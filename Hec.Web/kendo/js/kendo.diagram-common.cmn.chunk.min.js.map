{"version":3,"sources":["raw-js/kendo.diagram-common.cmn.chunk.js"],"names":["global","factory","exports","module","require","define","amd","globalThis","self","kendo","_globals","DiagramCommonCmnChunk","DrawingCmnChunk","CommonCmnChunk","this","kendo_drawing_cmn_chunk_js","kendo_common_cmn_chunk_js","WIDTH","HEIGHT","X","Y","TRANSPARENT","START$1","END$1","Markers","none","arrowStart","filledCircle","arrowEnd","DEG_TO_RAD","Math","PI","EPSILON","CHANGE$1","Cursors","arrow","grip","cross","add","move","select","south","east","west","north","rowresize","colresize","HIT_TEST_DISTANCE","AUTO","TOP","RIGHT","LEFT","BOTTOM","DRAG_START","DRAG","DRAG_END","ITEMROTATE","ITEMBOUNDSCHANGE","MOUSE_ENTER","MOUSE_LEAVE","ZOOM_START","ZOOM_END","PAN","ROTATED","SOURCE","TARGET","HANDLE_NAMES","ConnectionEditing","CASCADING","MAXINT","SELECT$1","NONE","MAX_VALUE","Number","MIN_VALUE","TRANSFORMED","isNearZero","value","abs","isDefined","obj","defined","isFunction$1","isUndefined","isObject","Object","has","key","hasOwnProperty","call","isString$1","prototype","toString","isNumber","isNaN","parseFloat","isFinite","isEmpty","Array","isArray","length","simpleExtend","destination","source","name","initArray","size","array","i","randomInteger","lower","upper","random","floor","parseInt","DFT","el","func","childNodes","item","findRadian","start","end","sngXComp","x","sngYComp","y","atan","sign","num","findAngle","center","forEach","arr","iterator","thisRef","getAny","predicate","remove","what","ax","indexOf","splice","contains","includes","inArray","grep$1","filter","fold","list","acc","context","initial","undefined","Error","find","bind","first","constraint","insert","element","position","all","result","clear","bisort","a","b","sortfunc","points","push","sort","m","n","addRange","range","noop$1","STRING","FUNCTION","preventDefault$2","_defaultPrevented","isDefaultPrevented","Observable","constructor","options","events","_events","destroy","unbind","event","handlers","one","eventNames","handlersIsFunction","original","handler","idx","eventName","args","apply","String","from","curName","unshift","trigger","eventArgs","e","sender","preventDefault","slice","_setEvents","Utils$1","freeze","__proto__","deserializePoints","s","v","split","getMatrixAngle","d","atan2","getMatrixScaling","sqrt","c","grep","isBoolean","isFunction","isString","isType","type","noop","serializePoints","res","p","join","Easing","easeInOut","pos","cos","Ticker","adapters","target","tick","interval","duration","lastTime","timerDelegate","intervalId","caller","onTimerEvent","addAdapter","onComplete","removeHandler","h","onStep","seekTo","to","seekFromTo","max","min","Date","getTime","window","setInterval","stop","clearInterval","play","origin","initState","reverse","propagate","update","now","timePassed","movement","randomId","chars","charAt","round","HashTable","_buckets","_createGetBucket","get","_bucketExists","set","containsKey","hashId","_hash","hashes","_hashes","len","hash","bucket","clone","ht","_hashString","_objectHashId","console","log","charCodeAt","id","_hashId","Dictionary","dictionary","super","_hashTable","k","entry","forEachValue","forEachKey","keys","Geometry","_distanceToLineSquared","d2","pt1","pt2","vx","vy","dot","distanceToLine","distanceToPolyline","minimum","p1","p2","Polar","r","angle","Point","P","plus","minus","offset","times","normalize","lengthSquared","middleOf","q","toPolar","useDegrees","factor","halfpi","isOnLine","temp","r1","Rect","inflate","r2","o1","u1","union","height","width","parse","str","xy","point","dx","dy","x1","y1","x2","y2","top","right","bottom","left","topLeft","topRight","bottomLeft","bottomRight","equals","rect","rotatedBounds","rotatedPoints","tl","tr","br","bl","rotate","delimiter","scale","scaleX","scaleY","staicPoint","adornerCenter","thisCenter","delta","scaled","zoom","overlaps","rectBottomRight","toRect","empty","fromPoints","RectAlign","container","align","content","alignment","alignValues","toLowerCase","_singleAlign","_align","_left","_center","_right","stretch","_stretch","_top","middle","_middle","_bottom","alignCalc","Queue","_tail","_head","enqueue","next","dequeue","current","OBJECT","deepExtendOne","property","propValue","propType","propInit","destProp","deepExtend","sources","LayoutDefaultOptions","subtype","roots","animate","limitToView","friction","nodeDistance","iterations","horizontalSeparation","verticalSeparation","underneathVerticalTopOffset","underneathHorizontalOffset","underneathVerticalSeparation","grid","offsetX","offsetY","componentSpacingX","componentSpacingY","layerSeparation","layeredIterations","startRadialAngle","endRadialAngle","radialSeparation","radialFirstLevelSeparation","keepComponentsInOneRadialLayout","ignoreContainers","layoutContainerChildren","ignoreInvisible","animateTransitions","LayoutBase","defaultOptions","gridLayoutComponents","components","calcBounds","bounds","maxWidth","startX","resultLinkSet","resultNodeSet","component","pop","moveToOffset","nodes","links","boundingRect","currentHeight","currentWidth","j","deltaX","deltaY","node","nodeBounds","link","newPoints","pt","currentHorizontalOffset","transferOptions","LayoutState","diagram","graphOrNodes","nodeMap","linkMap","capture","diagramOrGraphOrNodes","shape","conn","associatedShape","visual","associatedConnection","shapes","connections","Node$1","Node","outgoing","incoming","weight","data","isVirtual","shortForm","isIsolated","isLinkedTo","getComplement","getChildren","children","getParents","parents","copy","balance","owner","adjacentTo","removeLink","hasLinkTo","degree","incidentWith","getLinksWith","getNeighbors","neighbors","Link","connection","sourceFound","targetFound","getCommonNode","isBridging","v1","v2","getNodes","changeSource","changeTarget","changesNodes","w","oldSource","oldTarget","directTo","createReverseEdge","reversed","Graph","idOrDiagram","_nodeMap","_root","_hasCachedRelationships","componentIndex","cacheRelationships","forceRebuild","assignLevels","startNode","visited","level","child","root","found","getConnectedComponents","setItemIndices","componentId","_collectConnectedNodes","addNodeAndOutgoings","setIds","nodeIndex","nextId","index","getSpanningTree","tree","map","rootClone","remaining","_addNode","levelCount","ni","cn","newLink","addLink","treeLevels","takeRandomNode","excludedNodes","incidenceLessThan","pool","isHealthy","hasNode","sourceOrLink","addExistingLink","foundSource","getNode","addNode","foundTarget","removeAllLinks","hasLink","t","linkOrId","nodeOrId","_removeNode","removeNode","areConnected","n1","n2","layoutRect","newNode","newLinks","saveMapping","save","nOriginal","nCopy","linkOriginal","linkCopy","linearize","addIds","Utils","depthFirstTraversal","action","foundNode","_dftIterator","breadthFirstTraversal","queue","_stronglyConnectedComponents","excludeSingleItems","indices","lowLinks","connected","stack","findCycles","isAcyclic","isSubGraph","other","otherArray","thisArray","makeAcyclic","oneNode","rev","N","intensityCatalog","flowIntensity","catalogEqualIntensity","intensity","sourceStack","targetStack","targets","li","targetLink","si","sourceLink","ri","ril","u","concat","vertexOrder","kk","reversedEdges","Predefined","EightGraph","Mindmap","ThreeGraph","BinaryTree","levels","createBalancedTree","Linear","Tree","siblingsCount","Forest","trees","createBalancedForest","Workflow","Grid","g","previous","graphString","previousLink","graph","parts","part","lin","_addShape","kendoDiagram","shapeDefaults","radius","fill","undoable","addShape","_addConnection","connect","createDiagramFromGraph","doLayout","randomSize","clientWidth","clientHeight","opt","color","gli","sourceShape","targetShape","SpringLayout","layoutGraph","shi","news","counter","lastAdded","parent","treeCount","createRandomConnectedGraph","nodeCount","maxIncidence","isTree","poolNode","randomAdditions","randomDiagram","shapeCount","layout","DiagramToHyperTreeAdapter","convert","finalNodeSet","initialTemperature","temperature","guessBounds","_expectedBounds","step","refineStage","_repulsion","_attraction","_shake","rho","alpha","sin","_InverseSquareForce","force","deltax","deltay","wn","hn","wm","hm","pow","_SquareForce","distance","squareSize","area","ceil","shapeMap","edges","edgeMap","finalNodes","finalLinks","ignoredConnections","ignoredShapes","hyperMap","hyperTree","finalGraph","_renormalizeShapes","_renormalizeConnections","l","mapConnection","mapShape","getEdge","listToRoot","containerGraph","parentContainer","firstNonIgnorableContainer","isContainer","isIgnorableItem","isContainerConnection","isDescendantOf","scope","containers","isCollapsed","_isVisible","_isTop","isShapeMapped","leastCommonAncestor","al","xa","xb","visible","_isCollapsed","sourceConnector","sink","targetConnector","sourceNode","sinkNode","areConnectedAlready","newEdge","intersectLine","start1","end1","start2","end2","isSegment","tangensdiff","Intersect","lines","segments","rectWithLine","rects","rect1","rect2","intersect","reverseAngle","MatrixVector","f","fromMatrix","Matrix","applyRect","fromSVGMatrix","vm","fromMatrixVector","fromList","translation","unit","rotation","scaling","nums","trim","substr","PathDefiner","Size","Empty","Rotation","toMatrix","invert","create","values","ZERO","Scale","Translation","toMatrixVector","Length","CompositeTransform","translate","transform","render","_transform","_renderTransform","rotateMatrix","scaleMatrix","translatePoint","diffNumericOptions","fields","elementOptions","field","hasChanges","Element","_originSize","drawingContainer","redraw","drawingElement","matrix","M","_hover","_diffNumericOptions","_measure","_measured","box","_boundingBox","R","startPoint","_originWidth","_originHeight","rawBBox","sizeOptionsOrDefault","normalizeDrawingOptions","drawingOptions","getColor","C","toHex","createSegment","S","toDrawingRect","defaultOptions$a","stroke","VisualBase","opacity","_fill","_stroke","show","hover","strokeOptions","dashType","fillOptions","gradient","GradientClass","L","defaultOptions$9","MarkerBase","anchor","createElement","_transformToPath","path","transformCopy","defaultOptions$8","ArrowMarker","positionMarker","_linePoints","transform$1","xDiff","yDiff","lineAngle","endPoint","targetSegment","controlOut","nextSegment","controlIn","prevSegment","Canvas$1","_translate","viewBox","_viewBox","surface","G","clippedBBox","setSize","draw","append","insertBefore","clearHtml","firstChild","removeChild","removeChildren$1","AutoSizeableMixin","_setScale","originWidth","originHeight","_setTranslate","_initSize","autoSize","_updateSize","Circle","_initCircle","circleOptions","_circle","setRadius","defaultOptions$7","CircleMarker","Group","_childrenChange","_remove","removeAt","toFront","visuals","toBack","_reorderChildren","toIndex","group","drawingChildren","fixedPosition","boundingBox","childBoundingBox","_includeInBBox","Image","_initImage","src","_rect","I","sizeOptions","MarkerPathMixin","_getPath","paths","_normalizeMarkerOptions","startCap","endCap","_removeMarker","marker","_markers","_createMarkers","_createMarker","markerType","_positionMarker","_capMap","_redrawMarker","pathChange","pathOptions","cap","pathCapType","optionsCap","created","_redrawMarkers","Path","_createElements","_setData","multipath","elements","Polyline","_initPath","_updatePath","_pointsDiffer","currentPoints","differ","Rectangle","_setPosition","_drawPath","closed","textColor","defaultOptions$6","fontSize","fontFamily","TextBlock","_font","_initText","T","text","font","fontOptions","fontStyle","fontWeight","sizeChanged","textOptions","LayeredLayout","_initRuntimeProperties","layer","downstreamLinkCount","upstreamLinkCount","uBaryCenter","dBaryCenter","upstreamPriority","downstreamPriority","gridPosition","_prepare","layerMap","targetLayer","layerCount","shift","sortedNodes","o2","o1layer","o2layer","minLayer","layers","linksTo","layerVal","_dummify","_optimizeCrossings","_swapPairs","arrangeNodes","_moveThingsAround","_dedummify","setMinDist","_n","minDist","layerIndex","isInteger","minDistances","getMinDist","dist","i1","i2","placeLeftToRight","leftClasses","leftPos","classNodes","placeLeft","POSITIVE_INFINITY","rightSibling","nodeLeftClass","D","upNodes","downNodes","neighbor","intDiv","placeRightToLeft","rightClasses","rightPos","placeRight","NEGATIVE_INFINITY","leftSibling","nodeRightClass","_getLeftWing","leftWing","computeClasses","_getRightWing","rightWing","wingPair","currentWing","wing","ndsinl","_nodesInLink","vnode","wings","classIndex","_isVerticalLayout","_isHorizontalLayout","_isIncreasingLayout","_gridPositionComparer","gNode","dest","down","up","currentNode","currDown","downNode","order","placed","sequenceStart","ll","layer2","virtualStartIndex","_firstVirtualNode","virtualStart","sequence","_sequencer","virtualEnd","nextVirtualNode","virtualEndIndex","adjustDirections","fromLayerIndex","layerIncrement","maximumHeight","ctx","nn","node2","prevBridge","prevBridgeTarget","nextBridge","nextBridgeTarget","getNeighborOnLayer","clayer","j1","j2","dir","_sequenceSingle","combineSequences","leftHeap","pair","_positionDescendingComparer","rightHeap","_positionAscendingComparer","leftRes","rightRes","leftClass","_getComposite","rightClass","it","layoutLayer","gridPos","iconsidered","considered","sorted","n1Priority","n2Priority","nodeGridPos","nodeBaryCenter","calcBaryCenter","nodePriority","moveRight","moveLeft","calcDownData","calcUpData","priority","rightNode","rightNodePriority","leftNode","leftNodePriority","mapVirtualNode","nodeToLinkMap","linkToNodeMap","addLinkBetweenLayers","upLayer","downLayer","o","oLayer","dLayer","oPos","dPos","depthOfDumminess","dedum","prevLink","moves","iter","optimizeLayerCrossings","Set","sum","total","presorted","n1BaryCenter","n2BaryCenter","compareByIndex","compareValue","inode","maxIterations","downwards","secondPass","hasSwapped","calcCrossings","memCrossings","crossBefore","countLinksCrossingBetweenTwoLayers","node1","node1GridPos","node2GridPos","crossAfter","revert","ulayer","dlayer","link1","link2","n11","n12","n21","n22","l1","l2","crossings","n11gp","n12gp","numerator","denominator","TreeLayoutProcessor","treeGraph","layoutSwitch","layoutLeft","setChildrenDirection","setChildrenLayout","TreeDirection","measure","arrange","layoutRight","layoutUp","layoutDown","treeDirection","layoutRadialTree","previousRoot","startAngle","endAngle","maxDepth","calculateAngularWidth","radialLayout","Angle","tipOverTree","startFromLevel","diameter","aw","sectorAngle","sortChildren","basevalue","pl","nl","normalizeAngle","count","col","deltaTheta","deltaThetaHalf","parentSector","fraction","childNode","cp","childAngleFraction","setPolarLocation","BoundingRectangle","direction","includeStart","rootDirection","rootLayout","childrenLayout","givenSize","shapeWidth","shapeHeight","AngleToParent","SectorAngle","pp","childrenwidth","selfLocation","single","male","female","leftcount","tipOverTreeStartLevel","TreeLayout","adapter","layoutComponents","getTree","getTreeForRoot","AdornerBase","_adorners","refresh","ConnectionEditUndoUnit","undoSource","undoTarget","_undoSource","_undoTarget","_redoSource","_redoTarget","title","undo","_updateConnector","updateModel","redo","isAutoConnector","connector","closestConnector","connectors","resCtr","minimumDistance","distanceTo","indicesOfItems","filterShapeDataItem","dataItem","RotateUnit","adorner","undoRotates","redoRotates","redoAngle","_angle","_innerBounds","_initialize","defaultOptions$5","Connector","getPosition","toJSON","shapeId","tempStr","getConnector","DefaultConnectors","extra","defaults","minWidth","minHeight","editable","tools","defaultOptions$4","cursor","selectable","serializable","enable","DiagramElement","isSelected","_template","_getCursor","serialize","json","_content","contentOptions","_contentVisual","_updateContentVisual","_createContentVisual","_hitTest","template","elementTemplate","kendoTemplate","paramName","_canSelect","Shape","updateOptionsFromModel","createShapeVisual","updateBounds","_createConnectors","_setOptionsFromModel","model","modelOptions","redrawVisual","_isEditable","_redrawVisual","syncChanges","updateShapeModel","_rotate","_alignContent","contentVisual","containerRect","aligner","contentBounds","bbox","contentRect","alignedBounds","connectorDefaults","_transformedBounds","pan","_pan","_rotatedBounds","_bounds","_setBounds","_triggerBoundsChange","_layouting","refreshConnections","cloneDataItem","selected","deselected","_selectedItems","_internalSelection","_selectionChanged","undoRedoService","_resizingAdorner","sc","deltaAngle","newPosition","_rotationOffset","_connectorsAdorner","con","cons","ctr","nameOrPoint","toLocaleLowerCase","side","fnName","_transformPoint","boundsChange","shapeOptions","shapeVisual","_visualOptions","_updateConnectors","modelToView","_showConnectors","rotatedPoint","visualOptions","visualTemplate","translateToOrigin","ConnectionEditAdorner","handles","_ts","toolService","sp","sourcePoint","tp","targetPoint","spVisual","epVisual","handle","_initialSource","_initialTarget","_connectionManipulation","ts","hoveredItem","_hoveredConnector","_c","radiusX","radiusY","sourcePointDistance","targetPointDistance","sourceHandle","targetHandle","modelToLayer","ConnectorVisual","relative","_visualBounds","ConnectorsAdorner","_refreshHandler","_visible","_clearVisual","_cachedTouchTarget","_keepCachedTouchTarget","visualChildren","childrenCount","canDrag","drag","TransformUnit","undoStates","redoStates","refreshBounds","defaultOptions$3","ResizingAdorner","_manipulating","_initSelection","_createHandles","_internalChange","_rotatedHandler","_resizable","resize","_handleOptions","handlesCount","hit","handleBounds","_getHandleBounds","items","_startAngle","_rotates","_positions","initialRotates","initialStates","handleOptions","_sp","_cp","_lp","shapeStates","visibleHandles","currentAngle","dragging","newBounds","staticPoint","dtl","dbr","changed","_truncateAngle","_rotating","shouldSnap","thr","_truncateDistance","isDragHandle","hitToOppositeSide","_displaceBounds","newCenter","oldBounds","cancel","states","_truncatePositionToGuides","ruler","truncatePositionToGuides","_truncateSizeToGuides","truncateSizeToGuides","snap","snapOptions","snapAngle","snapSize","_diffStates","_syncShapeChanges","rotationThumb","thumb","_rotationThumbBounds","defaultOptions$2","Selector","_ep","_adorn","visualBounds","ConnectionRouterBase","LinearConnectionRouter","hitTest","getBounds","allPoints","CascadingRouter","SAME_SIDE_DISTANCE_RATIO","_connectorSides","axis","boundsPoint","secondarySign","routePoints","_connectorPoints","_floatingPoints","route","_resolvedSourceConnector","_resolvedTargetConnector","_connectorSide","shapeBounds","sides","sideDistance","minSide","_sameSideDistance","sourceConnectorSide","targetConnectorSide","sameSideDistance","pointX","pointY","cascadeStartHorizontal","_startHorizontal","shiftX","shiftY","sourceSide","horizontal","PolylineRouter","ConnectionEditTool","tryActivate","_p","meta","isActive","ctrlKey","selectSingle","connectionHandle","handleName","_syncConnectionChanges","getCursor","ConnectionTool","_createConnection","_removeHover","activeConnection","cachedTouchTarget","EmptyTool","noMeta","altKey","shiftKey","PointerTool","eventMap","queryEventMap","applyEventMap","replace","getSupportedFeatures","os","ua","agentRxs","wp","fire","android","iphone","ipad","playbook","windows","tizen","sailfish","osRxs","ios","flat","agent","match","navigator","device","testRegex","detectOS","userAgent","support","mobileOS","regexes","dflt","regex","test","extend$1","assign","addClass","className","classList","convertToHtml","html","div","document","innerHTML","prepend","originElement","elementOffset$1","TapCapture","domElement","_pressHandler","_press","_releaseHandler","_release","addEventListener","captureNext","cancelCapture","removeEventListener","PaneDimension","forcedEnabled","scrollSize","makeVirtual","virtual","_virtualMin","_virtualMax","virtualSize","outOfBounds","forceEnabled","getSize","getTotal","rescale","silent","scaledTotal","minScale","centerOffset","enabled","PaneDimensions","forcedMinScale","maxScale","newScale","centerCoordinates","fitScale","PaneAxis","dimension","movable","dragMove","dragDelta","resistance","translateAxis","Pane","elastic","dimensions","userEvents","gesturestart","gesture","press","closestAnchor","closest","matches","gesturechange","previousGesture","previousCenter","scaleDelta","coordinates","scaleWith","tagName","touch","skip","Movable","style","transformOrigin","_saveCoordinates","by","scaleTo","moveAxis","moveTo","newCoordinates","animationFrame","callback","requestAnimationFrame","Animation","_tickProxy","_tick","_started","done","onEnd","onCancel","Transition","startDate","location","_easeProxy","ease","easeOutExpo","elementEventHandlers","WeakMap","ID","Symbol","on","useCapture","eventFilter","eventHandler","attachedHandler","closestMatchingTarget","currentTarget","defineProperty","guid","eventHandlers","Map","Boolean","addEventListeners","off","handlerId","delete","removeEventListeners","preventDefault$1","PRESS","HOLD","SELECT","START","MOVE","END","CANCEL","TAP","DOUBLETAP","RELEASE","GESTURECHANGE","GESTUREEND","GESTURETAP","THRESHOLD","api","mouse","pointer","DEFAULT_MIN_HOLD","DEFAULT_THRESHOLD","getTouches","touches","originalEvent","pointerId","TouchAxis","invalidZeroEvents","_updateLocationData","startLocation","velocity","timeStamp","timeDelta","initialDelta","client","screen","Touch","touchInfo","threshold","initialTouch","pressEvent","_clicks","supportDoubleTap","_moved","_finished","_holdTimeout","setTimeout","_hold","minHold","_trigger","_tap","_clickTimeout","preventMove","_shouldNotMove","_withinIgnoreThreshold","UserEvents","dispose","_start","endTime","clearTimeout","activeTouches","activeTouchIndex","isMoved","startTime","notify","xDelta","yDelta","withEachUpEvent","downEvents","_maxTouches","multiTouch","allowSelection","captureUpIfMoved","stopPropagation","pressed","_surfaceMoveHandler","_move","_surfaceEndHandler","_end","_elementStartHandler","touchAction","preventDragEvent","_elementDragStartHandler","_elementSelectHandler","_select","surfaceElement","preventIfMovingProxy","preventIfMoving","_isMoved","_destroyed","_disposeAll","_isMultiTouch","touch1","touch2","touchDelta","_apiCall","_maxTouchesReached","which","eventTouches","eventTouch","_eachTouch","methodName","dict","matchingTouch","hasPointerCapture","setPointerCapture","pageX","pageY","clientX","clientY","defaultThreshold","extend","CHANGE","SCROLL","ZoomSnapBack","tapCapture","DragInertia","transition","_moveTo","paneAxis","_snapBack","velocityMultiplier","snapBack","AnimatedScroller","_to","_updateCoordinates","setCoordinates","setCallback","ScrollBar","elementSize","scrollMovable","alwaysVisible","appendChild","paneSize","sizeRatio","display","visibility","hide","defaultScrollerOptions","pullOffset","visibleScrollHints","useNative","mousewheelScrolling","avoidScrolling","pullToRefresh","messages","pullTemplate","releaseTemplate","refreshTemplate","Scroller","_initOptions","hasScrolling","hasNativeScrolling","_native","scrollHeader","scrollElement","fixedContainer","overflow","wrapper","wrapInner","inner","velocityX","velocityY","horizontalSwipe","verticalSwipe","pane","zoomSnapBack","animatedScroller","scrollTo","scrollTop","scrollLeft","_wheelScrollHandler","_wheelScroll","pulled","_initAxis","_wheelEnd","_wheel","_wheelY","_initPullToRefresh","_wheelTimeout","wheelDeltaY","wheelDelta","detail","VERTICAL_AXIS","scrollHeight","scrollWidth","_resize","contentResized","setOptions","reset","_scale","zoomOut","disable","animatedScrollTo","pullHandled","_dragEnd","_paneChange","scrollBar","ScrollerTool","canvas","_mobileOS","scroller","scrollable","scroll","movableCanvas","virtualScroll","pannable","hoveredAdorner","scrollPos","_storePan","SelectionTool","multiple","deselect","selector","selectArea","testKey","toUpperCase","ConnectionEditUnit","redoSource","redoTarget","defaultOptions$1","fromConnector","toConnector","Connection","_initRouter","_sourcePoint","_targetPoint","_setSource","_setTarget","definers","dataMap","_dataMap","fromX","fromY","toX","toY","filterConnectionDataItem","updateConnectionModel","shapeSource","defaultConnector","_removeFromSourceConnector","_clearSourceConnector","_setFromOptions","addCompositeItem","fromPoint","sourceDefiner","_sourceDefiner","shapeTarget","_removeFromTargetConnector","_clearTargetConnector","_setToOptions","toPoint","targetDefiner","_targetDefiner","instance","getShapeById","connectorName","setNewTarget","inactiveItem","_inactiveShapeItems","getByUid","uid","_deferredConnectionUpdates","onActivate","endIdx","startIdx","alignToPath","midIdx","selection","_router","pts","definition","_resolveConnectors","_refreshPath","sourceConnectors","targetConnectors","_resolveAutoConnectors","minNonConflictSource","minNonConflictTarget","minSource","minTarget","sourceIdx","targetIdx","minNonConflict","_testRoutePoints","router","passRoute","exclude","_getRouteExclude","_shapesQuadTree","hitTestRect","_isPointInsideShape","boundsX","boundsY","ToolService","activeTool","_updateHoveredItem","_activateTool","_updateCursor","focus","suspendTracking","updateHovered","resumeTracking","keyDown","metaKey","toRemove","_triggerRemove","_syncChanges","_destroyToolBar","_discardNewConnection","selectAll","cut","paste","wheel","z","zoomRate","zoomOptions","zoomMin","zoomMax","setTool","tool","addToSelection","newConnection","disabledShape","isNew","selectedConnections","_hitTestItems","_hitTestElements","shapeHit","connectionHit","hitTestShapeConnectors","mainLayer","AddConnectionUnit","AddShapeUnit","CompositeUnit","units","undoUnit","DeleteConnectionUnit","DeleteShapeUnit","PositionAdapter","layoutState","froms","tos","subjects","LayoutUndoUnit","initialState","finalState","_initialState","_finalState","setState","state","ticker","ToBackUnit","initialIndices","_toIndex","ToFrontUnit","UndoRedoService","capacity","begin","composite","commit","execute","_restart","InactiveItem","callbacks","Promise","resolve","activate","InactiveItemsCollection","QuadRoot","_add","_quadNode","_testRect","QuadNode","inBounds","nodeRect","nodeBottomRight","overlapsBounds","inserted","_initChildren","halfWidth","halfHeight","childIdx","shapeIdx","ShapesQuadTree","ROOT_SIZE","boundsChangeHandler","_boundsChange","initRoots","rootMap","rootSize","sectors","getSectors","inRoot","bottomX","bottomY","xIdx","yIdx","copyDefaultOptions","mainOptions","theme","dataSource","draggable","autoBind","tooltip","format","connectionDefaults","splitDiagramElements","outerHeight","includeMargins","heightValue","offsetHeight","getComputedStyle","marginTop","marginBottom","$","A","B","E","F","H","J","K","O","Q","Infinity","curK","rangeIntegerScale","resource","kv","toArray","U","V","W","Z","_","__meta__","category","description","depends","hidden","chunk","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","initialPosition","finalPosition","finalPos","ae","af","ag","ah","ai","aj","ak","am","an","ao","ap","aq","ar","as","at","au","userOptions","themeOptions","_clipboard","_connectionsDataMap","createToolBar","destroyToolBar","_initTheme","_initElements","_extendLayoutOptions","_initDefaults","_interactionDefaults","_initCanvas","adornerLayer","_createHandlers","pauseMouseHandlers","_createShape","setAttribute","userShapeDefaults","mobile","canvasContainer","viewPort","viewport","Canvas","_wheelHandler","_keydownHandler","_keydown","browser","mobilesafari","_userEvents","fastTap","tap","_dragStart","_drag","_gestureStart","_gestureChange","gestureend","_gestureEnd","doubleTap","_doubleTap","_mouseoverHandler","_mouseover","_mouseoutHandler","_mouseout","_mouseMoveHandler","_mouseMove","_mouseDownHandler","_mouseDown","_mouseUpHandler","_mouseUp","_initResizeObserver","observer","ResizeObserver","entries","_resizeObserver","observe","_destroyResizeObserver","disconnect","_pauseMouseHandlers","_eventPositions","_meta","focused","ctrlPressed","keyCode","mwDelta","documentToModel","initialCenter","_gesture","_initialCenter","documentToView","_zoom","updateZoom","_getValidZoom","zoomedPoint","_panTransform","_updateAdorners","pointPosition","toolBar","_kendoNode","srcElement","_createOptionElements","shapesLength","_createShapes","_createConnections","_findConnectionTarget","destroyScroller","_destroyGlobalToolBar","ownerDocument","activeElement","offsets","documentElement","scrollContainer","parentNode","preventScroll","load","addConnection","added","removed","_parseBounds","_suspendModelRefresh","_removeItem","_resumeModelRefresh","_shouldRefresh","_suspended","_addConnections","_addConnectionDataItem","_validateConnector","_addDataItems","parentShape","_addDataItemByUid","resolvedOptions","_getDiagramItems","_fixOrdering","bringIntoView","_zoomMainLayer","newPan","alignShapes","val","raw","hideTooltip","_getPan","paddingLeft","paddingRight","elementWidth","paddingTop","paddingBottom","elementHeight","_copyOffset","copied","mapping","_updateCopiedConnection","sourceConnection","di","_containerOffset","containerOffset","getBoundingClientRect","doc","defaultView","scrollX","scrollY","elementOffset","viewToDocument","viewToModel","_transformWithMatrix","_matrixInvert","_matrix","_layerMatrix","layerToModel","_layerMatrixInvert","viewPoint","modelToDocument","_redrawConnections","getShapeByModelId","shapeResult","getShapeByModelUid","_transformMainLayer","_finishPan","NaN","_storeViewMatrix","_storeLayerMatrix","canvasTransform","shapePos","conPos","_addItem","_toolBarClick","_normalizePointZoom","undone","redone","adorners","_refresh","removedConnections","_removeShapeDataItem","_removeShape","_removeConnectionDataItem","_removeConnection","_removeShapeConnections","exportDOMVisual","scrollOffset","viewRect","clipPath","fromRect","wrap","clipWrap","clip","exportVisual","av","ay","mean","deviation","drawingRect","reflow"],"mappings":";;;;;;;;CAAA,SAAAA,EAAAC,GACA,iBAAAC,SAAA,oBAAAC,OAAAF,EAAAC,QAAAE,QAAA,8BAAAA,QAAA,8BACA,mBAAAC,QAAAA,OAAAC,IAAAD,OAAA,CAAA,UAAA,8BAAA,8BAAAJ,GACAA,IAAAD,EAAA,oBAAAO,WAAAA,WAAAP,GAAAQ,MAAAC,MAAAT,EAAAS,OAAA,CAAA,EAAAT,EAAAS,MAAAC,SAAAV,EAAAS,MAAAC,UAAA,CAAA,EAAAV,EAAAS,MAAAC,SAAAC,sBAAA,CAAA,GAAAX,EAAAS,MAAAC,SAAAE,gBAAAZ,EAAAS,MAAAC,SAAAG,eACA,CAJA,CAIAC,MAAA,SAAAZ,EAAAa,EAAAC,GACA,MAWAC,EAAA,QACAC,EAAA,SACAC,EAAA,IACAC,EAAA,IAEAC,EAAA,cACAC,EAAA,QACAC,EAAA,MACAC,EAAA,CACAC,KAAA,OACAC,WAAA,aACAC,aAAA,eACAC,SAAA,YAEAC,EAAAC,KAAAC,GAAA,IACAC,EAAA,KACAC,EAAA,SACAC,EAAA,CACAC,MAAA,UACAC,KAAA,UACAC,MAAA,UACAC,IAAA,UACAC,KAAA,OACAC,OAAA,UACAC,MAAA,WACAC,KAAA,WACAC,KAAA,WACAC,MAAA,WACAC,UAAA,aACAC,UAAA,cAEAC,EAAA,GAAAC,EAAA,OAAAC,EAAA,MAAAC,EAAA,QAAAC,EAAA,OAAAC,EAAA,SAAAC,EAAA,YAAAC,EAAA,OAAAC,EAAA,UAAAC,EAAA,aAAAC,EAAA,mBAAAC,EAAA,aAAAC,EAAA,aAAAC,EAAA,YAAAC,EAAA,UAAAC,EAAA,MAAAC,EAAA,UAAAC,EAAA,SAAAC,EAAA,SAAAC,EAAA,CACA,KAAAF,EACA,EAAAC,GAEAE,EAAA,qBACAC,EAAA,YAAAC,EAAA,iBAAAC,EAAA,SAAAC,EAAA,OAAAC,EAAAC,OAAAD,UAAAE,GAAAD,OAAAD,UAAAG,EAAA,cAEAC,EAAAC,GAAA/C,KAAAgD,IAAAD,GAAA7C,EACA+C,EAAAC,QAAA,IAAAA,EACAC,EAAAF,EACAG,EAAAF,GAAA,mBAAAA,EACAG,EAAAH,GAAA,MAAAA,EAIAI,EAAAJ,GAAAA,IAAAK,OAAAL,GAIAM,EAAA,CAAAN,EAAAO,IAAAF,OAAAG,eAAAC,KAAAT,EAAAO,GAIAG,EAAAV,GACA,oBAAAK,OAAAM,UAAAC,SAAAH,KAAAT,GAWAa,EAAAb,IAAAc,MAAAC,WAAAf,KAAAgB,SAAAhB,GAIAiB,EAAAjB,IACA,GAAA,OAAAA,EACA,OAAA,EAEA,GAAAkB,MAAAC,QAAAnB,IAAAU,EAAAV,GACA,OAAA,IAAAA,EAAAoB,OAEA,IAAA,MAAAb,KAAAP,EACA,GAAAM,EAAAN,EAAAO,GACA,OAAA,EAGA,OAAA,CAAA,EAEAc,EAAA,CAAAC,EAAAC,KACA,GAAAnB,EAAAmB,GAGA,IAAA,MAAAC,KAAAD,EACAC,IACAF,EAAAE,GAAAD,EAAAC,GAEA,EASAC,GAAA,CAAAC,EAAA7B,KACA,MAAA8B,EAAA,GACA,IAAA,IAAAC,EAAA,EAAAA,EAAAF,IAAAE,EACAD,EAAAC,GAAA/B,EAEA,OAAA8B,CAAA,EA+BAE,GAAA,CAAAC,EAAAC,KACA,MAAAC,EAAAlF,KAAAmF,MAAAnF,KAAAkF,SAAAD,GAAAD,EACA,OAAAI,SAAAF,EAAApB,WAAA,GAAA,EAKAuB,GAAA,CAAAC,EAAAC,KAEA,GADAA,EAAAD,GACAA,EAAAE,WACA,IAAA,IAAAV,EAAA,EAAAA,EAAAQ,EAAAE,WAAAlB,OAAAQ,IAAA,CACA,MAAAW,EAAAH,EAAAE,WAAAV,GACAO,GAAAI,EAAAF,EACA,CACA,EAmBAG,GAAA,CAAAC,EAAAC,KACA,GAAAD,IAAAC,EACA,OAAA,EAEA,MAAAC,EAAAD,EAAAE,EAAAH,EAAAG,EACAC,EAAAJ,EAAAK,EAAAJ,EAAAI,EACAC,EAAAjG,KAAAiG,KAAAJ,EAAAE,GACA,OAAAA,GAAA,EACAF,EAAA,EAAAI,EAAA,EAAAjG,KAAAC,GAAAgG,EAEAA,EAAAjG,KAAAC,EAAA,EAEAiG,GAAAC,GACAA,EAAAA,EAAA,GAAA,EAAA,EAAA,EAEAC,GAAA,CAAAC,EAAAT,IACA,IAAAF,GAAAW,EAAAT,GAAA5F,KAAAC,GAEAqG,GAAA,CAAAC,EAAAC,EAAAC,KACA,IAAA,IAAA3B,EAAA,EAAAA,EAAAyB,EAAAjC,OAAAQ,IACA0B,EAAA7C,KAAA8C,EAAAF,EAAAzB,GAAAA,EAAAyB,EACA,EAEAG,GAAA,CAAAH,EAAAI,KACA,IAAA,IAAA7B,EAAA,EAAAA,EAAAyB,EAAAjC,SAAAQ,EACA,GAAA6B,EAAAJ,EAAAzB,IACA,OAAAyB,EAAAzB,GAGA,OAAA,IAAA,EAEA8B,GAAA,CAAAL,EAAAM,KACA,IAAAC,EAAAP,EAAAQ,QAAAF,GACA,MAAA,IAAAC,GACAP,EAAAS,OAAAF,EAAA,GACAA,EAAAP,EAAAQ,QAAAF,GAEA,OAAAN,CAAA,EAEAU,GAAA,CAAAV,EAAArD,KACAqD,GAAA,IAAAW,SAAAhE,GAEA6D,GAAA,CAAAR,EAAAM,IACAN,EAAAQ,QAAAF,GAEAM,GAAA,CAAAN,EAAAN,IACAA,EAAAQ,QAAAF,GAEAO,GAAA,CAAAb,EAAAI,IAAAJ,EAAAc,OAAAV,GACAW,GAAA,CAAAC,EAAAf,EAAAgB,EAAAC,KACA,IAAAC,OAAAC,IAAAH,EACA,IAAA,IAAA1C,EAAA,EAAAA,EAAAyC,EAAAjD,OAAAQ,IAAA,CACA,MAAA/B,EAAAwE,EAAAzC,GACA4C,EAKAF,EAAAhB,EAAA7C,KAAA8D,EAAAD,EAAAzE,EAAA+B,EAAAyC,IAJAC,EAAAzE,EACA2E,GAAA,EAKA,CACA,IAAAA,EACA,MAAA,IAAAE,MAAA,+CAEA,OAAAJ,CAAA,EAEAK,GAAA,CAAAtB,EAAAC,EAAAiB,IACAlB,EAAAsB,KAAArB,EAAAsB,KAAAL,UAAAE,EAEAI,GAAA,CAAAxB,EAAAyB,EAAAP,IACA,IAAAlB,EAAAjC,OACA,KAEAjB,EAAA2E,GACAzB,EAAA,GAEAsB,GAAAtB,EAAAyB,EAAAP,GAKAQ,GAAA,CAAA1B,EAAA2B,EAAAC,KACA5B,EAAAS,OAAAmB,EAAA,EAAAD,GACA3B,GAEA6B,GAAA,CAAA7B,EAAAC,EAAAiB,KACA,IACA1E,EADAsF,GAAA,EAEA,IAAA,IAAAvD,EAAA,EAAAA,EAAAyB,EAAAjC,SACAvB,EAAAwD,EAAAzB,GACAuD,EAAAA,GAAA7B,EAAA7C,KAAA8D,EAAA1E,EAAA+B,EAAAyB,GACA8B,GAHAvD,KAOA,OAAAuD,CAAA,EAEAC,GAAA/B,IACAA,EAAAS,OAAA,EAAAT,EAAAjC,OAAA,EAEAiE,GAAA,CAAAC,EAAAC,EAAAC,KACA,GAAArF,EAAAmF,GACA,MAAA,IAAAZ,MAAA,iCAEA,GAAAvE,EAAAoF,GACA,MAAA,IAAAb,MAAA,kCAEA,GAAAY,EAAAlE,SAAAmE,EAAAnE,OACA,MAAA,IAAAsD,MAAA,2CAEA,MAAAe,EAAA,GACA,IAAA,IAAA7D,EAAA,EAAAA,EAAA0D,EAAAlE,OAAAQ,IACA6D,EAAAC,KAAA,CAAA9C,EAAA0C,EAAA1D,GAAAkB,EAAAyC,EAAA3D,KAEAzB,EAAAqF,GACAC,EAAAE,MAAA,CAAAC,EAAAC,IAAAD,EAAAhD,EAAAiD,EAAAjD,IAGA6C,EAAAE,MAAA,CAAAC,EAAAC,IAAAL,EAAAI,EAAAhD,EAAAiD,EAAAjD,KAEAwC,GAAAE,GACAF,GAAAG,GACA,IAAA,IAAA3D,EAAA,EAAAA,EAAA6D,EAAArE,OAAAQ,IACA0D,EAAAI,KAAAD,EAAA7D,GAAAgB,GACA2C,EAAAG,KAAAD,EAAA7D,GAAAkB,EACA,EAEAgD,GAAA,CAAAzC,EAAA0C,KACA1C,EAAAqC,QAAAK,EAAA,EAEAC,GAAA,OAEAC,GAAA,SACAC,GAAA,WACAC,GAAA,WACArK,KAAAsK,mBAAA,CACA,EACAC,GAAA,WACA,OAAA,IAAAvK,KAAAsK,iBACA,EACA,MAAAE,GACA,WAAAC,GACAzK,KAAA0K,QAAA,CAAA,EACA1K,KAAA2K,OAAA,GACA3K,KAAA4K,QAAA,CAAA,CACA,CACA,OAAAC,GACA7K,KAAA8K,QACA,CACA,IAAAhC,CAAAiC,EAAAC,EAAAC,GACA,IAAAD,GAAA1G,EAAAyG,KAAA3F,MAAAC,QAAA0F,GAAA,CACA,IAAA,MAAArF,KAAAqF,EACAA,EAAArF,IACA1F,KAAA8I,KAAApD,EAAAqF,EAAArF,IAGA,OAAA1F,IACA,CACA,MAAAkL,SAAAH,IAAAZ,GAAA,CAAAY,GAAAA,EAAAI,SAAAH,IAAAZ,GACA,IAAAgB,EAAAC,EACA,IAAA,IAAAC,EAAA,EAAAhG,EAAA4F,EAAA5F,OAAAgG,EAAAhG,EAAAgG,IAAA,CACA,MAAAC,EAAAL,EAAAI,GACAD,EAAAF,EAAAH,EAAAA,EAAAO,GACAF,IACAJ,IACAG,EAAAC,EACAA,EAAA,IAAAG,KACAxL,KAAA8K,OAAAS,EAAAF,GACAD,EAAAK,MAAAzL,KAAAwL,EAAA,EAEAH,EAAAD,SAAAA,GAEApL,KAAA4K,QAAAW,GAAAvL,KAAA4K,QAAAW,IAAA,GACAvL,KAAA4K,QAAAW,GAAA3B,KAAAyB,GAEA,CACA,OAAArL,IACA,CACA,GAAAiL,CAAAC,EAAAF,GACA,OAAAhL,KAAA8I,KAAAoC,EAAAF,GAAA,EACA,CACA,KAAAjC,CAAAwC,EAAAP,GACA,MAAAE,SAAAK,IAAApB,GAAA,CAAAuB,OAAAH,IAAAnG,MAAAuG,KAAAJ,GAAAJ,SAAAH,IAAAZ,GACA,IAAAiB,EACA,IAAA,IAAAC,EAAA,EAAAhG,EAAA4F,EAAA5F,OAAAgG,EAAAhG,EAAAgG,IAAA,CACA,MAAAM,EAAAV,EAAAI,GACAD,EAAAF,EAAAH,EAAAA,EAAAY,GACAP,IACArL,KAAA4K,QAAAgB,GAAA5L,KAAA4K,QAAAgB,IAAA,GACA5L,KAAA4K,QAAAgB,GAAAC,QAAAR,GAEA,CACA,OAAArL,IACA,CACA,OAAA8L,CAAAP,EAAAQ,GACA,IAAApB,EAAA3K,KAAA4K,QAAAW,GACA,GAAAZ,EAAA,CACA,MAAAqB,EAAAD,GAAA,CAAA,EACAC,EAAAC,OAAAjM,KACAgM,EAAA1B,mBAAA,EACA0B,EAAAE,eAAA7B,GACA2B,EAAAzB,mBAAAA,GACAI,EAAAA,EAAAwB,QACA,IAAA,IAAAb,EAAA,EAAAhG,EAAAqF,EAAArF,OAAAgG,EAAAhG,EAAAgG,IACAX,EAAAW,GAAA3G,KAAA3E,KAAAgM,GAEA,OAAA,IAAAA,EAAA1B,iBACA,CACA,OAAA,CACA,CACA,MAAAQ,CAAAS,EAAAF,GACA,MAAAV,EAAA3K,KAAA4K,QAAAW,GACA,QAAA5C,IAAA4C,EACAvL,KAAA4K,QAAA,CAAA,OAEA,GAAAD,EACA,GAAAU,EACA,IAAA,IAAAC,EAAAX,EAAArF,OAAA,EAAAgG,GAAA,EAAAA,IACAX,EAAAW,KAAAD,GAAAV,EAAAW,GAAAF,WAAAC,GACAV,EAAA3C,OAAAsD,EAAA,QAKAtL,KAAA4K,QAAAW,GAAA,GAGA,OAAAvL,IACA,CACA,UAAAoM,CAAA1B,GACA,MAAApF,GAAAtF,KAAA2K,QAAA,IAAArF,OACA,IAAA,IAAAgG,EAAA,EAAAA,EAAAhG,EAAAgG,IAAA,CACA,MAAA5F,EAAA1F,KAAA2K,OAAAW,GACAtL,KAAA0K,QAAAhF,IAAAgF,EAAAhF,KACA1F,KAAA8K,OAAApF,EAAA1F,KAAA0K,QAAAhF,IACA1F,KAAA4K,SAAA5K,KAAA4K,QAAAlF,WACA1F,KAAA4K,QAAAlF,GAGA,CACA1F,KAAA8I,KAAA9I,KAAA2K,OAAAD,EACA,EAGA,IAAA2B,GAAA9H,OAAA+H,OAAA,CACAC,UAAA,KACAlG,IAAAA,GACAmE,WAAAA,GACAR,SAAAA,GACAZ,IAAAA,GACAG,OAAAA,GACAD,MAAAA,GACArB,SAAAA,GACA9D,QAAAA,EACAqI,kBApTAC,IACA,MAAAC,EAAAD,EAAAE,MAAA,KACAhD,EAAA,GACA,GAAA+C,EAAApH,OAAA,GAAA,EACA,MAAA,IAAAsD,MAAA,2BAEA,IAAA,IAAA9C,EAAA,EAAAA,EAAA4G,EAAApH,OAAAQ,GAAA,EACA6D,EAAAC,KAAA,CACA9C,EAAAV,SAAAsG,EAAA5G,GAAA,IACAkB,EAAAZ,SAAAsG,EAAA5G,EAAA,GAAA,MAGA,OAAA6D,CAAA,EAySAd,KAAAA,GACAzB,UAAAA,GACAV,WAAAA,GACAqC,MAAAA,GACAT,KAAAA,GACAhB,QAAAA,GACAI,OAAAA,GACAkF,eApRA9C,GACA,OAAAA,GAAA,IAAAA,EAAA+C,EACA,EAEA,IAAA7L,KAAA8L,MAAAhD,EAAAL,EAAAK,EAAA+C,GAAA7L,KAAAC,GAiRA8L,iBA5QAjD,GAGA,CAFA9I,KAAAgM,KAAAlD,EAAAN,EAAAM,EAAAN,EAAAM,EAAAmD,EAAAnD,EAAAmD,GACAjM,KAAAgM,KAAAlD,EAAAL,EAAAK,EAAAL,EAAAK,EAAA+C,EAAA/C,EAAA+C,IA2QAK,KAAA9E,GACA5D,IAAAA,EACA2D,QAAAA,GACAJ,QAAAA,GACApC,UAAAA,GACAsD,OAAAA,GACAkE,UA/XAjJ,GACA,qBAAAK,OAAAM,UAAAC,SAAAH,KAAAT,GA+XAD,UAAAA,EACAkB,QAAAA,EACAiI,WAAAhJ,EACAN,WAAAA,EACAiB,SAAAA,EACAT,SAAAA,EACA+I,SAAAzI,EACA0I,OApYA,CAAApJ,EAAAqJ,IACAhJ,OAAAM,UAAAC,SAAAH,KAAAT,KAAA,WAAAqJ,EAAA,IAoYAlJ,YAAAA,EACAmJ,KAAAtD,GACAnE,cAAAA,GACA6B,OAAAA,GACA6F,gBAzVA9D,IACA,MAAA+D,EAAA,GACA,IAAA,IAAA5H,EAAA,EAAAA,EAAA6D,EAAArE,OAAAQ,IAAA,CACA,MAAA6H,EAAAhE,EAAA7D,GACA4H,EAAA9D,KAAA+D,EAAA7G,EAAA,IAAA6G,EAAA3G,EACA,CACA,OAAA0G,EAAAE,KAAA,IAAA,EAoVA1G,KAAAA,GACA3B,aAAAA,IAsDA,MAAAsI,GAAA,CACAC,UAAAC,IACA/M,KAAAgN,IAAAD,EAAA/M,KAAAC,IAAA,EAAA,IASA,MAAAgN,GACA,WAAAxD,GACAzK,KAAAkO,SAAA,GACAlO,KAAAmO,OAAA,EACAnO,KAAAoO,KAAA,EACApO,KAAAqO,SAAA,GACArO,KAAAsO,SAAA,IACAtO,KAAAuO,SAAA,KACAvO,KAAAgL,SAAA,GACAhL,KAAAwO,cAAA,OACAxO,KAAAyO,WAAA,KACAzO,KAAA0O,OAAA,KACA1O,KAAAwO,cAAA,KACAxO,KAAA2O,cAAA,CAEA,CAEA,UAAAC,CAAApF,GACAxJ,KAAAkO,SAAAtE,KAAAJ,EACA,CAEA,UAAAqF,CAAAxD,GACArL,KAAAgL,SAAApB,KAAAyB,EACA,CAEA,aAAAyD,CAAAzD,GACArL,KAAAgL,SAAAhL,KAAAgL,SAAA3C,QAAA0G,GACAA,IAAA1D,GAEA,CAEA,OAAAS,GACA9L,KAAAgL,UACA1D,GAAAtH,KAAAgL,UAAA+D,GACAA,EAAApK,KAAA,OAAA3E,KAAA0O,OAAA1O,KAAA0O,OAAA1O,OAGA,CAEA,MAAAgP,GACA,CAEA,MAAAC,CAAAC,GACAlP,KAAAmP,WAAAnP,KAAAoO,KAAAc,EACA,CAEA,UAAAC,CAAAxD,EAAAuD,GACAlP,KAAAmO,OAAAnN,KAAAoO,IAAA,EAAApO,KAAAqO,IAAA,EAAAH,IACAlP,KAAAoO,KAAApN,KAAAoO,IAAA,EAAApO,KAAAqO,IAAA,EAAA1D,IACA3L,KAAAuO,UAAA,IAAAe,MAAAC,UACAvP,KAAAyO,aACAzO,KAAAyO,WAAAe,OAAAC,YAAAzP,KAAAwO,cAAAxO,KAAAqO,UAEA,CAEA,IAAAqB,GACA1P,KAAAyO,aACAe,OAAAG,cAAA3P,KAAAyO,YACAzO,KAAAyO,WAAA,KAEAzO,KAAA8L,UAGA,CAEA,IAAA8D,CAAAC,GACA,IAAA7P,KAAAkO,SAAA5I,SAGA,OAAAuK,IACA7P,KAAA0O,OAAAmB,GAEA7P,KAAA8P,YACA9P,KAAAmP,WAAA,EAAA,GACA,CAEA,OAAAY,GACA/P,KAAAmP,WAAA,EAAA,EACA,CAEA,SAAAW,GACA,GAAA,IAAA9P,KAAAkO,SAAA5I,OAGA,IAAA,IAAAQ,EAAA,EAAAA,EAAA9F,KAAAkO,SAAA5I,OAAAQ,IACA9F,KAAAkO,SAAApI,GAAAgK,WAEA,CAEA,SAAAE,GACA,MAAAjM,EAAA8J,GAAAC,UAAA9N,KAAAoO,MACA,IAAA,IAAAtI,EAAA,EAAAA,EAAA9F,KAAAkO,SAAA5I,OAAAQ,IACA9F,KAAAkO,SAAApI,GAAAmK,OAAAlM,EAEA,CAEA,YAAA4K,GACA,MAAAuB,GAAA,IAAAZ,MAAAC,UACAY,EAAAD,EAAAlQ,KAAAuO,SACAvO,KAAAuO,SAAA2B,EACA,MAAAE,EAAAD,EAAAnQ,KAAAsO,UAAAtO,KAAAoO,KAAApO,KAAAmO,OAAA,GAAA,GACAnN,KAAAgD,IAAAoM,IAAApP,KAAAgD,IAAAhE,KAAAoO,KAAApO,KAAAmO,QACAnO,KAAAoO,KAAApO,KAAAmO,OAGAnO,KAAAoO,MAAAgC,EAEA,IACApQ,KAAAgQ,WACA,CACA,QACAhQ,KAAAgP,OAAArK,KAAA3E,MACAA,KAAAmO,SAAAnO,KAAAoO,MACApO,KAAA0P,MAEA,CACA,EAQA,SAAAW,GAAA/K,GACAjB,EAAAiB,KACAA,EAAA,IAGA,IAAA+D,EAAA,GACA,MAAAiH,EAAA,iEACA,IAAA,IAAAxK,EAAAR,EAAAQ,EAAA,IAAAA,EACAuD,GAAAiH,EAAAC,OAAAvP,KAAAwP,MAAA,GAAAxP,KAAAkF,WAEA,OAAAmD,CACA,CAQA,MAAAoH,GACA,WAAAhG,GACAzK,KAAA0Q,SAAA,CAAA,EACA1Q,KAAAsF,OAAA,CACA,CAIA,GAAA9D,CAAAiD,EAAAV,GACA,MAAAG,EAAAlE,KAAA2Q,iBAAAlM,GAIA,OAHAR,EAAAF,KACAG,EAAAH,MAAAA,GAEAG,CACA,CAIA,GAAA0M,CAAAnM,GACA,OAAAzE,KAAA6Q,cAAApM,GACAzE,KAAA2Q,iBAAAlM,GAEA,IACA,CAOA,GAAAqM,CAAArM,EAAAV,GACA/D,KAAAwB,IAAAiD,EAAAV,EACA,CAIA,WAAAgN,CAAAtM,GACA,OAAAzE,KAAA6Q,cAAApM,EACA,CAKA,MAAAmD,CAAAnD,GACA,GAAAzE,KAAA6Q,cAAApM,GAAA,CACA,MAAAuM,EAAAhR,KAAAiR,MAAAxM,GAGA,cAFAzE,KAAA0Q,SAAAM,GACAhR,KAAAsF,SACAb,CACA,CACA,CAMA,OAAA6C,CAAAf,GACA,MAAA2K,EAAAlR,KAAAmR,UACA,IAAA,IAAArL,EAAA,EAAAsL,EAAAF,EAAA5L,OAAAQ,EAAAsL,EAAAtL,IAAA,CACA,MAAAuL,EAAAH,EAAApL,GACAwL,EAAAtR,KAAA0Q,SAAAW,GACAhN,EAAAiN,IAGA/K,EAAA+K,EACA,CACA,CAMA,KAAAC,GACA,MAAAC,EAAA,IAAAf,GACAS,EAAAlR,KAAAmR,UACA,IAAA,IAAArL,EAAA,EAAAsL,EAAAF,EAAA5L,OAAAQ,EAAAsL,EAAAtL,IAAA,CACA,MAAAuL,EAAAH,EAAApL,GACAwL,EAAAtR,KAAA0Q,SAAAW,GACAhN,EAAAiN,IAGAE,EAAAhQ,IAAA8P,EAAA7M,IAAA6M,EAAAvN,MACA,CACA,OAAAyN,CACA,CAOA,OAAAL,GACA,MAAAD,EAAA,GACA,IAAA,MAAAG,KAAArR,KAAA0Q,SACAnM,OAAAM,UAAAH,eAAAC,KAAA3E,KAAA0Q,SAAAW,IACAH,EAAAtH,KAAAyH,GAGA,OAAAH,CACA,CACA,aAAAL,CAAApM,GACA,MAAAuM,EAAAhR,KAAAiR,MAAAxM,GACA,OAAAR,EAAAjE,KAAA0Q,SAAAM,GACA,CAMA,gBAAAL,CAAAlM,GACA,MAAAuM,EAAAhR,KAAAiR,MAAAxM,GACA,IAAA6M,EAAAtR,KAAA0Q,SAAAM,GAMA,OALA3M,EAAAiN,KACAA,EAAA,CAAA7M,IAAAA,GACAzE,KAAA0Q,SAAAM,GAAAM,EACAtR,KAAAsF,UAEAgM,CACA,CAIA,KAAAL,CAAAxM,GACA,GAAAM,EAAAN,GACA,OAAAA,EAEA,GAAAG,EAAAH,GACA,OAAAzE,KAAAyR,YAAAhN,GAEA,GAAAH,EAAAG,GACA,OAAAzE,KAAA0R,cAAAjN,GAGA,MADAkN,QAAAC,IAAAnN,GACA,IAAAmE,MAAA,wBACA,CAIA,WAAA6I,CAAAhF,GAEA,IAAApD,EAAA,EACA,GAAA,IAAAoD,EAAAnH,OACA,OAAA+D,EAEA,IAAA,IAAAvD,EAAA,EAAAA,EAAA2G,EAAAnH,OAAAQ,IAAA,CAEAuD,EAAA,GAAAA,EAAAA,EADAoD,EAAAoF,WAAA/L,EAEA,CACA,OAAAuD,CACA,CAIA,aAAAqI,CAAAjN,GACA,IAAAqN,EAAArN,EAAAsN,QAKA,OAJA1N,EAAAyN,KACAA,EAAAzB,KACA5L,EAAAsN,QAAAD,GAEAA,CACA,EAOA,MAAAE,WAAAxH,GAMA,WAAAC,CAAAwH,GAIA,GAHAC,QACAlS,KAAAmS,WAAA,IAAA1B,GACAzQ,KAAAsF,OAAA,EACArB,EAAAgO,GACA,GAAA7M,MAAAC,QAAA4M,GACA,IAAA,IAAAnM,EAAA,EAAAA,EAAAmM,EAAA3M,OAAAQ,IACA9F,KAAAwB,IAAAyQ,EAAAnM,SAIAmM,EAAA3K,SAAA,SAAA8K,EAAA1F,GACA1M,KAAAwB,IAAA4Q,EAAA1F,EACA,GAAA1M,KAGA,CAKA,GAAAwB,CAAAiD,EAAAV,GACA,IAAAsO,EAAArS,KAAAmS,WAAAvB,IAAAnM,GACA4N,IACAA,EAAArS,KAAAmS,WAAA3Q,IAAAiD,GACAzE,KAAAsF,SACAtF,KAAA8L,QAAA,YAEAuG,EAAAtO,MAAAA,CACA,CAOA,GAAA+M,CAAArM,EAAAV,GACA/D,KAAAwB,IAAAiD,EAAAV,EACA,CAIA,GAAA6M,CAAAnM,GACA,MAAA4N,EAAArS,KAAAmS,WAAAvB,IAAAnM,GACA,GAAA4N,EACA,OAAAA,EAAAtO,MAEA,MAAA,IAAA6E,MAAA,mBAAAnE,EACA,CAIA,WAAAsM,CAAAtM,GACA,OAAAzE,KAAAmS,WAAApB,YAAAtM,EACA,CAIA,MAAAmD,CAAAnD,GACA,GAAAzE,KAAA+Q,YAAAtM,GAGA,OAFAzE,KAAA8L,QAAA,WACA9L,KAAAsF,SACAtF,KAAAmS,WAAAvK,OAAAnD,EAEA,CAIA,OAAA6C,CAAAf,EAAAkB,GACAzH,KAAAmS,WAAA7K,SAAA,SAAA+K,GACA9L,EAAA5B,KAAA8C,EAAA4K,EAAA5N,IAAA4N,EAAAtO,MACA,GACA,CAIA,YAAAuO,CAAA/L,EAAAkB,GACAzH,KAAAmS,WAAA7K,SAAA,SAAA+K,GACA9L,EAAA5B,KAAA8C,EAAA4K,EAAAtO,MACA,GACA,CAIA,UAAAwO,CAAAhM,EAAAkB,GACAzH,KAAAmS,WAAA7K,SAAA,SAAA+K,GACA9L,EAAA5B,KAAA8C,EAAA4K,EAAA5N,IACA,GACA,CAIA,IAAA+N,GACA,MAAAA,EAAA,GAIA,OAHAxS,KAAAuS,YAAA,SAAA9N,GACA+N,EAAA5I,KAAAnF,EACA,IACA+N,CACA,EAGA,MAAAC,GAAA,CAQAC,uBAAA,SAAA/E,EAAAnE,EAAAC,GACA,SAAAkJ,EAAAC,EAAAC,GACA,OAAAD,EAAA9L,EAAA+L,EAAA/L,IAAA8L,EAAA9L,EAAA+L,EAAA/L,IAAA8L,EAAA5L,EAAA6L,EAAA7L,IAAA4L,EAAA5L,EAAA6L,EAAA7L,EACA,CACA,GAAAwC,IAAAC,EACA,OAAAkJ,EAAAhF,EAAAnE,GAEA,MAAAsJ,EAAArJ,EAAA3C,EAAA0C,EAAA1C,EAAAiM,EAAAtJ,EAAAzC,EAAAwC,EAAAxC,EACA,IAAAgM,GAAArF,EAAA7G,EAAA0C,EAAA1C,GAAAgM,GAAAnF,EAAA3G,EAAAwC,EAAAxC,GAAA+L,EACA,OAAAC,EAAA,EACAL,EAAAnJ,EAAAmE,IAEAqF,GAAAvJ,EAAA3C,EAAA6G,EAAA7G,GAAAgM,GAAArJ,EAAAzC,EAAA2G,EAAA3G,GAAA+L,EACAC,EAAA,EACAL,EAAAlJ,EAAAkE,IAGAqF,GAAAvJ,EAAA3C,EAAA6G,EAAA7G,GAAAiM,GAAAtJ,EAAAzC,EAAA2G,EAAA3G,GAAA8L,EACAE,EAAAA,GAAAF,EAAAA,EAAAC,EAAAA,IACA,EAQAE,eAAA,SAAAtF,EAAAnE,EAAAC,GACA,OAAAzI,KAAAgM,KAAAhN,KAAA0S,uBAAA/E,EAAAnE,EAAAC,GACA,EAQAyJ,mBAAA,SAAAvF,EAAAhE,GACA,IAAAwJ,EAAAxP,OAAAD,UACA,GAAAW,EAAAsF,IAAA,IAAAA,EAAArE,OACA,OAAA3B,OAAAD,UAEA,IAAA,IAAA+I,EAAA,EAAAA,EAAA9C,EAAArE,OAAA,EAAAmH,IAAA,CACA,MAAA2G,EAAAzJ,EAAA8C,GACA4G,EAAA1J,EAAA8C,EAAA,GACAI,EAAA7M,KAAA0S,uBAAA/E,EAAAyF,EAAAC,GACAxG,EAAAsG,IACAA,EAAAtG,EAEA,CACA,OAAA7L,KAAAgM,KAAAmG,EACA,GAGA,MAAAG,GACA,WAAA7I,CAAA8I,EAAA/J,GACAxJ,KAAAuT,EAAAA,EACAvT,KAAAwT,MAAAhK,CACA,EAIA,MAAAiK,WAAAxT,EAAAyT,EACA,WAAAjJ,CAAA3D,EAAAE,GACAkL,MAAApL,EAAAE,EACA,CACA,KAAAuK,GACA,OAAA,IAAAkC,GAAAzT,KAAA8G,EAAA9G,KAAAgH,EACA,CACA,IAAA2M,CAAAhG,GACA,OAAA,IAAA8F,GAAAzT,KAAA8G,EAAA6G,EAAA7G,EAAA9G,KAAAgH,EAAA2G,EAAA3G,EACA,CACA,KAAA4M,CAAAjG,GACA,OAAA,IAAA8F,GAAAzT,KAAA8G,EAAA6G,EAAA7G,EAAA9G,KAAAgH,EAAA2G,EAAA3G,EACA,CACA,MAAA6M,CAAA9P,GACA,OAAA,IAAA0P,GAAAzT,KAAA8G,EAAA/C,EAAA/D,KAAAgH,EAAAjD,EACA,CACA,KAAA+P,CAAArH,GACA,OAAA,IAAAgH,GAAAzT,KAAA8G,EAAA2F,EAAAzM,KAAAgH,EAAAyF,EACA,CACA,SAAAsH,GACA,OAAA,IAAA/T,KAAAsF,SACA,IAAAmO,GAEAzT,KAAA8T,MAAA,EAAA9T,KAAAsF,SACA,CACA,MAAAA,GACA,OAAAtE,KAAAgM,KAAAhN,KAAA8G,EAAA9G,KAAA8G,EAAA9G,KAAAgH,EAAAhH,KAAAgH,EACA,CACA,QAAAlC,GACA,MAAA,IAAA9E,KAAA8G,EAAA,IAAA9G,KAAAgH,EAAA,GACA,CACA,aAAAgN,GACA,OAAAhU,KAAA8G,EAAA9G,KAAA8G,EAAA9G,KAAAgH,EAAAhH,KAAAgH,CACA,CACA,QAAAiN,CAAAtG,EAAAuG,GACA,OAAA,IAAAT,GAAAS,EAAApN,EAAA6G,EAAA7G,EAAAoN,EAAAlN,EAAA2G,EAAA3G,GAAA8M,MAAA,IAAAH,KAAAhG,EACA,CACA,OAAAwG,CAAAC,GACA,IAAAC,EAAA,EACAD,IACAC,EAAA,IAAArT,KAAAC,IAEA,MAAAuI,EAAAxI,KAAA8L,MAAA9L,KAAAgD,IAAAhE,KAAAgH,GAAAhG,KAAAgD,IAAAhE,KAAA8G,IACAwN,EAAAtT,KAAAC,GAAA,EACAmQ,EAAApR,KAAAsF,SACA,GAAA,IAAAtF,KAAA8G,EAAA,CAEA,GAAA,IAAA9G,KAAAgH,EACA,OAAA,IAAAsM,GAAA,EAAA,GAEA,GAAAtT,KAAAgH,EAAA,EACA,OAAA,IAAAsM,GAAAlC,EAAAiD,EAAAC,GAEA,GAAAtU,KAAAgH,EAAA,EACA,OAAA,IAAAsM,GAAAlC,EAAA,EAAAiD,EAAAC,EAEA,MACA,GAAAtU,KAAA8G,EAAA,EAAA,CACA,GAAA,IAAA9G,KAAAgH,EACA,OAAA,IAAAsM,GAAAlC,EAAA,GAEA,GAAApR,KAAAgH,EAAA,EACA,OAAA,IAAAsM,GAAAlC,EAAAiD,EAAA7K,GAEA,GAAAxJ,KAAAgH,EAAA,EACA,OAAA,IAAAsM,GAAAlC,EAAAiD,GAAA,EAAAC,EAAA9K,GAEA,KACA,CACA,GAAA,IAAAxJ,KAAAgH,EACA,OAAA,IAAAsM,GAAAlC,EAAA,EAAAkD,GAEA,GAAAtU,KAAAgH,EAAA,EACA,OAAA,IAAAsM,GAAAlC,EAAAiD,GAAA,EAAAC,EAAA9K,IAEA,GAAAxJ,KAAAgH,EAAA,EACA,OAAA,IAAAsM,GAAAlC,EAAAiD,GAAA,EAAAC,EAAA9K,GAEA,CACA,CACA,QAAA+K,CAAA5I,EAAAuD,GACA,GAAAvD,EAAA7E,EAAAoI,EAAApI,EAAA,CACA,MAAA0N,EAAAtF,EACAA,EAAAvD,EACAA,EAAA6I,CACA,CACA,MAAAC,EAAA,IAAAC,GAAA/I,EAAA7E,EAAA6E,EAAA3E,GAAA2N,QAvFA,KAuFAC,EAAA,IAAAF,GAAAxF,EAAApI,EAAAoI,EAAAlI,GAAA2N,QAvFA,KAwFA,IAAAE,EAAAC,EACA,QAAAL,EAAAM,MAAAH,GAAA3M,SAAAjI,QACA2L,EAAA7E,IAAAoI,EAAApI,GAAA6E,EAAA3E,IAAAkI,EAAAlI,IAGA2E,EAAA3E,EAAAkI,EAAAlI,GACA6N,EAAAJ,EAAA3N,GAAA8N,EAAA9N,EAAA2N,EAAA3N,IAAA9G,KAAAgH,GAAAyN,EAAAzN,EAAAyN,EAAAO,UAAAJ,EAAA5N,EAAA4N,EAAAI,QAAAP,EAAAzN,EAAAyN,EAAAO,SACAF,EAAAL,EAAA3N,EAAA2N,EAAAQ,OAAAL,EAAA9N,EAAA8N,EAAAK,OAAAR,EAAA3N,EAAA2N,EAAAQ,SAAAjV,KAAAgH,EAAAyN,EAAAzN,IAAA4N,EAAA5N,EAAAyN,EAAAzN,KAGA6N,EAAAJ,EAAA3N,GAAA8N,EAAA9N,EAAA2N,EAAA3N,IAAA9G,KAAAgH,EAAAyN,EAAAzN,IAAA4N,EAAA5N,EAAAyN,EAAAzN,GACA8N,EAAAL,EAAA3N,EAAA2N,EAAAQ,OAAAL,EAAA9N,EAAA8N,EAAAK,OAAAR,EAAA3N,EAAA2N,EAAAQ,SAAAjV,KAAAgH,GAAAyN,EAAAzN,EAAAyN,EAAAO,UAAAJ,EAAA5N,EAAA4N,EAAAI,QAAAP,EAAAzN,EAAAyN,EAAAO,UAEAhV,KAAA8G,EAAA+N,GAAA7U,KAAA8G,EAAAgO,GAGA,CACA,KAAAI,CAAAC,GACA,MAAAC,EAAAD,EAAAhJ,MAAA,EAAAgJ,EAAA7P,OAAA,GAAAqH,MAAA,KAAA7F,EAAAV,SAAAgP,EAAA,GAAA,IAAApO,EAAAZ,SAAAgP,EAAA,GAAA,IACA,IAAApQ,MAAA8B,KAAA9B,MAAAgC,GACA,OAAA,IAAAyM,GAAA3M,EAAAE,EAEA,EAEA,MAAA0N,GACA,WAAAjK,CAAA3D,EAAAE,EAAAiO,EAAAD,GACAhV,KAAA8G,EAAAA,GAAA,EACA9G,KAAAgH,EAAAA,GAAA,EACAhH,KAAAiV,MAAAA,GAAA,EACAjV,KAAAgV,OAAAA,GAAA,CACA,CACA,QAAA/M,CAAAoN,GACA,OAAAA,EAAAvO,GAAA9G,KAAA8G,GAAAuO,EAAAvO,GAAA9G,KAAA8G,EAAA9G,KAAAiV,OAAAI,EAAArO,GAAAhH,KAAAgH,GAAAqO,EAAArO,GAAAhH,KAAAgH,EAAAhH,KAAAgV,MACA,CACA,OAAAL,CAAAW,EAAAC,GAQA,YAPA5M,IAAA4M,IACAA,EAAAD,GAEAtV,KAAA8G,GAAAwO,EACAtV,KAAAgH,GAAAuO,EACAvV,KAAAiV,OAAA,EAAAK,EAAA,EACAtV,KAAAgV,QAAA,EAAAO,EAAA,EACAvV,IACA,CACA,MAAA6T,CAAAyB,EAAAC,GACA,IAAAzO,EAAAwO,EAAAtO,EAAAuO,EAOA,OANAD,aAAA7B,KACA3M,EAAAwO,EAAAxO,EACAE,EAAAsO,EAAAtO,GAEAhH,KAAA8G,GAAAA,EACA9G,KAAAgH,GAAAA,EACAhH,IACA,CACA,KAAA+U,CAAAxB,GACA,MAAAiC,EAAAxU,KAAAqO,IAAArP,KAAA8G,EAAAyM,EAAAzM,GACA2O,EAAAzU,KAAAqO,IAAArP,KAAAgH,EAAAuM,EAAAvM,GACA0O,EAAA1U,KAAAoO,IAAApP,KAAA8G,EAAA9G,KAAAiV,MAAA1B,EAAAzM,EAAAyM,EAAA0B,OACAU,EAAA3U,KAAAoO,IAAApP,KAAAgH,EAAAhH,KAAAgV,OAAAzB,EAAAvM,EAAAuM,EAAAyB,QACA,OAAA,IAAAN,GAAAc,EAAAC,EAAAC,EAAAF,EAAAG,EAAAF,EACA,CACA,MAAApO,GACA,OAAA,IAAAoM,GAAAzT,KAAA8G,EAAA9G,KAAAiV,MAAA,EAAAjV,KAAAgH,EAAAhH,KAAAgV,OAAA,EACA,CACA,GAAAY,GACA,OAAA,IAAAnC,GAAAzT,KAAA8G,EAAA9G,KAAAiV,MAAA,EAAAjV,KAAAgH,EACA,CACA,KAAA6O,GACA,OAAA,IAAApC,GAAAzT,KAAA8G,EAAA9G,KAAAiV,MAAAjV,KAAAgH,EAAAhH,KAAAgV,OAAA,EACA,CACA,MAAAc,GACA,OAAA,IAAArC,GAAAzT,KAAA8G,EAAA9G,KAAAiV,MAAA,EAAAjV,KAAAgH,EAAAhH,KAAAgV,OACA,CACA,IAAAe,GACA,OAAA,IAAAtC,GAAAzT,KAAA8G,EAAA9G,KAAAgH,EAAAhH,KAAAgV,OAAA,EACA,CACA,OAAAgB,GACA,OAAA,IAAAvC,GAAAzT,KAAA8G,EAAA9G,KAAAgH,EACA,CACA,QAAAiP,GACA,OAAA,IAAAxC,GAAAzT,KAAA8G,EAAA9G,KAAAiV,MAAAjV,KAAAgH,EACA,CACA,UAAAkP,GACA,OAAA,IAAAzC,GAAAzT,KAAA8G,EAAA9G,KAAAgH,EAAAhH,KAAAgV,OACA,CACA,WAAAmB,GACA,OAAA,IAAA1C,GAAAzT,KAAA8G,EAAA9G,KAAAiV,MAAAjV,KAAAgH,EAAAhH,KAAAgV,OACA,CACA,KAAAzD,GACA,OAAA,IAAAmD,GAAA1U,KAAA8G,EAAA9G,KAAAgH,EAAAhH,KAAAiV,MAAAjV,KAAAgV,OACA,CACA,OAAA7P,GACA,OAAAnF,KAAAiV,QAAAjV,KAAAgV,MACA,CACA,MAAAoB,CAAAC,GACA,OAAArW,KAAA8G,IAAAuP,EAAAvP,GAAA9G,KAAAgH,IAAAqP,EAAArP,GAAAhH,KAAAiV,QAAAoB,EAAApB,OAAAjV,KAAAgV,SAAAqB,EAAArB,MACA,CACA,aAAAsB,CAAA9C,GACA,MAAA6C,EAAArW,KAAAuR,QAAA5H,EAAA3J,KAAAuW,cAAA/C,GAAAgD,EAAA7M,EAAA,GAAA8M,EAAA9M,EAAA,GAAA+M,EAAA/M,EAAA,GAAAgN,EAAAhN,EAAA,GAKA,OAJA0M,EAAAvP,EAAA9F,KAAAqO,IAAAqH,EAAA5P,EAAA0P,EAAA1P,EAAA2P,EAAA3P,EAAA6P,EAAA7P,GACAuP,EAAArP,EAAAhG,KAAAqO,IAAAqH,EAAA1P,EAAAwP,EAAAxP,EAAAyP,EAAAzP,EAAA2P,EAAA3P,GACAqP,EAAApB,MAAAjU,KAAAoO,IAAAsH,EAAA5P,EAAA0P,EAAA1P,EAAA2P,EAAA3P,EAAA6P,EAAA7P,GAAAuP,EAAAvP,EACAuP,EAAArB,OAAAhU,KAAAoO,IAAAsH,EAAA1P,EAAAwP,EAAAxP,EAAAyP,EAAAzP,EAAA2P,EAAA3P,GAAAqP,EAAArP,EACAqP,CACA,CACA,aAAAE,CAAA/C,GACA,MAAAvG,EAAAjN,KAAAqH,SAAAqP,EAAA1W,KAAAmW,cAAAS,OAAApD,EAAAvG,GACA,MAAA,CADAjN,KAAAgW,UAAAY,OAAApD,EAAAvG,GAAAjN,KAAAiW,WAAAW,OAAApD,EAAAvG,GACAyJ,EADA1W,KAAAkW,aAAAU,OAAApD,EAAAvG,GAEA,CACA,QAAAnI,CAAA+R,GAEA,OADAA,EAAAA,GAAA,IACA7W,KAAA8G,EAAA+P,EAAA7W,KAAAgH,EAAA6P,EAAA7W,KAAAiV,MAAA4B,EAAA7W,KAAAgV,MACA,CACA,KAAA8B,CAAAC,EAAAC,EAAAC,EAAAC,EAAA1D,GACA,IAAAgD,EAAAxW,KAAAgW,UACA,MAAAmB,EAAAnX,KAAAqH,SACAmP,EAAAI,OAAApD,EAAA2D,GAAAP,OAAApD,EAAA0D,GACA,MAAAE,EAAAH,EAAArD,MAAA4C,GACAa,EAAA,IAAA5D,GAAA2D,EAAAtQ,EAAAiQ,EAAAK,EAAApQ,EAAAgQ,GACA7N,EAAAiO,EAAAxD,MAAAyD,GACAb,EAAAA,EAAA7C,KAAAxK,GACAqN,EAAAI,OAAApD,EAAA0D,GAAAN,OAAApD,EAAA2D,GACAnX,KAAA8G,EAAA0P,EAAA1P,EACA9G,KAAAgH,EAAAwP,EAAAxP,EACAhH,KAAAiV,OAAA8B,EACA/W,KAAAgV,QAAAgC,CACA,CACA,IAAAM,CAAAA,GAKA,OAJAtX,KAAA8G,GAAAwQ,EACAtX,KAAAgH,GAAAsQ,EACAtX,KAAAiV,OAAAqC,EACAtX,KAAAgV,QAAAsC,EACAtX,IACA,CACA,QAAAuX,CAAAlB,GACA,MAAAF,EAAAnW,KAAAmW,cACAqB,EAAAnB,EAAAF,cAGA,QAFAA,EAAArP,EAAAuP,EAAAvP,GAAAqP,EAAAnP,EAAAqP,EAAArP,GACAwQ,EAAA1Q,EAAA9G,KAAA8G,GAAA0Q,EAAAxQ,EAAAhH,KAAAgH,EAEA,CACA,aAAAyQ,CAAApB,GAIA,OAHAA,aAAA3B,KACA2B,EAAA,IAAA3B,GAAA2B,EAAAvP,EAAAuP,EAAArP,EAAAqP,EAAApB,MAAAoB,EAAArB,SAEAqB,CACA,CACA,YAAAqB,GACA,OAAA,IAAAhD,GAAA,EAAA,EAAA,EAAA,EACA,CACA,iBAAAiD,CAAAhK,EAAAuG,GACA,GAAAlP,MAAA2I,EAAA7G,IAAA9B,MAAA2I,EAAA3G,IAAAhC,MAAAkP,EAAApN,IAAA9B,MAAAkP,EAAAlN,GACA,MAAA,IAAA4B,MAAA,wBAEA,OAAA,IAAA8L,GAAA1T,KAAAqO,IAAA1B,EAAA7G,EAAAoN,EAAApN,GAAA9F,KAAAqO,IAAA1B,EAAA3G,EAAAkN,EAAAlN,GAAAhG,KAAAgD,IAAA2J,EAAA7G,EAAAoN,EAAApN,GAAA9F,KAAAgD,IAAA2J,EAAA3G,EAAAkN,EAAAlN,GACA,EAKA,MAAA4Q,GACA,WAAAnN,CAAAoN,GACA7X,KAAA6X,UAAAnD,GAAA+C,OAAAI,EACA,CACA,KAAAC,CAAAC,EAAAC,GACA,MAAAC,EAAAD,EAAAE,cAAAvL,MAAA,KACA,IAAA,IAAA7G,EAAA,EAAAA,EAAAmS,EAAA3S,OAAAQ,IACAiS,EAAA/X,KAAAmY,aAAAJ,EAAAE,EAAAnS,IAEA,OAAAiS,CACA,CACA,YAAAI,CAAAJ,EAAAC,GACA,OAAA5T,EAAApE,KAAAgY,IACAhY,KAAAgY,GAAAD,GAGAA,CAEA,CACA,IAAAhC,CAAAgC,GACA,OAAA/X,KAAAoY,OAAAL,EAAA/X,KAAAqY,MACA,CACA,MAAAhR,CAAA0Q,GACA,OAAA/X,KAAAoY,OAAAL,EAAA/X,KAAAsY,QACA,CACA,KAAAzC,CAAAkC,GACA,OAAA/X,KAAAoY,OAAAL,EAAA/X,KAAAuY,OACA,CACA,OAAAC,CAAAT,GACA,OAAA/X,KAAAoY,OAAAL,EAAA/X,KAAAyY,SACA,CACA,GAAA7C,CAAAmC,GACA,OAAA/X,KAAAoY,OAAAL,EAAA/X,KAAA0Y,KACA,CACA,MAAAC,CAAAZ,GACA,OAAA/X,KAAAoY,OAAAL,EAAA/X,KAAA4Y,QACA,CACA,MAAA9C,CAAAiC,GACA,OAAA/X,KAAAoY,OAAAL,EAAA/X,KAAA6Y,QACA,CACA,KAAAR,CAAAR,EAAAE,GACAA,EAAAjR,EAAA+Q,EAAA/Q,CACA,CACA,OAAAwR,CAAAT,EAAAE,GACAA,EAAAjR,GAAA+Q,EAAA5C,MAAA8C,EAAA9C,OAAA,GAAA,CACA,CACA,MAAAsD,CAAAV,EAAAE,GACAA,EAAAjR,EAAA+Q,EAAA5C,MAAA8C,EAAA9C,KACA,CACA,IAAAyD,CAAAb,EAAAE,GACAA,EAAA/Q,EAAA6Q,EAAA7Q,CACA,CACA,OAAA4R,CAAAf,EAAAE,GACAA,EAAA/Q,GAAA6Q,EAAA7C,OAAA+C,EAAA/C,QAAA,GAAA,CACA,CACA,OAAA6D,CAAAhB,EAAAE,GACAA,EAAA/Q,EAAA6Q,EAAA7C,OAAA+C,EAAA/C,MACA,CACA,QAAAyD,CAAAZ,EAAAE,GACAA,EAAAjR,EAAA,EACAiR,EAAA/Q,EAAA,EACA+Q,EAAA/C,OAAA6C,EAAA7C,OACA+C,EAAA9C,MAAA4C,EAAA5C,KACA,CACA,MAAAmD,CAAAL,EAAAe,GAGA,OAFAf,EAAArD,GAAA+C,OAAAM,GACAe,EAAA9Y,KAAA6X,UAAAE,GACAA,CACA,EAGA,MAAAgB,GACA,WAAAtO,GACAzK,KAAAgZ,MAAA,KACAhZ,KAAAiZ,MAAA,KACAjZ,KAAAsF,OAAA,CACA,CAIA,OAAA4T,CAAAnV,GACA,MAAAsO,EAAA,CAAAtO,MAAAA,EAAAoV,KAAA,MACAnZ,KAAAiZ,OAKAjZ,KAAAgZ,MAAAG,KAAA9G,EACArS,KAAAgZ,MAAAhZ,KAAAgZ,MAAAG,OALAnZ,KAAAiZ,MAAA5G,EACArS,KAAAgZ,MAAAhZ,KAAAiZ,OAMAjZ,KAAAsF,QACA,CAIA,OAAA8T,GACA,GAAApZ,KAAAsF,OAAA,EACA,MAAA,IAAAsD,MAAA,uBAEA,MAAA7E,EAAA/D,KAAAiZ,MAAAlV,MAGA,OAFA/D,KAAAiZ,MAAAjZ,KAAAiZ,MAAAE,KACAnZ,KAAAsF,SACAvB,CACA,CACA,QAAAkE,CAAAxB,GACA,IAAA4S,EAAArZ,KAAAiZ,MACA,KAAAI,GAAA,CACA,GAAAA,EAAAtV,QAAA0C,EACA,OAAA,EAEA4S,EAAAA,EAAAF,IACA,CACA,OAAA,CACA,EAGA,MAAAG,GAAA,SAGA,SAAAC,GAAA/T,EAAAC,GACA,IAAA,MAAA+T,KAAA/T,EAAA,CACA,GAAA,cAAA+T,GAAA,gBAAAA,EACA,SAEA,MAAAC,EAAAhU,EAAA+T,GACAE,SAAAD,EACA,IAAAE,EAOA,GALAA,EADAD,IAAAJ,IAAA,OAAAG,EACAA,EAAAhP,YAGA,KAEAkP,GAAAA,IAAAvU,MACA,GAAAqU,aAAAnK,KACA9J,EAAAgU,GAAA,IAAAlK,KAAAmK,EAAAlK,gBAEA,GAnBA,mBAmBAkK,EAAAlI,MACA/L,EAAAgU,GAAAC,EAAAlI,YAEA,CACA,MAAAqI,EAAApU,EAAAgU,GAEAhU,EAAAgU,UADA,IAAAF,IACAM,GAGA,CAAA,EAEAL,GAAA/T,EAAAgU,GAAAC,EACA,KAhCA,cAkCAC,IACAlU,EAAAgU,GAAAC,EAEA,CACA,OAAAjU,CACA,CACA,SAAAqU,GAAArU,KAAAsU,GACA,MAAAxU,EAAAwU,EAAAxU,OACA,IAAA,IAAAQ,EAAA,EAAAA,EAAAR,EAAAQ,IACAyT,GAAA/T,EAAAsU,EAAAhU,IAEA,OAAAN,CACA,CAEA,MAAAuU,GAAA,CACAxM,KAAA,OACAyM,QAAA,OACAC,MAAA,KACAC,SAAA,EAKAC,aAAA,EAIAC,SAAA,GAIAC,aAAA,GAIAC,WAAA,IAKAC,qBAAA,GAIAC,mBAAA,GAKAC,4BAAA,GAIAC,2BAAA,GAIAC,6BAAA,GAKAC,KAAA,CAIA3F,MAAA,KAIA4F,QAAA,GAIAC,QAAA,GAIAC,kBAAA,GAIAC,kBAAA,IAMAC,gBAAA,GAIAC,kBAAA,EAIAC,iBAAA,EAIAC,eAAA,IAIAC,iBAAA,IAIAC,2BAAA,IAIAC,iCAAA,EAGAC,kBAAA,EACAC,yBAAA,EACAC,iBAAA,EACAC,oBAAA,GAOA,MAAAC,GACA,WAAAnR,GACAzK,KAAA6b,eAAA,IAAA9B,GAAAa,KAAA,IAAAb,GAAAa,MACA,CAOA,oBAAAkB,CAAAC,GACA,IAAAA,EACA,MAAA,IAAAnT,MAAA,2BAGAtB,GAAAyU,GAAA,SAAA9O,GACAA,EAAA+O,YACA,IAEAD,EAAAlS,MAAA,SAAAL,EAAAC,GACA,OAAAA,EAAAwS,OAAAhH,MAAAzL,EAAAyS,OAAAhH,KACA,IACA,MAAAiH,EAAAlc,KAAA0K,QAAAkQ,KAAA3F,MAAA4F,EAAA7a,KAAA0K,QAAAkQ,KAAAG,kBAAAD,EAAA9a,KAAA0K,QAAAkQ,KAAAI,kBAAAmB,EAAAnc,KAAA0K,QAAAkQ,KAAAC,QAAAuB,EAAA,GAAAC,EAAA,GACA,IAAArH,EAAA,EAAAlO,EAAAqV,EAAAnV,EADAhH,KAAA0K,QAAAkQ,KAAAE,QAEA,KAAAiB,EAAAzW,OAAA,GAAA,CACAwB,GAAAoV,IAEApV,EAAAqV,EACAnV,GAAAgO,EAAA8F,EAEA9F,EAAA,GAEA,MAAAsH,EAAAP,EAAAQ,MACAvc,KAAAwc,aAAAF,EAAA,IAAA7I,GAAA3M,EAAAE,IACA,IAAA,IAAAlB,EAAA,EAAAA,EAAAwW,EAAAG,MAAAnX,OAAAQ,IACAuW,EAAAzS,KAAA0S,EAAAG,MAAA3W,IAEA,IAAA,IAAAA,EAAA,EAAAA,EAAAwW,EAAAI,MAAApX,OAAAQ,IACAsW,EAAAxS,KAAA0S,EAAAI,MAAA5W,IAEA,MAAA6W,EAAAL,EAAAL,OACA,IAAAW,EAAAD,EAAA3H,QACA4H,GAAA,GAAA5X,MAAA4X,MACAA,EAAA,GAEA,IAAAC,EAAAF,EAAA1H,OACA4H,GAAA,GAAA7X,MAAA6X,MACAA,EAAA,GAEAD,GAAA5H,IACAA,EAAA4H,GAEA9V,GAAA+V,EAAAhC,CACA,CACA,MAAA,CACA4B,MAAAJ,EACAK,MAAAN,EAEA,CACA,YAAAI,CAAAF,EAAA3O,GACA,IAAA7H,EAAAgX,EACA,MAAAb,EAAAK,EAAAL,OAAAc,EAAApP,EAAA7G,EAAAmV,EAAAnV,EAAAkW,EAAArP,EAAA3G,EAAAiV,EAAAjV,EACA,IAAAlB,EAAA,EAAAA,EAAAwW,EAAAG,MAAAnX,OAAAQ,IAAA,CACA,MAAAmX,EAAAX,EAAAG,MAAA3W,GACA,IAAAoX,EAAAD,EAAAhB,SACA,IAAAiB,EAAAjI,OAAA,IAAAiI,EAAAlI,QAAA,IAAAkI,EAAApW,GAAA,IAAAoW,EAAAlW,IACAkW,EAAA,IAAAxI,GAAA,EAAA,EAAA,EAAA,IAEAwI,EAAApW,GAAAiW,EACAG,EAAAlW,GAAAgW,EACAC,EAAAhB,OAAAiB,EACA,CACA,IAAApX,EAAA,EAAAA,EAAAwW,EAAAI,MAAApX,OAAAQ,IAAA,CACA,MAAAqX,EAAAb,EAAAI,MAAA5W,GACA,GAAAqX,EAAAxT,OAAA,CACA,MAAAyT,EAAA,GACAzT,EAAAwT,EAAAxT,OACA,IAAAmT,EAAA,EAAAA,EAAAnT,EAAArE,OAAAwX,IAAA,CACA,MAAAO,EAAA1T,EAAAmT,GACAO,EAAAvW,GAAAiW,EACAM,EAAArW,GAAAgW,EACAI,EAAAxT,KAAAyT,EACA,CACAF,EAAAxT,OAAAyT,CACA,CACA,CAEA,OADApd,KAAAsd,yBAAArB,EAAAhH,MAAAjV,KAAA0K,QAAAkQ,KAAAC,QACA,IAAApH,GAAAsJ,EAAAC,EACA,CACA,eAAAO,CAAA7S,GAEA1K,KAAA0K,QAAAmP,GAAA,CAAA,EAAA7Z,KAAA6b,gBACAxX,EAAAqG,KAGA1K,KAAA0K,QAAAmP,GAAA7Z,KAAA0K,QAAAA,GAAA,CAAA,GACA,EAQA,MAAA8S,GACA,WAAA/S,CAAAgT,EAAAC,GACA,GAAArZ,EAAAoZ,GACA,MAAA,IAAA7U,MAAA,oBAEA5I,KAAAyd,QAAAA,EACAzd,KAAA2d,QAAA,IAAA3L,GACAhS,KAAA4d,QAAA,IAAA5L,GACAhS,KAAA6d,QAAAH,GAAAD,EACA,CAUA,OAAAI,CAAAC,GACA,IAAAb,EAAAR,EAAAsB,EAAAjY,EAAAkY,EAAAb,EAAAT,EACA,GAAAoB,GAAA,UAAAA,EAAAvQ,KAAA,CACA,IAAAzH,EAAA,EAAAA,EAAAgY,EAAArB,MAAAnX,OAAAQ,IACAmX,EAAAa,EAAArB,MAAA3W,GACAiY,EAAAd,EAAAgB,gBAEAje,KAAA2d,QAAA7M,IAAAiN,EAAAG,OAAApM,GAAA,IAAA4C,GAAAuI,EAAAnW,EAAAmW,EAAAjW,EAAAiW,EAAAhI,MAAAgI,EAAAjI,SAEA,IAAAlP,EAAA,EAAAA,EAAAgY,EAAApB,MAAApX,OAAAQ,IACAqX,EAAAW,EAAApB,MAAA5W,GACAkY,EAAAb,EAAAgB,qBACAne,KAAA4d,QAAA9M,IAAAkN,EAAAE,OAAApM,GAAAqL,EAAAxT,SAEA,MACA,GAAAmU,aAAA1Y,MAEA,IADAqX,EAAAqB,EACAhY,EAAA,EAAAA,EAAA2W,EAAAnX,OAAAQ,IACAmX,EAAAR,EAAA3W,GACAiY,EAAAd,EAAAgB,gBACAF,GACA/d,KAAA2d,QAAA7M,IAAAiN,EAAAG,OAAApM,GAAA,IAAA4C,GAAAuI,EAAAnW,EAAAmW,EAAAjW,EAAAiW,EAAAhI,MAAAgI,EAAAjI,cAIA,GAAAzQ,OAAAM,UAAAH,eAAAC,KAAAmZ,EAAA,UAAAvZ,OAAAM,UAAAH,eAAAC,KAAAmZ,EAAA,SAAA,CAGA,IAFArB,EAAAqB,EAAArB,MACAC,EAAAoB,EAAApB,MACA5W,EAAA,EAAAA,EAAA2W,EAAAnX,OAAAQ,IACAmX,EAAAR,EAAA3W,GACAiY,EAAAd,EAAAgB,gBACAF,GACA/d,KAAA2d,QAAA7M,IAAAiN,EAAAG,OAAApM,GAAA,IAAA4C,GAAAuI,EAAAnW,EAAAmW,EAAAjW,EAAAiW,EAAAhI,MAAAgI,EAAAjI,SAGA,IAAAlP,EAAA,EAAAA,EAAA4W,EAAApX,OAAAQ,IACAqX,EAAAT,EAAA5W,GACAkY,EAAAb,EAAAgB,qBACAH,GACAhe,KAAA4d,QAAA9M,IAAAkN,EAAAE,OAAApM,GAAAqL,EAAAxT,OAGA,KACA,CACA,MAAAyU,EAAApe,KAAAyd,QAAAW,OACAC,EAAAre,KAAAyd,QAAAY,YACA,IAAAvY,EAAA,EAAAA,EAAAsY,EAAA9Y,OAAAQ,IACAiY,EAAAK,EAAAtY,GACA9F,KAAA2d,QAAA7M,IAAAiN,EAAAG,OAAApM,GAAAiM,EAAA9B,UAEA,IAAAnW,EAAA,EAAAA,EAAAuY,EAAA/Y,OAAAQ,IACAkY,EAAAK,EAAAvY,GACA9F,KAAA4d,QAAA9M,IAAAkN,EAAAE,OAAApM,GAAAkM,EAAArU,SAEA,CACA,EAMA,IAAA2U,GAAA,MAAAC,EACA,WAAA9T,CAAAqH,EAAAiM,GAuCA,GAlCA/d,KAAA0c,MAAA,GAKA1c,KAAAwe,SAAA,GAKAxe,KAAAye,SAAA,GAIAze,KAAA0e,OAAA,EAMA1e,KAAA2e,KAAA,KACA3e,KAAAuN,KAAA,OAMAvN,KAAA4e,WAAA,EACA3a,EAAA6N,GACA9R,KAAA8R,GAAAA,EAGA9R,KAAA8R,GAAAzB,KAEApM,EAAA8Z,GAAA,CACA/d,KAAAie,gBAAAF,EAEA,MAAAtU,EAAAsU,EAAA9B,SACAjc,KAAAiV,MAAAxL,EAAAwL,MACAjV,KAAAgV,OAAAvL,EAAAuL,OACAhV,KAAA8G,EAAA2C,EAAA3C,EACA9G,KAAAgH,EAAAyC,EAAAzC,CACA,MAEAhH,KAAAie,gBAAA,KAEAje,KAAA6e,UAAA,SAAA7e,KAAA8R,GAAA,GACA,CAIA,UAAAgN,GACA,OAAA3Z,EAAAnF,KAAA0c,MACA,CAKA,MAAAT,CAAA1I,GACA,IAAAtP,EAAAsP,GACA,OAAA,IAAAmB,GAAA1U,KAAA8G,EAAA9G,KAAAgH,EAAAhH,KAAAiV,MAAAjV,KAAAgV,QAEAhV,KAAA8G,EAAAyM,EAAAzM,EACA9G,KAAAgH,EAAAuM,EAAAvM,EACAhH,KAAAiV,MAAA1B,EAAA0B,MACAjV,KAAAgV,OAAAzB,EAAAyB,MACA,CAKA,UAAA+J,CAAA9B,GACA,OAAAvV,GAAA1H,KAAA0c,OAAAS,GACAA,EAAA6B,cAAAhf,QAAAid,GAEA,CAMA,WAAAgC,GACA,GAAA,IAAAjf,KAAAwe,SAAAlZ,OACA,MAAA,GAEA,MAAA4Z,EAAA,GACA,IAAA,IAAApZ,EAAA,EAAAsL,EAAApR,KAAAwe,SAAAlZ,OAAAQ,EAAAsL,EAAAtL,IAAA,CACA,MAAAqX,EAAAnd,KAAAwe,SAAA1Y,GACAoZ,EAAAtV,KAAAuT,EAAA6B,cAAAhf,MACA,CACA,OAAAkf,CACA,CAMA,UAAAC,GACA,GAAA,IAAAnf,KAAAye,SAAAnZ,OACA,MAAA,GAEA,MAAA8Z,EAAA,GACA,IAAA,IAAAtZ,EAAA,EAAAsL,EAAApR,KAAAye,SAAAnZ,OAAAQ,EAAAsL,EAAAtL,IAAA,CACA,MAAAqX,EAAAnd,KAAAye,SAAA3Y,GACAsZ,EAAAxV,KAAAuT,EAAA6B,cAAAhf,MACA,CACA,OAAAof,CACA,CAMA,KAAA7N,GACA,MAAA8N,EAAA,IAAAd,EAeA,OAdAta,EAAAjE,KAAA0e,UACAW,EAAAX,OAAA1e,KAAA0e,QAEAza,EAAAjE,KAAAsf,WACAD,EAAAC,QAAAtf,KAAAsf,SAEArb,EAAAjE,KAAAuf,SACAF,EAAAE,MAAAvf,KAAAuf,OAEAF,EAAApB,gBAAAje,KAAAie,gBACAoB,EAAAvY,EAAA9G,KAAA8G,EACAuY,EAAArY,EAAAhH,KAAAgH,EACAqY,EAAApK,MAAAjV,KAAAiV,MACAoK,EAAArK,OAAAhV,KAAAgV,OACAqK,CACA,CAIA,UAAAG,CAAAvC,GACA,OAAA,OAAAjd,KAAA+e,WAAA9B,EACA,CAMA,UAAAwC,CAAAtC,GACAA,EAAA1X,SAAAzF,OACA4H,GAAA5H,KAAA0c,MAAAS,GACAvV,GAAA5H,KAAAwe,SAAArB,GACAA,EAAA1X,OAAA,MAEA0X,EAAAhP,SAAAnO,OACA4H,GAAA5H,KAAA0c,MAAAS,GACAvV,GAAA5H,KAAAye,SAAAtB,GACAA,EAAAhP,OAAA,KAEA,CAIA,SAAAuR,CAAAzC,GACA,OAAAvV,GAAA1H,KAAAwe,UAAA,SAAArB,GACA,OAAAA,EAAAhP,SAAA8O,CACA,GACA,CAIA,MAAA0C,GACA,OAAA3f,KAAA0c,MAAApX,MACA,CAIA,YAAAsa,CAAAzC,GACA,OAAAlV,GAAAjI,KAAA0c,MAAAS,EACA,CAIA,YAAA0C,CAAA5C,GACA,OAAA7T,GAAApJ,KAAA0c,OAAA,SAAAS,GACA,OAAAA,EAAA6B,cAAAhf,QAAAid,CACA,GAAAjd,KACA,CAIA,YAAA8f,GACA,MAAAC,EAAA,GAOA,OANAzY,GAAAtH,KAAAye,UAAA,SAAAzS,GACA+T,EAAAnW,KAAAoC,EAAAgT,cAAAhf,MACA,GAAAA,MACAsH,GAAAtH,KAAAwe,UAAA,SAAAxS,GACA+T,EAAAnW,KAAAoC,EAAAgT,cAAAhf,MACA,GAAAA,MACA+f,CACA,GAKA,MAAAC,GACA,WAAAvV,CAAAhF,EAAA0I,EAAA2D,EAAAmO,GACA,GAAA5b,EAAAoB,GACA,MAAA,IAAAmD,MAAA,0CAEA,GAAAvE,EAAA8J,GACA,MAAA,IAAAvF,MAAA,0CAEA,IAAAsX,EAAAC,EAEAD,EADAtb,EAAAa,GACA,IAAA6Y,GAAA7Y,GAGAA,EAGA0a,EADAvb,EAAAuJ,GACA,IAAAmQ,GAAAnQ,GAGAA,EAEAnO,KAAAyF,OAAAya,EACAlgB,KAAAmO,OAAAgS,EACAngB,KAAAyF,OAAAiX,MAAA9S,KAAA5J,MACAA,KAAAmO,OAAAuO,MAAA9S,KAAA5J,MACAA,KAAAyF,OAAA+Y,SAAA5U,KAAA5J,MACAA,KAAAmO,OAAAsQ,SAAA7U,KAAA5J,MACAiE,EAAA6N,GACA9R,KAAA8R,GAAAA,EAGA9R,KAAA8R,GAAAzB,KAEApM,EAAAgc,GACAjgB,KAAAme,qBAAA8B,EAGAjgB,KAAAme,qBAAA,KAEAne,KAAAuN,KAAA,OACAvN,KAAA6e,UAAA,SAAA7e,KAAAyF,OAAAqM,GAAA,KAAA9R,KAAAmO,OAAA2D,GAAA,GACA,CAIA,aAAAkN,CAAA/B,GACA,GAAAjd,KAAAyF,SAAAwX,GAAAjd,KAAAmO,SAAA8O,EACA,MAAA,IAAArU,MAAA,kDAEA,OAAA5I,KAAAyF,SAAAwX,EAAAjd,KAAAmO,OAAAnO,KAAAyF,MACA,CAIA,aAAA2a,CAAAjD,GACA,OAAAnd,KAAAyF,SAAA0X,EAAA1X,QAAAzF,KAAAyF,SAAA0X,EAAAhP,OACAnO,KAAAyF,OAEAzF,KAAAmO,SAAAgP,EAAA1X,QAAAzF,KAAAmO,SAAAgP,EAAAhP,OACAnO,KAAAmO,OAEA,IACA,CAIA,UAAAkS,CAAAC,EAAAC,GACA,OAAAvgB,KAAAyF,SAAA6a,GAAAtgB,KAAAmO,SAAAoS,GAAAvgB,KAAAyF,SAAA8a,GAAAvgB,KAAAmO,SAAAmS,CACA,CAIA,QAAAE,GACA,MAAA,CAAAxgB,KAAAyF,OAAAzF,KAAAmO,OACA,CAIA,YAAAyR,CAAA3C,GACA,OAAAjd,KAAAyF,SAAAwX,GAAAjd,KAAAmO,SAAA8O,CACA,CAKA,UAAAuC,CAAArC,GACA,OAAAlV,GAAAjI,KAAAyF,OAAAiX,MAAAS,IAAAlV,GAAAjI,KAAAmO,OAAAuO,MAAAS,EACA,CAIA,YAAAsD,CAAAxD,GACArV,GAAA5H,KAAAyF,OAAAiX,MAAA1c,MACA4H,GAAA5H,KAAAyF,OAAA+Y,SAAAxe,MACAid,EAAAP,MAAA9S,KAAA5J,MACAid,EAAAuB,SAAA5U,KAAA5J,MACAA,KAAAyF,OAAAwX,CACA,CAMA,YAAAyD,CAAAzD,GACArV,GAAA5H,KAAAmO,OAAAuO,MAAA1c,MACA4H,GAAA5H,KAAAmO,OAAAsQ,SAAAze,MACAid,EAAAP,MAAA9S,KAAA5J,MACAid,EAAAwB,SAAA7U,KAAA5J,MACAA,KAAAmO,OAAA8O,CACA,CAIA,YAAA0D,CAAAjU,EAAAkU,GACA5gB,KAAAyF,SAAAiH,EACA1M,KAAAygB,aAAAG,GAEA5gB,KAAAmO,SAAAzB,GACA1M,KAAA0gB,aAAAE,EAEA,CAIA,OAAA7Q,GACA,MAAA8Q,EAAA7gB,KAAAyF,OACAqb,EAAA9gB,KAAAmO,OAOA,OANAnO,KAAAyF,OAAAqb,EACAlZ,GAAAiZ,EAAArC,SAAAxe,MACAA,KAAAyF,OAAA+Y,SAAA5U,KAAA5J,MACAA,KAAAmO,OAAA0S,EACAjZ,GAAAkZ,EAAArC,SAAAze,MACAA,KAAAmO,OAAAsQ,SAAA7U,KAAA5J,MACAA,IACA,CAIA,QAAA+gB,CAAA5S,GACA,GAAAnO,KAAAyF,SAAA0I,GAAAnO,KAAAmO,SAAAA,EACA,MAAA,IAAAvF,MAAA,kDAEA5I,KAAAmO,SAAAA,GACAnO,KAAA+P,SAEA,CAIA,iBAAAiR,GACA,MAAAzN,EAAAvT,KAAAuR,QAGA,OAFAgC,EAAAxD,UACAwD,EAAA0N,UAAA,EACA1N,CACA,CAIA,KAAAhC,GAEA,OADA,IAAAyO,GAAAhgB,KAAAyF,OAAAzF,KAAAmO,OAEA,EAQA,MAAA+S,GACA,WAAAzW,CAAA0W,GAMAnhB,KAAA0c,MAAA,GAMA1c,KAAAyc,MAAA,GACAzc,KAAAohB,SAAA,IAAApP,GAMAhS,KAAAyd,QAAA,KAOAzd,KAAAqhB,MAAA,KAMArhB,KAAAic,OAAA,IAAAvH,GAEA1U,KAAAshB,yBAAA,EACAthB,KAAAuN,KAAA,QACAvN,KAAAuhB,eAAA,EACAtd,EAAAkd,GACAvc,EAAAuc,GACAnhB,KAAA8R,GAAAqP,GAGAnhB,KAAAyd,QAAA0D,EACAnhB,KAAA8R,GAAAqP,EAAArP,IAIA9R,KAAA8R,GAAAzB,IAEA,CAOA,kBAAAmR,CAAAC,GAIA,GAHApd,EAAAod,KACAA,GAAA,IAEAzhB,KAAAshB,yBAAAG,EAAA,CAGA,IAAA,IAAA3b,EAAA,EAAAsL,EAAApR,KAAAyc,MAAAnX,OAAAQ,EAAAsL,EAAAtL,IAAA,CACA,MAAAmX,EAAAjd,KAAAyc,MAAA3W,GACAmX,EAAAiC,SAAAlf,KAAAif,YAAAhC,GACAA,EAAAmC,QAAApf,KAAAmf,WAAAlC,EACA,CACAjd,KAAAshB,yBAAA,CANA,CAOA,CAUA,YAAAI,CAAAC,EAAA9N,EAAA+N,GACA,IAAAD,EACA,MAAA,IAAA/Y,MAAA,6BAEAvE,EAAAwP,KACAA,EAAA,GAGA7T,KAAAwhB,qBACAnd,EAAAud,KACAA,EAAA,IAAA5P,GACA1K,GAAAtH,KAAAyc,OAAA,SAAA1S,GACA6X,EAAApgB,IAAAuI,GAAA,EACA,KAEA6X,EAAA9Q,IAAA6Q,GAAA,GACAA,EAAAE,MAAAhO,EACA,MAAAqL,EAAAyC,EAAAzC,SACA,IAAA,IAAApZ,EAAA,EAAAsL,EAAA8N,EAAA5Z,OAAAQ,EAAAsL,EAAAtL,IAAA,CACA,MAAAgc,EAAA5C,EAAApZ,GACAgc,IAAAF,EAAAhR,IAAAkR,IAGA9hB,KAAA0hB,aAAAI,EAAAjO,EAAA,EAAA+N,EACA,CACA,CAQA,IAAAG,CAAAhe,GACA,GAAAM,EAAAN,GAAA,CACA,GAAA/D,KAAAqhB,MAWA,OAAArhB,KAAAqhB,MAXA,CAEA,MAAAW,EAAAjZ,GAAA/I,KAAAyc,OAAA,SAAA1S,GACA,OAAA,IAAAA,EAAA0U,SAAAnZ,MACA,IACA,OAAA0c,GAGAjZ,GAAA/I,KAAAyc,MACA,CAIA,CAEAzc,KAAAqhB,MAAAtd,CAEA,CAQA,sBAAAke,GACAjiB,KAAAuhB,eAAA,EACAvhB,KAAAkiB,iBACA,MAAAC,EAAAxc,GAAA3F,KAAAyc,MAAAnX,QAAA,GACA,IAAA,IAAAoH,EAAA,EAAAA,EAAA1M,KAAAyc,MAAAnX,OAAAoH,KACA,IAAAyV,EAAAzV,KACA1M,KAAAoiB,uBAAAD,EAAAzV,GACA1M,KAAAuhB,kBAGA,MAAAxF,EAAA,GACA,IAAAjW,EACA,IAAAA,EAAA,EAAAA,EAAA9F,KAAAuhB,iBAAAzb,EACAiW,EAAAjW,GAAA,IAAAob,GAEA,IAAApb,EAAA,EAAAA,EAAAqc,EAAA7c,SAAAQ,EAAA,CACAiW,EAAAoG,EAAArc,IACAuc,oBAAAriB,KAAAyc,MAAA3W,GACA,CAKA,OAHAiW,EAAAlS,MAAA,SAAAL,EAAAC,GACA,OAAAA,EAAAgT,MAAAnX,OAAAkE,EAAAiT,MAAAnX,MACA,IACAyW,CACA,CACA,sBAAAqG,CAAAE,EAAAC,GACAD,EAAAC,GAAAviB,KAAAuhB,eACA,MAAAtE,EAAAjd,KAAAyc,MAAA8F,GACAjb,GAAA2V,EAAAP,OAAA,SAAAS,GACA,MACAqF,EADArF,EAAA6B,cAAA/B,GACAwF,OACA,IAAAH,EAAAE,IACAxiB,KAAAoiB,uBAAAE,EAAAE,EAEA,GAAAxiB,KACA,CAMA,UAAAgc,GACA,GAAAhc,KAAAmF,UAEA,OADAnF,KAAAic,OAAA,IAAAvH,GACA1U,KAAAic,OAEA,IAAAxS,EAAA,KACA,IAAA,IAAA3D,EAAA,EAAAsL,EAAApR,KAAAyc,MAAAnX,OAAAQ,EAAAsL,EAAAtL,IAAA,CACA,MAAAmX,EAAAjd,KAAAyc,MAAA3W,GAKA2D,EAJAA,EAIAA,EAAAsL,MAAAkI,EAAAhB,UAHAgB,EAAAhB,QAKA,CAEA,OADAjc,KAAAic,OAAAxS,EACAzJ,KAAAic,MACA,CAUA,eAAAyG,CAAAX,GACA,MAAAY,EAAA,IAAAzB,GACA0B,EAAA,IAAA5Q,GACA,IAAAvM,EAAA0I,EACA,MAAA0U,EAAAd,EAAAxQ,QACAoR,EAAAZ,KAAAc,GACAA,EAAAhB,MAAA,EACAgB,EAAA/Q,GAAAiQ,EAAAjQ,GACA8Q,EAAAphB,IAAAugB,EAAAY,EAAAZ,QACAA,EAAAF,MAAA,EACA,MAAAD,EAAA,GACAkB,EAAA,GACAH,EAAAI,SAAAJ,EAAAZ,QACAH,EAAAhY,KAAAmY,GACAe,EAAAlZ,KAAAmY,GACA,IAAAiB,EAAA,EACA,KAAAF,EAAAxd,OAAA,GAAA,CACA,MAAA6T,EAAA2J,EAAAvG,MACA,IAAA,IAAA0G,EAAA,EAAAA,EAAA9J,EAAAuD,MAAApX,OAAA2d,IAAA,CACA,MACAC,EADA/J,EAAAuD,MAAAuG,GACAjE,cAAA7F,GACA,GAAAlR,GAAA2Z,EAAAsB,GACA,SAEAA,EAAArB,MAAA1I,EAAA0I,MAAA,EACAmB,EAAAE,EAAArB,MAAA,IACAmB,EAAAE,EAAArB,MAAA,GAEA5Z,GAAA6a,EAAAI,IACAJ,EAAAlZ,KAAAsZ,GAEAjb,GAAA2Z,EAAAsB,IACAtB,EAAAhY,KAAAsZ,GAEAN,EAAA7R,YAAAoI,GACA1T,EAAAmd,EAAAhS,IAAAuI,IAGA1T,EAAA0T,EAAA5H,QACA9L,EAAAoc,MAAA1I,EAAA0I,MACApc,EAAAqM,GAAAqH,EAAArH,GACA8Q,EAAAphB,IAAA2X,EAAA1T,IAEAmd,EAAA7R,YAAAmS,GACA/U,EAAAyU,EAAAhS,IAAAsS,IAGA/U,EAAA+U,EAAA3R,QACApD,EAAA0T,MAAAqB,EAAArB,MACA1T,EAAA2D,GAAAoR,EAAApR,GACA8Q,EAAAphB,IAAA0hB,EAAA/U,IAEA,MAAAgV,EAAA,IAAAnD,GAAAva,EAAA0I,GACAwU,EAAAS,QAAAD,EACA,CACA,CACA,MAAAE,EAAA,GACA,IAAA,IAAAvd,EAAA,EAAAA,EAAAkd,EAAAld,IACAud,EAAAzZ,KAAA,IAOA,OALAtC,GAAAqb,EAAAlG,OAAA,SAAAQ,GACAoG,EAAApG,EAAA4E,OAAAjY,KAAAqT,EACA,IACA0F,EAAAU,WAAAA,EACAV,EAAAnB,qBACAmB,CACA,CAQA,cAAAW,CAAAC,EAAAC,GAOA,GANAnf,EAAAkf,KACAA,EAAA,IAEAlf,EAAAmf,KACAA,EAAA,GAEA,IAAAxjB,KAAAyc,MAAAnX,OACA,OAAA,KAEA,GAAA,IAAAtF,KAAAyc,MAAAnX,OACA,OAAA2C,GAAAsb,EAAAvjB,KAAAyc,MAAA,IAAA,KAAAzc,KAAAyc,MAAA,GAEA,MAAAgH,EAAAzjB,KAAAyc,MAAApU,QAAA,SAAA4U,GACA,OAAAhV,GAAAsb,EAAAtG,IAAAA,EAAA0C,UAAA6D,CACA,IACA,OAAAre,EAAAse,GACA,KAEAA,EAAA1d,GAAA,EAAA0d,EAAAne,QACA,CAIA,OAAAH,GACA,OAAAA,EAAAnF,KAAAyc,MACA,CAIA,SAAAiH,GACA,OAAAta,GAAApJ,KAAA0c,OAAA,SAAAS,GACA,OAAAlV,GAAAjI,KAAAyc,MAAAU,EAAA1X,SAAAwC,GAAAjI,KAAAyc,MAAAU,EAAAhP,OACA,GAAAnO,KACA,CAMA,UAAAmf,CAAApV,GACA,IAAA/J,KAAA2jB,QAAA5Z,GACA,MAAA,IAAAnB,MAAA,6CAEA,OAAAmB,EAAAoV,YACA,CAMA,WAAAF,CAAAlV,GACA,IAAA/J,KAAA2jB,QAAA5Z,GACA,MAAA,IAAAnB,MAAA,6CAEA,OAAAmB,EAAAkV,aACA,CAIA,OAAAmE,CAAAQ,EAAAzV,EAAAoR,GACA,GAAAlb,EAAAuf,GACA,MAAA,IAAAhb,MAAA,0CAEA,GAAAvE,EAAA8J,GAAA,CAEA,GAAAlK,EAAA2f,EAAArW,OAAA,SAAAqW,EAAArW,KAEA,YADAvN,KAAA6jB,gBAAAD,GAIA,MAAA,IAAAhb,MAAA,yCAEA,CACA,IAAAkb,EAAA9jB,KAAA+jB,QAAAH,GACAvf,EAAAyf,KACAA,EAAA9jB,KAAAgkB,QAAAJ,IAEA,IAAAK,EAAAjkB,KAAA+jB,QAAA5V,GACA9J,EAAA4f,KACAA,EAAAjkB,KAAAgkB,QAAA7V,IAEA,MAAAgV,EAAA,IAAAnD,GAAA8D,EAAAG,GASA,OARAhgB,EAAAsb,KACA4D,EAAA5D,MAAAA,GAMAvf,KAAA0c,MAAA9S,KAAAuZ,GACAA,CACA,CAIA,cAAAe,GACA,KAAAlkB,KAAA0c,MAAApX,OAAA,GAAA,CACA,MAAA6X,EAAAnd,KAAA0c,MAAA,GACA1c,KAAAyf,WAAAtC,EACA,CACA,CAIA,eAAA0G,CAAA1G,GACA,IAAAnd,KAAAmkB,QAAAhH,GAAA,CAIA,GADAnd,KAAA0c,MAAA9S,KAAAuT,GACAnd,KAAA2jB,QAAAxG,EAAA1X,OAAAqM,IAAA,CAEA,MAAArF,EAAAzM,KAAA+jB,QAAA5G,EAAA1X,OAAAqM,IACAqL,EAAAsD,aAAAhU,EACA,MAEAzM,KAAAgkB,QAAA7G,EAAA1X,QAEA,GAAAzF,KAAA2jB,QAAAxG,EAAAhP,OAAA2D,IAAA,CACA,MAAAsS,EAAApkB,KAAA+jB,QAAA5G,EAAAhP,OAAA2D,IACAqL,EAAAuD,aAAA0D,EACA,MAEApkB,KAAAgkB,QAAA7G,EAAAhP,OAfA,CA6BA,CAOA,OAAAgW,CAAAE,GACA,GAAAzf,EAAAyf,GACA,OAAA3c,GAAA1H,KAAA0c,OAAA,SAAAS,GACA,OAAAA,EAAArL,KAAAuS,CACA,IAEA,GAAA,SAAAA,EAAA9W,KACA,OAAAtF,GAAAjI,KAAA0c,MAAA2H,GAEA,MAAA,IAAAzb,MAAA,wDACA,CAIA,OAAAmb,CAAAO,GACA,MAAAxS,EAAAwS,EAAAxS,IAAAwS,EACA,GAAAtkB,KAAAohB,SAAArQ,YAAAe,GACA,OAAA9R,KAAAohB,SAAAxQ,IAAAkB,EAEA,CAIA,OAAA6R,CAAAW,GACA,MAAAxS,EAAAwS,EAAAxS,IAAAwS,EACA,OAAAtkB,KAAAohB,SAAArQ,YAAAe,EACA,CACA,QAAAiR,CAAA9F,GACAjd,KAAAyc,MAAA7S,KAAAqT,GACAjd,KAAAohB,SAAA5f,IAAAyb,EAAAnL,GAAAmL,EACA,CACA,WAAAsH,CAAAtH,GACArV,GAAA5H,KAAAyc,MAAAQ,GACAjd,KAAAohB,SAAAxZ,OAAAqV,EAAAnL,GACA,CAKA,UAAA0S,CAAAF,GACA,IAAAva,EAAAua,EAIA,GAHA1f,EAAA0f,KACAva,EAAA/J,KAAA+jB,QAAAO,KAEArgB,EAAA8F,GAUA,MAAA,IAAAnB,MAAA,iEAVA,CACA,MAAA8T,EAAA3S,EAAA2S,MACA3S,EAAA2S,MAAA,GACA,IAAA,IAAA5W,EAAA,EAAAsL,EAAAsL,EAAApX,OAAAQ,EAAAsL,EAAAtL,IAAA,CACA,MAAAqX,EAAAT,EAAA5W,GACA9F,KAAAyf,WAAAtC,EACA,CACAnd,KAAAukB,YAAAxa,EACA,CAIA,CAIA,YAAA0a,CAAAC,EAAAC,GACA,OAAAjd,GAAA1H,KAAA0c,OAAA,SAAAS,GACA,OAAAA,EAAA1X,SAAAif,GAAAvH,EAAAhP,SAAAwW,GAAAxH,EAAA1X,SAAAkf,GAAAxH,EAAAhP,SAAAuW,CACA,GACA,CAIA,UAAAjF,CAAAtC,GAKAvV,GAAA5H,KAAA0c,MAAAS,GACAvV,GAAAuV,EAAA1X,OAAA+Y,SAAArB,GACAvV,GAAAuV,EAAA1X,OAAAiX,MAAAS,GACAvV,GAAAuV,EAAAhP,OAAAsQ,SAAAtB,GACAvV,GAAAuV,EAAAhP,OAAAuO,MAAAS,EACA,CAMA,OAAA6G,CAAAM,EAAAM,EAAArF,GACA,IAAAsF,EAAA,KACA,IAAA5gB,EAAAqgB,GACA,MAAA,IAAA1b,MAAA,kDAEA,GAAAhE,EAAA0f,GAAA,CACA,GAAAtkB,KAAA2jB,QAAAW,GACA,OAAAtkB,KAAA+jB,QAAAO,GAEAO,EAAA,IAAAvG,GAAAgG,EACA,KACA,CACA,GAAAtkB,KAAA2jB,QAAAW,GACA,OAAAtkB,KAAA+jB,QAAAO,GAGAO,EAAAP,CACA,CAQA,OAPArgB,EAAA2gB,IACAC,EAAA5I,OAAA2I,GAEA3gB,EAAAsb,KACAsF,EAAAtF,MAAAA,GAEAvf,KAAA+iB,SAAA8B,GACAA,CACA,CAIA,mBAAAxC,CAAApF,GACAjd,KAAA2jB,QAAA1G,IACAjd,KAAA+iB,SAAA9F,GAEA,MAAA6H,EAAA7H,EAAAuB,SACAvB,EAAAuB,SAAA,GACAlX,GAAAwd,GAAA,SAAA3H,GACAnd,KAAA6jB,gBAAA1G,EACA,GAAAnd,KACA,CAIA,cAAAkiB,GACA,IAAApc,EACA,IAAAA,EAAA,EAAAA,EAAA9F,KAAAyc,MAAAnX,SAAAQ,EACA9F,KAAAyc,MAAA3W,GAAA2c,MAAA3c,EAEA,IAAAA,EAAA,EAAAA,EAAA9F,KAAA0c,MAAApX,SAAAQ,EACA9F,KAAA0c,MAAA5W,GAAA2c,MAAA3c,CAEA,CAIA,KAAAyL,CAAAwT,GACA,MAAA1F,EAAA,IAAA6B,GACA8D,EAAA/gB,EAAA8gB,KAAA,IAAAA,EACAC,IACA3F,EAAA1B,QAAA,IAAA3L,GACAqN,EAAAzB,QAAA,IAAA5L,IAGA,MAAA4Q,EAAA,IAAA5Q,GAiBA,OAhBA1K,GAAAtH,KAAAyc,OAAA,SAAAwI,GACA,MAAAC,EAAAD,EAAA1T,QACAqR,EAAA9R,IAAAmU,EAAAC,GACA7F,EAAA0D,SAAAmC,GACAF,GACA3F,EAAA1B,QAAA7M,IAAAoU,EAAAD,EAEA,IACA3d,GAAAtH,KAAA0c,OAAA,SAAAyI,GACA,GAAAvC,EAAA7R,YAAAoU,EAAA1f,SAAAmd,EAAA7R,YAAAoU,EAAAhX,QAAA,CACA,MAAAiX,EAAA/F,EAAA+D,QAAAR,EAAAhS,IAAAuU,EAAA1f,QAAAmd,EAAAhS,IAAAuU,EAAAhX,SACA6W,GACA3F,EAAAzB,QAAA9M,IAAAsU,EAAAD,EAEA,CACA,IACA9F,CACA,CAMA,SAAAgG,CAAAC,GACA,OAAApE,GAAAqE,MAAAF,UAAArlB,KAAAslB,EACA,CAOA,mBAAAE,CAAA7D,EAAA8D,GACA,GAAAphB,EAAAsd,GACA,MAAA,IAAA/Y,MAAA,uCAEA,GAAAvE,EAAAohB,GACA,MAAA,IAAA7c,MAAA,iCAEA,IAAA5I,KAAA2jB,QAAAhC,GACA,MAAA,IAAA/Y,MAAA,kDAEA,MAAA8c,EAAA1lB,KAAA+jB,QAAApC,GAEA3hB,KAAA2lB,aAAAD,EAAAD,EADA,GAEA,CACA,YAAAE,CAAA1I,EAAAwI,EAAA7D,GACA6D,EAAAxI,GACA2E,EAAAhY,KAAAqT,GACA,MAAAiC,EAAAjC,EAAAgC,cACA,IAAA,IAAAnZ,EAAA,EAAAsL,EAAA8N,EAAA5Z,OAAAQ,EAAAsL,EAAAtL,IAAA,CACA,MAAAgc,EAAA5C,EAAApZ,GACAmC,GAAA2Z,EAAAE,IAGA9hB,KAAA2lB,aAAA7D,EAAA2D,EAAA7D,EACA,CACA,CAOA,qBAAAgE,CAAAjE,EAAA8D,GACA,GAAAphB,EAAAsd,GACA,MAAA,IAAA/Y,MAAA,uCAEA,GAAAvE,EAAAohB,GACA,MAAA,IAAA7c,MAAA,iCAEA,IAAA5I,KAAA2jB,QAAAhC,GACA,MAAA,IAAA/Y,MAAA,kDAEA,MAAA8c,EAAA1lB,KAAA+jB,QAAApC,GACAkE,EAAA,IAAA9M,GACA6I,EAAA,GAEA,IADAiE,EAAA3M,QAAAwM,GACAG,EAAAvgB,OAAA,GAAA,CACA,MAAA2X,EAAA4I,EAAAzM,UACAqM,EAAAxI,GACA2E,EAAAhY,KAAAqT,GACA,MAAAiC,EAAAjC,EAAAgC,cACA,IAAA,IAAAnZ,EAAA,EAAAsL,EAAA8N,EAAA5Z,OAAAQ,EAAAsL,EAAAtL,IAAA,CACA,MAAAgc,EAAA5C,EAAApZ,GACAmC,GAAA2Z,EAAAE,IAAA+D,EAAA5d,SAAA6Z,IAGA+D,EAAA3M,QAAA4I,EACA,CACA,CACA,CAcA,4BAAAgE,CAAAC,EAAA9I,EAAA+I,EAAAC,EAAAC,EAAAC,EAAA1D,GACAuD,EAAAxkB,IAAAyb,EAAAwF,GACAwD,EAAAzkB,IAAAyb,EAAAwF,GACAA,IACA0D,EAAAvc,KAAAqT,GACA,MAAAiC,EAAAjC,EAAAgC,cACA,IAAA9F,EACA,IAAA,IAAArT,EAAA,EAAAsL,EAAA8N,EAAA5Z,OAAAQ,EAAAsL,EAAAtL,IACAqT,EAAA+F,EAAApZ,GACAkgB,EAAAjV,YAAAoI,GAIAlR,GAAAke,EAAAhN,IACA8M,EAAAzkB,IAAAyb,EAAAjc,KAAAqO,IAAA4W,EAAArV,IAAAqM,GAAA+I,EAAApV,IAAAuI,MAJAnZ,KAAA8lB,6BAAAC,EAAA5M,EAAA6M,EAAAC,EAAAC,EAAAC,EAAA1D,GACAwD,EAAAzkB,IAAAyb,EAAAjc,KAAAqO,IAAA4W,EAAArV,IAAAqM,GAAAgJ,EAAArV,IAAAuI,MAOA,GAAA8M,EAAArV,IAAAqM,KAAA+I,EAAApV,IAAAqM,GAAA,CACA,MAAAX,EAAA,GACA,GACAnD,EAAAgN,EAAA5J,MACAD,EAAA1S,KAAAuP,SACAA,IAAA8D,KACA8I,GAAAzJ,EAAAhX,OAAA,IACA4gB,EAAAtc,KAAA0S,EAEA,CACA,CAQA,UAAA8J,CAAAL,GACA1hB,EAAA0hB,KACAA,GAAA,GAEA,MAAAC,EAAA,IAAAhU,GACAiU,EAAA,IAAAjU,GACAkU,EAAA,GACAC,EAAA,GACA,IAAA,IAAArgB,EAAA,EAAAsL,EAAApR,KAAAyc,MAAAnX,OAAAQ,EAAAsL,EAAAtL,IAAA,CACA,MAAAmX,EAAAjd,KAAAyc,MAAA3W,GACAkgB,EAAAjV,YAAAkM,IAGAjd,KAAA8lB,6BAAAC,EAAA9I,EAAA+I,EAAAC,EAAAC,EAAAC,EAAA,EACA,CACA,OAAAD,CACA,CAMA,SAAAG,GACA,OAAAlhB,EAAAnF,KAAAomB,aACA,CAMA,UAAAE,CAAAC,GACA,MAAAC,EAAAD,EAAAlB,YACAoB,EAAAzmB,KAAAqlB,YACA,OAAAjc,GAAAod,GAAA,SAAA/Z,GACA,OAAAxE,GAAAwe,EAAAha,EACA,GACA,CAKA,WAAAia,GAEA,GAAA1mB,KAAAmF,WAAAnF,KAAAyc,MAAAnX,QAAA,GAAAtF,KAAA0c,MAAApX,QAAA,EACA,MAAA,GAGA,GAAA,IAAAtF,KAAAyc,MAAAnX,OAAA,CACA,MAAA+D,EAAA,GACA,GAAArJ,KAAA0c,MAAApX,OAAA,EAAA,CACA,MACAqhB,EADA3mB,KAAA0c,MAAA,GACAjX,OACA,IAAA,IAAAK,EAAA,EAAAsL,EAAApR,KAAA0c,MAAApX,OAAAQ,EAAAsL,EAAAtL,IAAA,CACA,MAAAqX,EAAAnd,KAAA0c,MAAA5W,GACA,GAAAqX,EAAA1X,SAAAkhB,EACA,SAEA,MAAAC,EAAAzJ,EAAApN,UACA1G,EAAAO,KAAAgd,EACA,CACA,CACA,OAAAvd,CACA,CACA,MAAAgW,EAAArf,KAAAuR,OAAA,GACAsV,EAAA7mB,KAAAyc,MAAAnX,OACAwhB,EAAA,IAAA9U,GAQA+U,EAAA,SAAA9J,GACA,OAAA,IAAAA,EAAAuB,SAAAlZ,OACA,EAAAuhB,EAEA,IAAA5J,EAAAwB,SAAAnZ,OACAuhB,EAAA,EAGA5J,EAAAuB,SAAAlZ,OAAA2X,EAAAwB,SAAAnZ,MAEA,EAOA0hB,EAAA,SAAA/J,GACA,MAAAgK,EAAAF,EAAA9J,GACA6J,EAAA/V,YAAAkW,IACAH,EAAAhW,IAAAmW,EAAA,IAEAH,EAAAlW,IAAAqW,GAAArd,KAAAqT,EACA,EACA3V,GAAA+X,EAAA5C,OAAA,SAAA/P,GACAsa,EAAAta,EACA,IACA,IAAAwa,EAAA,GACA,MAAAC,EAAA,GACA,KAAA9H,EAAA5C,MAAAnX,OAAA,GAAA,CACA,IAAAG,EAAA0I,EAAA8Y,EACA,GAAAH,EAAA/V,YAAA,EAAA8V,GAAA,CACA,MAAAO,EAAAN,EAAAlW,IAAA,EAAAiW,GACA,KAAAO,EAAA9hB,OAAA,GAAA,CACA6I,EAAAiZ,EAAA7K,MACA,IAAA,IAAA8K,EAAA,EAAAA,EAAAlZ,EAAAuO,MAAApX,OAAA+hB,IAAA,CACA,MAAAC,EAAAnZ,EAAAuO,MAAA2K,GACA5hB,EAAA6hB,EAAAtI,cAAA7Q,GACA8Y,EAAAF,EAAAthB,GACAmC,GAAAkf,EAAAlW,IAAAqW,GAAAxhB,GACAA,EAAAga,WAAA6H,GACAN,EAAAvhB,EACA,CACA4Z,EAAAkF,YAAApW,GACAgZ,EAAAtb,QAAAsC,EACA,CACA,CAEA,GAAA2Y,EAAA/V,YAAA8V,EAAA,GAAA,CACA,MAAA/M,EAAAgN,EAAAlW,IAAAiW,EAAA,GACA,KAAA/M,EAAAxU,OAAA,GAAA,CACAG,EAAAqU,EAAAyC,MACA,IAAA,IAAAgL,EAAA,EAAAA,EAAA9hB,EAAAiX,MAAApX,OAAAiiB,IAAA,CACA,MAAAC,EAAA/hB,EAAAiX,MAAA6K,GACApZ,EAAAqZ,EAAAxI,cAAAvZ,GACAwhB,EAAAF,EAAA5Y,GACAvG,GAAAkf,EAAAlW,IAAAqW,GAAA9Y,GACAA,EAAAsR,WAAA+H,GACAR,EAAA7Y,EACA,CACA+Y,EAAAtd,KAAAnE,GACA4Z,EAAAkF,YAAA9e,EACA,CACA,CACA,GAAA4Z,EAAA5C,MAAAnX,OAAA,EACA,IAAA,IAAA8M,EAAAyU,EAAA,EAAAzU,EAAA,EAAAyU,EAAAzU,IACA,GAAA0U,EAAA/V,YAAAqB,IACA0U,EAAAlW,IAAAwB,GAAA9M,OAAA,EAAA,CACA,MACAoH,EADAoa,EAAAlW,IAAAwB,GACAmK,MACA,IAAA,IAAAkL,EAAA,EAAAA,EAAA/a,EAAAgQ,MAAApX,OAAAmiB,IAAA,CACA,MAAAC,EAAAhb,EAAAgQ,MAAA+K,GACAE,EAAAD,EAAA1I,cAAAtS,GACAua,EAAAF,EAAAY,GACA/f,GAAAkf,EAAAlW,IAAAqW,GAAAU,GACAA,EAAAlI,WAAAiI,GACAV,EAAAW,EACA,CACAT,EAAAtd,KAAA8C,GACA2S,EAAAkF,YAAA7X,GACA,KACA,CAGA,CACAwa,EAAAA,EAAAU,OAAAT,GACA,MAAAU,EAAA,IAAA7V,GACA,IAAA,IAAA8V,EAAA,EAAAA,EAAA9nB,KAAAyc,MAAAnX,OAAAwiB,IACAD,EAAA/W,IAAAuO,EAAA1B,QAAA/M,IAAAsW,EAAAY,IAAAA,GAEA,MAAAC,EAAA,GAOA,OANAzgB,GAAAtH,KAAA0c,OAAA,SAAAS,GACA0K,EAAAjX,IAAAuM,EAAA1X,QAAAoiB,EAAAjX,IAAAuM,EAAAhP,UACAgP,EAAApN,UACAgY,EAAAne,KAAAuT,GAEA,IACA4K,CACA,EAKA7G,GAAA8G,WAAA,CAOAC,WAAA,IACA/G,GAAAqE,MAAArQ,MAAA,CAAA,OAAA,OAAA,OAAA,OAAA,OAAA,OAAA,OAAA,SAQAgT,QAAA,IACAhH,GAAAqE,MAAArQ,MAAA,CAAA,OAAA,OAAA,OAAA,OAAA,OAAA,OAAA,OAAA,OAAA,OAAA,QAAA,QAAA,QACA,SAAA,SAAA,QAAA,QAAA,SAAA,SAAA,SAAA,SAAA,SAAA,SAAA,QAAA,SAAA,SAAA,UAQAiT,WAAA,IACAjH,GAAAqE,MAAArQ,MAAA,CAAA,OAAA,OAAA,SASAkT,WAAAC,IACAhkB,EAAAgkB,KACAA,EAAA,GAEAnH,GAAAqE,MAAA+C,mBAAAD,EAAA,IASAE,OAAAjjB,IACAjB,EAAAiB,KACAA,EAAA,IAEA4b,GAAAqE,MAAA+C,mBAAAhjB,EAAA,IAaAkjB,KAAA,CAAAH,EAAAI,IACAvH,GAAAqE,MAAA+C,mBAAAD,EAAAI,GAcAC,OAAA,CAAAL,EAAAI,EAAAE,IACAzH,GAAAqE,MAAAqD,qBAAAP,EAAAI,EAAAE,GAQAE,SAAA,IACA3H,GAAAqE,MAAArQ,MAAA,CAAA,OAAA,OAAA,OAAA,OAAA,OAAA,OAAA,OAAA,OAAA,OAAA,SAWA,IAAA4T,CAAA/e,EAAAD,GACA,MAAAif,EAAA,IAAA7H,GACA,GAAAnX,GAAA,GAAAD,GAAA,EACA,OAAAif,EAEA,IAAA,IAAAjjB,EAAA,EAAAA,EAAAiE,EAAA,EAAAjE,IAAA,CACA,IAAAkjB,EAAA,KACA,IAAA,IAAAlM,EAAA,EAAAA,EAAAhT,EAAA,EAAAgT,IAAA,CAEA,MAAAG,EAAA,IAAAqB,GAAAxY,EAAAhB,WAAA,IAAAgY,EAAAhY,YAKA,GAJAikB,EAAA/E,QAAA/G,GACA+L,GACAD,EAAA3F,QAAA4F,EAAA/L,GAEAnX,EAAA,EAAA,CACA,MAAAiQ,EAAAgT,EAAAhF,SAAAje,EAAA,GAAAhB,WAAA,IAAAgY,EAAAhY,YACAikB,EAAA3F,QAAArN,EAAAkH,EACA,CACA+L,EAAA/L,CACA,CACA,CACA,OAAA8L,CACA,GAKA7H,GAAAqE,MAAA,CAMA,KAAArQ,CAAA+T,GACA,IAAAC,EACA,MAAAC,EAAA,IAAAjI,GAAAkI,EAAAH,EAAA9c,QACA,IAAA,IAAArG,EAAA,EAAAsL,EAAAgY,EAAA9jB,OAAAQ,EAAAsL,EAAAtL,IAAA,CACA,MAAAujB,EAAAD,EAAAtjB,GACA,GAAAlB,EAAAykB,GAAA,CACA,GAAAA,EAAAthB,QAAA,MAAA,EACA,MAAA,IAAAa,MAAA,2CAEA,MAAA+E,EAAA0b,EAAA1c,MAAA,MACA,GAAA,IAAAgB,EAAArI,OACA,MAAA,IAAAsD,MAAA,2CAEAsgB,EAAA,IAAAlJ,GAAArS,EAAA,GAAAA,EAAA,IACAwb,EAAA/F,QAAA8F,EACA,CACA,GAAA5kB,EAAA+kB,GAAA,CACA,IAAAH,EACA,MAAA,IAAAtgB,MAAA,+CAEAiR,GAAAqP,EAAAG,EACA,CACA,CACA,OAAAF,CACA,EAKA,SAAA9D,CAAA8D,EAAA7D,GACA,GAAAjhB,EAAA8kB,GACA,MAAA,IAAAvgB,MAAA,uDAEAvE,EAAAihB,KACAA,GAAA,GAEA,MAAAgE,EAAA,GACA,IAAA,IAAAxjB,EAAA,EAAAsL,EAAA+X,EAAAzM,MAAApX,OAAAQ,EAAAsL,EAAAtL,IAAA,CACA,MAAAqX,EAAAgM,EAAAzM,MAAA5W,GACAwjB,EAAA1f,KAAAuT,EAAA1X,OAAAqM,GAAA,KAAAqL,EAAAhP,OAAA2D,IACAwT,GACAgE,EAAA1f,KAAA,CAAAkI,GAAAqL,EAAArL,IAEA,CACA,OAAAwX,CACA,EAWAC,UAAA,CAAAC,EAAA7b,EAAAmE,EAAA2X,KACAplB,EAAAsJ,KACAA,EAAA,IAAA8F,GAAA,EAAA,IAEApP,EAAAyN,KACAA,EAAAzB,MAEAoZ,EAAA5P,GAAA,CACA5E,MAAA,GACAD,OAAA,GACAlD,GAAAA,EACA4X,OAAA,GACAC,KAAA,UACAhL,KAAA,SACAiL,UAAA,EACA9iB,EAAA6G,EAAA7G,EACAE,EAAA2G,EAAA3G,GACAyiB,GACAD,EAAAK,SAAAJ,IAYAK,eAAA,CAAArM,EAAA9R,EAAAuD,EAAAxE,IACA+S,EAAAsM,QAAApe,EAAAuD,EAAAxE,GAQA,sBAAAsf,CAAAvM,EAAA0L,EAAAc,EAAAC,GACA,GAAA7lB,EAAAoZ,GACA,MAAA,IAAA7U,MAAA,qCAEA,GAAAvE,EAAA8kB,GACA,MAAA,IAAAvgB,MAAA,mCAEAvE,EAAA4lB,KACAA,GAAA,GAEA5lB,EAAA6lB,KACAA,GAAA,GAEA,MAAAjV,EAAAwI,EAAAvU,QAAAihB,aAAA,IACAnV,EAAAyI,EAAAvU,QAAAkhB,cAAA,IACAxH,EAAA,GACA,IAAA3F,EAAAc,EACA,IAAA,IAAAjY,EAAA,EAAAsL,EAAA+X,EAAA1M,MAAAnX,OAAAQ,EAAAsL,EAAAtL,IAAA,CACAmX,EAAAkM,EAAA1M,MAAA3W,GACA,IAAA6H,EAAAsP,EAAA9T,SACA9E,EAAAsJ,KAEAA,EADA1J,EAAAgZ,EAAAnW,IAAA7C,EAAAgZ,EAAAjW,GACA,IAAAyM,GAAAwJ,EAAAnW,EAAAmW,EAAAjW,GAGA,IAAAyM,GAAA1N,GAAA,GAAAkP,EAAA,IAAAlP,GAAA,GAAAiP,EAAA,MAGA,MAAAqV,EAAA,CAAA,EACA,MAAApN,EAAAnL,IAUAoY,GACArQ,GAAAwQ,EAAA,CACApV,MAAA,IAAAjU,KAAAkF,SAAA,GACA8O,OAAA,GAAAhU,KAAAkF,SAAA,GACAyY,KAAA,YACAgL,KAAA,CACAW,MAAA,aAIAvM,EAAA/d,KAAAupB,UAAA9L,EAAA9P,EAAAsP,EAAAnL,GAAAuY,GAEA,MAAApO,EAAA8B,EAAA9B,SACAhY,EAAAgY,KACAgB,EAAAnW,EAAAmV,EAAAnV,EACAmW,EAAAjW,EAAAiV,EAAAjV,EACAiW,EAAAhI,MAAAgH,EAAAhH,MACAgI,EAAAjI,OAAAiH,EAAAjH,QAEA4N,EAAA3F,EAAAnL,IAAAiM,CACA,CACA,IAAA,IAAAwM,EAAA,EAAAA,EAAApB,EAAAzM,MAAApX,OAAAilB,IAAA,CACA,MAAApN,EAAAgM,EAAAzM,MAAA6N,GACAC,EAAA5H,EAAAzF,EAAA1X,OAAAqM,IACA,GAAAzN,EAAAmmB,GACA,SAEA,MAAAC,EAAA7H,EAAAzF,EAAAhP,OAAA2D,IACAzN,EAAAomB,IAGAzqB,KAAA8pB,eAAArM,EAAA+M,EAAAC,EAAA,CAAA3Y,GAAAqL,EAAArL,IACA,CACA,GAAAmY,EAAA,CACA,IAAAS,GAAAjN,GACAkN,YAAAxB,EAAA,CAAAhP,aAAA,IACA,IAAA,IAAAyQ,EAAA,EAAAA,EAAAzB,EAAA1M,MAAAnX,OAAAslB,IACA3N,EAAAkM,EAAA1M,MAAAmO,GACA7M,EAAA6E,EAAA3F,EAAAnL,IACAiM,EAAA9B,OAAA,IAAAvH,GAAAuI,EAAAnW,EAAAmW,EAAAjW,EAAAiW,EAAAhI,MAAAgI,EAAAjI,QAEA,CACA,EAWA,kBAAAsT,CAAAD,EAAAI,GACApkB,EAAAgkB,KACAA,EAAA,GAEAhkB,EAAAokB,KACAA,EAAA,GAEA,MAAAM,EAAA,IAAA7H,GACA,IAAA2J,EAAAC,GAAA,EAAAC,EAAA,GACA,GAAA1C,GAAA,GAAAI,GAAA,EACA,OAAAM,EAEA,MAAAhH,EAAA,IAAAzD,MAAAwM,GAAAhmB,YACAikB,EAAA/E,QAAAjC,GACAgH,EAAAhH,KAAAA,GACAgJ,EAAAnhB,KAAAmY,GACA,IAAA,IAAAjc,EAAA,EAAAA,EAAAuiB,EAAAviB,IAAA,CACA+kB,EAAA,GACA,IAAA,IAAA/N,EAAA,EAAAA,EAAAiO,EAAAzlB,OAAAwX,IAAA,CACA,MAAAkO,EAAAD,EAAAjO,GACA,IAAA,IAAA1K,EAAA,EAAAA,EAAAqW,EAAArW,IAAA,CACA,MAAA3L,EAAA,IAAA6X,MAAAwM,GAAAhmB,YACAikB,EAAA3F,QAAA4H,EAAAvkB,GACAokB,EAAAjhB,KAAAnD,EACA,CACA,CACAskB,EAAAF,CACA,CACA,OAAA9B,CACA,EAYA,oBAAAH,CAAAP,EAAAI,EAAAwC,GACA5mB,EAAAgkB,KACAA,EAAA,GAEAhkB,EAAAokB,KACAA,EAAA,GAEApkB,EAAA4mB,KACAA,EAAA,GAEA,MAAAlC,EAAA,IAAA7H,GACA,IAAA2J,EAAAC,GAAA,EAAAC,EAAA,GACA,GAAA1C,GAAA,GAAAI,GAAA,GAAAwC,GAAA,EACA,OAAAlC,EAEA,IAAA,IAAA3E,EAAA,EAAAA,EAAA6G,EAAA7G,IAAA,CACA,MAAArC,EAAA,IAAAzD,MAAAwM,GAAAhmB,YACAikB,EAAA/E,QAAAjC,GACAgJ,EAAA,CAAAhJ,GACA,IAAA,IAAAjc,EAAA,EAAAA,EAAAuiB,EAAAviB,IAAA,CACA+kB,EAAA,GACA,IAAA,IAAA/N,EAAA,EAAAA,EAAAiO,EAAAzlB,OAAAwX,IAAA,CACA,MAAAkO,EAAAD,EAAAjO,GACA,IAAA,IAAA1K,EAAA,EAAAA,EAAAqW,EAAArW,IAAA,CACA,MAAA3L,EAAA,IAAA6X,MAAAwM,GAAAhmB,YACAikB,EAAA3F,QAAA4H,EAAAvkB,GACAokB,EAAAjhB,KAAAnD,EACA,CACA,CACAskB,EAAAF,CACA,CACA,CACA,OAAA9B,CACA,EASA,0BAAAmC,CAAAC,EAAAC,EAAAC,GASAhnB,EAAA8mB,KACAA,EAAA,IAEA9mB,EAAA+mB,KACAA,EAAA,GAEA/mB,EAAAgnB,KACAA,GAAA,GAEA,MAAAtC,EAAA,IAAA7H,GACA,IAAA4J,GAAA,EACA,GAAAK,GAAA,EACA,OAAApC,EAEA,MAAAhH,EAAA,IAAAzD,MAAAwM,GAAAhmB,YAEA,GADAikB,EAAA/E,QAAAjC,GACA,IAAAoJ,EACA,OAAApC,EAEA,GAAAoC,EAAA,EAAA,CAEA,IAAA,IAAArlB,EAAA,EAAAA,EAAAqlB,EAAArlB,IAAA,CACA,MAAAwlB,EAAAvC,EAAAzF,eAAA,GAAA8H,GACA,IAAAE,EAEA,MAEA,MAAAzG,EAAAkE,EAAA/E,QAAAle,EAAAhB,YACAikB,EAAA3F,QAAAkI,EAAAzG,EACA,CACA,IAAAwG,GAAAF,EAAA,EAAA,CACA,MAAAI,EAAAxlB,GAAA,EAAAolB,GACA,IAAA,IAAA1D,EAAA,EAAAA,EAAA8D,EAAA9D,IAAA,CACA,MAAA/C,EAAAqE,EAAAzF,eAAA,GAAA8H,GACAzG,EAAAoE,EAAAzF,eAAA,GAAA8H,GACA1G,GAAAC,IAAAoE,EAAAtE,aAAAC,EAAAC,IACAoE,EAAA3F,QAAAsB,EAAAC,EAEA,CACA,CACA,OAAAoE,CACA,CACA,EAUA,aAAAyC,CAAA/N,EAAAgO,EAAAL,EAAAC,EAAAnB,GACA,MAAAnB,EAAA7H,GAAAqE,MAAA2F,2BAAAO,EAAAL,EAAAC,GACAnK,GAAAqE,MAAAyE,uBAAAvM,EAAAsL,GAAA,EAAAmB,EACA,GAWA,MAAAQ,WAAA9O,GACA,WAAAnR,CAAAgT,GAEA,GADAvL,QACA7N,EAAAoZ,GACA,MAAA,IAAA7U,MAAA,6BAEA5I,KAAAyd,QAAAA,CACA,CACA,MAAAiO,CAAAhhB,GACA1K,KAAAud,gBAAA7S,GACA,MACAye,EADA,IAAAwC,GAAA3rB,KAAAyd,SACAmO,QAAAlhB,GACA,GAAAye,EAAAhkB,UACA,OAGA,MAAA4W,EAAAoN,EAAAlH,yBACA,GAAA9c,EAAA4W,GACA,OAEA,IAAA,IAAAjW,EAAA,EAAAA,EAAAiW,EAAAzW,OAAAQ,IAAA,CACA,MAAAwW,EAAAP,EAAAjW,GACA9F,KAAA2qB,YAAArO,EAAA5R,EACA,CACA,MAAAmhB,EAAA7rB,KAAA8b,qBAAAC,GACA,OAAA,IAAAyB,GAAAxd,KAAAyd,QAAAoO,EACA,CACA,WAAAlB,CAAAxB,EAAAze,GACAzG,EAAAyG,IACA1K,KAAAud,gBAAA7S,GAEA1K,KAAAmpB,MAAAA,EACA,MAAA2C,EAAA,EAAA9rB,KAAA0K,QAAA2P,aACAra,KAAA+rB,YAAAD,EACA,MAAAE,EAAAhsB,KAAAisB,kBACAjsB,KAAAiV,MAAA+W,EAAA/W,MACAjV,KAAAgV,OAAAgX,EAAAhX,OACA,IAAA,IAAAkX,EAAA,EAAAA,EAAAlsB,KAAA0K,QAAA4P,WAAA4R,IACAlsB,KAAAmsB,YAAAD,GAAA,EAAAlsB,KAAA0K,QAAA4P,WAAA,EACAta,KAAAoO,OAEApO,KAAA+rB,YAAA/rB,KAAAmsB,YACAL,EAAA,GACAA,GAAA,EAAAI,GAAA,EAAAlsB,KAAA0K,QAAA4P,YAEA,CAIA,IAAAlM,GACA,IAAAtI,EAEA,IAAAA,EAAA,EAAAA,EAAA9F,KAAAmpB,MAAA1M,MAAAnX,OAAAQ,IACA9F,KAAAosB,WAAApsB,KAAAmpB,MAAA1M,MAAA3W,IAGA,IAAAA,EAAA,EAAAA,EAAA9F,KAAAmpB,MAAAzM,MAAApX,OAAAQ,IACA9F,KAAAqsB,YAAArsB,KAAAmpB,MAAAzM,MAAA5W,IAGA,IAAAA,EAAA,EAAAA,EAAA9F,KAAAmpB,MAAA1M,MAAAnX,OAAAQ,IAAA,CACA,MAAAmX,EAAAjd,KAAAmpB,MAAA1M,MAAA3W,GACA+N,EAAA7S,KAAAgM,KAAAiQ,EAAA3H,GAAA2H,EAAA3H,GAAA2H,EAAA1H,GAAA0H,EAAA1H,IACA,GAAA,IAAA1B,EACA,OAEAoJ,EAAAnW,GAAA9F,KAAAqO,IAAAwE,EAAA7T,KAAA+rB,aAAA9O,EAAA3H,GAAAzB,EACAoJ,EAAAjW,GAAAhG,KAAAqO,IAAAwE,EAAA7T,KAAA+rB,aAAA9O,EAAA1H,GAAA1B,EACA7T,KAAA0K,QAAAyP,cACA8C,EAAAnW,EAAA9F,KAAAqO,IAAArP,KAAAiV,MAAAjU,KAAAoO,IAAA6N,EAAAhI,MAAA,EAAAgI,EAAAnW,IACAmW,EAAAjW,EAAAhG,KAAAqO,IAAArP,KAAAgV,OAAAhU,KAAAoO,IAAA6N,EAAAjI,OAAA,EAAAiI,EAAAjW,IAEA,CACA,CAOA,MAAAslB,CAAArP,GAEA,MAAAsP,EAAAvrB,KAAAkF,SAAAlG,KAAA0K,QAAA2P,aAAA,EACAmS,EAAA,EAAAxrB,KAAAkF,SAAAlF,KAAAC,GACAgc,EAAAnW,GAAAylB,EAAAvrB,KAAAgN,IAAAwe,GACAvP,EAAAjW,GAAAulB,EAAAvrB,KAAAyrB,IAAAD,EACA,CAWA,mBAAAE,CAAA7f,EAAA9C,EAAAD,GACA,IAAA6iB,EACA,GAAA3sB,KAAAmsB,YAGA,CACA,MAAAS,EAAA7iB,EAAAjD,EAAAgD,EAAAhD,EACA+lB,EAAA9iB,EAAA/C,EAAA8C,EAAA9C,EACA8lB,EAAA/iB,EAAAkL,MAAA,EACA8X,EAAAhjB,EAAAiL,OAAA,EACAgY,EAAAljB,EAAAmL,MAAA,EACAgY,EAAAnjB,EAAAkL,OAAA,EACA2X,EAAA3rB,KAAAksB,IAAAN,EAAA,GAAA5rB,KAAAksB,IAAAJ,EAAAE,EAAAhtB,KAAA0K,QAAA2P,aAAA,GAAArZ,KAAAksB,IAAAL,EAAA,GAAA7rB,KAAAksB,IAAAH,EAAAE,EAAAjtB,KAAA0K,QAAA2P,aAAA,EACA,MAVAsS,EAAA3rB,KAAAksB,IAAArgB,EAAA,GAAA7L,KAAAksB,IAAAltB,KAAA0K,QAAA2P,aAAA,GAWA,OAAA,EAAAsS,EAAA,CACA,CAUA,YAAAQ,CAAAtgB,EAAA9C,EAAAD,GACA,OAAA,EAAA9J,KAAA0sB,oBAAA7f,EAAA9C,EAAAD,EACA,CACA,UAAAsiB,CAAAriB,GACAA,EAAAuL,GAAA,EACAvL,EAAAwL,GAAA,EACAjO,GAAAtH,KAAAmpB,MAAA1M,OAAA,SAAA3S,GACA,GAAAA,IAAAC,EACA,OAEA,KAAAA,EAAAjD,IAAAgD,EAAAhD,GAAAiD,EAAA/C,IAAA8C,EAAA9C,GACAhH,KAAAssB,OAAAxiB,GAEA,MAAAgJ,EAAA/I,EAAAjD,EAAAgD,EAAAhD,EACAiM,EAAAhJ,EAAA/C,EAAA8C,EAAA9C,EACAomB,EAAApsB,KAAAgM,KAAA8F,EAAAA,EAAAC,EAAAA,GACAQ,EAAA,EAAAvT,KAAAmtB,aAAAC,EAAArjB,EAAAD,GACAC,EAAAuL,IAAAxC,EAAAsa,EAAA7Z,EACAxJ,EAAAwL,IAAAxC,EAAAqa,EAAA7Z,CACA,GAAAvT,KACA,CACA,WAAAqsB,CAAAlP,GACA,MAAAiH,EAAAjH,EAAAhP,OACA1B,EAAA0Q,EAAA1X,OACA,GAAAgH,IAAA2X,EAEA,OAEA,KAAA3X,EAAA3F,IAAAsd,EAAAtd,GAAA2F,EAAAzF,IAAAod,EAAApd,GACAhH,KAAAssB,OAAAlI,GAEA,MAAAtR,EAAArG,EAAA3F,EAAAsd,EAAAtd,EACAiM,EAAAtG,EAAAzF,EAAAod,EAAApd,EACAomB,EAAApsB,KAAAgM,KAAA8F,EAAAA,EAAAC,EAAAA,GACAvJ,EAAA,EAAAxJ,KAAA0sB,oBAAAU,EAAA3gB,EAAA2X,GACA9O,EAAAxC,EAAAsa,EAAA5jB,EACA+L,EAAAxC,EAAAqa,EAAA5jB,EACA4a,EAAA9O,IAAAA,EACA8O,EAAA7O,IAAAA,EACA9I,EAAA6I,IAAAA,EACA7I,EAAA8I,IAAAA,CACA,CAOA,eAAA0W,GACA,MAAApF,EAAA7mB,KAAAmpB,MAAA1M,MAAAnX,OACA,GAAA,IAAAuhB,EACA,OAEA,MASAwG,EATA/kB,GAAAtI,KAAAmpB,MAAA1M,OAAA,SAAAhQ,EAAAwQ,GACA,MAAAqQ,EAAArQ,EAAAhI,MAAAgI,EAAAjI,OACA,OAAAsY,EAAA,EACA7gB,GAAAzL,KAAAgM,KAAAsgB,GAGA,CACA,GAAA,EAAAttB,MACA6mB,EACA7lB,KAAAusB,KAAAvsB,KAAAgM,KAAA6Z,IAGA,MAAA,CAAA5R,MAhBA,GAcAoY,EAAArsB,KAAAgM,KAdA,MAgBAgI,OAhBA,GAeAqY,EAAArsB,KAAAgM,KAfA,MAiBA,EASA,MAAA2e,GACA,WAAAlhB,CAAAgT,GAMAzd,KAAA2d,QAAA,IAAA3L,GAMAhS,KAAAwtB,SAAA,IAAAxb,GAMAhS,KAAAyc,MAAA,GAMAzc,KAAAytB,MAAA,GAGAztB,KAAA0tB,QAAA,IAAA1b,GAMAhS,KAAA2tB,WAAA,GAMA3tB,KAAA4tB,WAAA,GAMA5tB,KAAA6tB,mBAAA,GAMA7tB,KAAA8tB,cAAA,GAMA9tB,KAAA+tB,SAAA,IAAA/b,GAOAhS,KAAAguB,UAAA,IAAA9M,GAOAlhB,KAAAiuB,WAAA,KACAjuB,KAAAyd,QAAAA,CACA,CAYA,OAAAmO,CAAAlhB,GACA,GAAArG,EAAArE,KAAAyd,SACA,MAAA,IAAA7U,MAAA,0BAsBA,OApBA5I,KAAA0K,QAAAmP,GAAA,CACA6B,iBAAA,EACAF,kBAAA,EACAC,yBAAA,GACA/Q,GAAA,CAAA,GACA1K,KAAAsJ,QAEAtJ,KAAAkuB,qBAEAluB,KAAAmuB,0BAEAnuB,KAAA2tB,WAAA,IAAA3b,GAAAhS,KAAAyc,OACAzc,KAAA4tB,WAAA,IAAA5b,GAAAhS,KAAAytB,OACAztB,KAAAiuB,WAAA,IAAA/M,GACAlhB,KAAA2tB,WAAArmB,SAAA,SAAAyC,GACA/J,KAAAiuB,WAAAjK,QAAAja,EACA,GAAA/J,MACAA,KAAA4tB,WAAAtmB,SAAA,SAAA8mB,GACApuB,KAAAiuB,WAAApK,gBAAAuK,EACA,GAAApuB,MACAA,KAAAiuB,UACA,CAOA,aAAAI,CAAApO,GACA,OAAAjgB,KAAA0tB,QAAA9c,IAAAqP,EAAAnO,GACA,CAOA,QAAAwc,CAAAvQ,GACA,OAAA/d,KAAA2d,QAAA/M,IAAAmN,EAAAjM,GACA,CAOA,OAAAyc,CAAA/kB,EAAAC,GACA,OAAAV,GAAAS,EAAAkT,OAAA,SAAAS,GACA,OAAAA,EAAA6B,cAAAxV,KAAAC,CACA,GACA,CAIA,KAAAH,GACAtJ,KAAAiuB,WAAA,KACAjuB,KAAAguB,WAAAhuB,KAAA0K,QAAA8Q,kBAAAxb,KAAA0K,QAAA+Q,wBAAA,IAAAyF,GAAA,KACAlhB,KAAA+tB,UAAA/tB,KAAA0K,QAAA8Q,kBAAAxb,KAAA0K,QAAA+Q,wBAAA,IAAAzJ,GAAA,KACAhS,KAAA2d,QAAA,IAAA3L,GACAhS,KAAAwtB,SAAA,IAAAxb,GACAhS,KAAAyc,MAAA,GACAzc,KAAAytB,MAAA,GACAztB,KAAA0tB,QAAA,IAAA1b,GACAhS,KAAA6tB,mBAAA,GACA7tB,KAAA8tB,cAAA,GACA9tB,KAAA2tB,WAAA,GACA3tB,KAAA4tB,WAAA,EACA,CAOA,UAAAY,CAAAC,GACA,MAAAlmB,EAAA,GACA,IAAAkE,EAAAgiB,EAAA5W,UACA,IAAApL,EACA,OAAAlE,EAGA,IADAA,EAAAqB,KAAA6C,GACAA,EAAAiiB,iBACAjiB,EAAAA,EAAAiiB,gBACAnmB,EAAAqB,KAAA6C,GAGA,OADAlE,EAAAwH,UACAxH,CACA,CACA,0BAAAomB,CAAA5Q,GACA,OAAAA,EAAA6Q,cAAA5uB,KAAA6uB,gBAAA9Q,GACAA,EAEAA,EAAA2Q,gBAAA1uB,KAAA2uB,2BAAA5Q,EAAA2Q,iBAAA,IACA,CACA,qBAAAI,CAAAtlB,EAAAC,GACA,SAAAD,EAAAolB,cAAA5uB,KAAA+uB,eAAAvlB,EAAAC,KAGAA,EAAAmlB,aAAA5uB,KAAA+uB,eAAAtlB,EAAAD,EACA,CASA,cAAAulB,CAAAC,EAAAxlB,GACA,IAAAwlB,EAAAJ,YACA,MAAA,IAAAhmB,MAAA,0BAEA,GAAAomB,IAAAxlB,EACA,OAAA,EAEA,GAAAvB,GAAA+mB,EAAA9P,SAAA1V,GACA,OAAA,EAEA,MAAAylB,EAAA,GACA,IAAA,IAAAnpB,EAAA,EAAAsL,EAAA4d,EAAA9P,SAAA5Z,OAAAQ,EAAAsL,EAAAtL,IAAA,CACA,MAAAmH,EAAA+hB,EAAA9P,SAAApZ,GACAmH,EAAA2hB,aAAA5uB,KAAA+uB,eAAA9hB,EAAAzD,IACAylB,EAAArlB,KAAAqD,EAEA,CACA,OAAAgiB,EAAA3pB,OAAA,CACA,CACA,eAAAupB,CAAA9Q,GACA,OAAA/d,KAAA0K,QAAAgR,kBACAqC,EAAAmR,cAAAlvB,KAAAmvB,WAAApR,QAGAA,EAAAmR,aAAAlvB,KAAAmvB,WAAApR,IAMAA,EAAAmR,cAAAlvB,KAAAovB,OAAArR,EAEA,CAQA,aAAAsR,CAAAtR,GACA,OAAAA,EAAAmR,cAAAlvB,KAAAmvB,WAAApR,KAAA/d,KAAAovB,OAAArR,EACA,CACA,mBAAAuR,CAAA9lB,EAAAC,GACA,IAAAD,EACA,MAAA,IAAAZ,MAAA,iCAEA,IAAAa,EACA,MAAA,IAAAb,MAAA,iCAEA,IAAA5I,KAAAguB,UACA,MAAA,IAAAplB,MAAA,2BAEA,MAAA2mB,EAAAvvB,KAAAwuB,WAAAhlB,GACAmN,EAAA3W,KAAAwuB,WAAA/kB,GACA,IAAAuY,EAAA,KACA,GAAA7c,EAAAoqB,IAAApqB,EAAAwR,GACA,OAAA3W,KAAAguB,UAAAjM,OAAApD,KAEA,IAAA6Q,EAAAD,EAAA,GACAE,EAAA9Y,EAAA,GACA7Q,EAAA,EACA,KAAA0pB,IAAAC,IACAzN,EAAAuN,EAAAzpB,GACAA,MACAA,GAAAypB,EAAAjqB,QAAAQ,GAAA6Q,EAAArR,UAGAkqB,EAAAD,EAAAzpB,GACA2pB,EAAA9Y,EAAA7Q,GAEA,OAAAkc,EAIAhiB,KAAAguB,UAAAvR,MAAApU,QAAA,SAAA0B,GACA,OAAAA,EAAA4U,KAAA9G,YAAAmK,CACA,IALAhiB,KAAAguB,UAAAjM,OAAApD,IAOA,CAQA,MAAAyQ,CAAA3oB,GACA,OAAAA,EAAAioB,eACA,CASA,UAAAS,CAAApR,GACA,QAAAA,EAAA2R,YAGA3R,EAAA2Q,gBAAA1uB,KAAAmvB,WAAApR,EAAA2Q,iBAAA3Q,EAAA2R,UACA,CACA,YAAAC,CAAA5R,GACA,SAAAA,EAAA6Q,cAAA7Q,EAAAmR,cAGAnR,EAAA2Q,iBAAA1uB,KAAA2vB,aAAA5R,EAAA2Q,gBACA,CAMA,kBAAAR,GAEA,IAAAluB,KAAA0K,QAAA8Q,iBAgBA,MAAA,IAAA5S,MAAA,qDAfA,IAAA,IAAA9C,EAAA,EAAAsL,EAAApR,KAAAyd,QAAAW,OAAA9Y,OAAAQ,EAAAsL,EAAAtL,IAAA,CACA,MAAAiY,EAAA/d,KAAAyd,QAAAW,OAAAtY,GAEA,GAAA9F,KAAA0K,QAAAgR,kBAAA1b,KAAAmvB,WAAApR,IAAAA,EAAA6Q,YAAA,CACA5uB,KAAA8tB,cAAAlkB,KAAAmU,GACA,QACA,CACA,MAAAd,EAAA,IAAAqB,GAAAP,EAAAjM,GAAAiM,GACAd,EAAA2B,WAAA,EAEA5e,KAAA2d,QAAAnc,IAAAuc,EAAAjM,GAAAmL,GACAjd,KAAAyc,MAAA7S,KAAAqT,EACA,CAKA,CAMA,uBAAAkR,GACA,GAAA,IAAAnuB,KAAAyd,QAAAY,YAAA/Y,OAGA,IAAA,IAAAQ,EAAA,EAAAsL,EAAApR,KAAAyd,QAAAY,YAAA/Y,OAAAQ,EAAAsL,EAAAtL,IAAA,CACA,MAAAkY,EAAAhe,KAAAyd,QAAAY,YAAAvY,GACA,GAAA9F,KAAA6uB,gBAAA7Q,GAAA,CACAhe,KAAA6tB,mBAAAjkB,KAAAoU,GACA,QACA,CACA,IAAAvY,EAAAuY,EAAA4R,gBAAA5R,EAAA4R,gBAAA7R,MAAA,KACA8R,EAAA7R,EAAA8R,gBAAA9R,EAAA8R,gBAAA/R,MAAA,KAEA,IAAAtY,IAAAoqB,EAAA,CACA7vB,KAAA6tB,mBAAAjkB,KAAAoU,GACA,QACA,CACA,GAAA/V,GAAAjI,KAAA8tB,cAAAroB,KAAAzF,KAAAwtB,SAAAzc,YAAAtL,GAAA,CACAzF,KAAA6tB,mBAAAjkB,KAAAoU,GACA,QACA,CACA,GAAA/V,GAAAjI,KAAA8tB,cAAA+B,KAAA7vB,KAAAwtB,SAAAzc,YAAA8e,GAAA,CACA7vB,KAAA6tB,mBAAAjkB,KAAAoU,GACA,QACA,CAEAhe,KAAAwtB,SAAAzc,YAAAtL,KACAA,EAAAzF,KAAAwtB,SAAA/nB,IAEAzF,KAAAwtB,SAAAzc,YAAA8e,KACAA,EAAA7vB,KAAAwtB,SAAAqC,IAEA,MAAAE,EAAA/vB,KAAAsuB,SAAA7oB,GACAuqB,EAAAhwB,KAAAsuB,SAAAuB,GACA,GAAAE,IAAAC,GAAAhwB,KAAAiwB,oBAAAF,EAAAC,GACAhwB,KAAA6tB,mBAAAjkB,KAAAoU,OADA,CAIA,GAAA,OAAA+R,GAAA,OAAAC,EACA,MAAA,IAAApnB,MAAA,qCAEA,IAAA5I,KAAA0K,QAAA8Q,iBAWA,MAAA,IAAA5S,MAAA,qDAXA,CAEA,GAAAmnB,EAAAnR,WAAAoR,EAAApR,UAAA,CACA5e,KAAA6tB,mBAAAjkB,KAAAoU,GACA,QACA,CACA,MAAAkS,EAAA,IAAAlQ,GAAA+P,EAAAC,EAAAhS,EAAAlM,GAAAkM,GACAhe,KAAA0tB,QAAAlsB,IAAAwc,EAAAlM,GAAAoe,GACAlwB,KAAAytB,MAAA7jB,KAAAsmB,EACA,CAbA,CAiBA,CACA,CACA,mBAAAD,CAAAlmB,EAAAD,GACA,OAAApC,GAAA1H,KAAAytB,OAAA,SAAAW,GACA,OAAAA,EAAA3oB,SAAAsE,GAAAqkB,EAAAjgB,SAAArE,GAAAskB,EAAA3oB,SAAAqE,GAAAskB,EAAAjgB,SAAApE,CACA,GACA,EAGA,SAAAomB,GAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACA,MAAAC,GAAAJ,EAAAvpB,EAAAspB,EAAAtpB,IAAAypB,EAAAvpB,EAAAspB,EAAAtpB,IAAAqpB,EAAArpB,EAAAopB,EAAAppB,IAAAupB,EAAAzpB,EAAAwpB,EAAAxpB,GACA,GAAAhD,EAAA2sB,GAEA,OAEA,MAEAld,IAFA6c,EAAAppB,EAAAspB,EAAAtpB,IAAAupB,EAAAzpB,EAAAwpB,EAAAxpB,IAAAspB,EAAAtpB,EAAAwpB,EAAAxpB,IAAAypB,EAAAvpB,EAAAspB,EAAAtpB,IAEAypB,EACAhkB,IAFA2jB,EAAAppB,EAAAspB,EAAAtpB,IAAAqpB,EAAAvpB,EAAAspB,EAAAtpB,IAAAspB,EAAAtpB,EAAAwpB,EAAAxpB,IAAAupB,EAAArpB,EAAAopB,EAAAppB,IAEAypB,EACA,OAAAD,IAAAjd,EAAA,GAAAA,EAAA,GAAA9G,EAAA,GAAAA,EAAA,QAAA,EAOA,IAAAgH,GAAA2c,EAAAtpB,EAAAyM,GAAA8c,EAAAvpB,EAAAspB,EAAAtpB,GAAAspB,EAAAppB,EAAAuM,GAAA8c,EAAArpB,EAAAopB,EAAAppB,GACA,CACA,MAAA0pB,GAAA,CACAC,MAAA,CAAAP,EAAAC,EAAAC,EAAAC,IACAJ,GAAAC,EAAAC,EAAAC,EAAAC,GAEAK,SAAA,CAAAR,EAAAC,EAAAC,EAAAC,IACAJ,GAAAC,EAAAC,EAAAC,EAAAC,GAAA,GAEAM,aAAA,CAAAxa,EAAA1P,EAAAC,IACA8pB,GAAAE,SAAAjqB,EAAAC,EAAAyP,EAAAL,UAAAK,EAAAJ,aACAya,GAAAE,SAAAjqB,EAAAC,EAAAyP,EAAAJ,WAAAI,EAAAF,gBACAua,GAAAE,SAAAjqB,EAAAC,EAAAyP,EAAAH,aAAAG,EAAAF,gBACAua,GAAAE,SAAAjqB,EAAAC,EAAAyP,EAAAL,UAAAK,EAAAH,cAEA,KAAA4a,CAAAC,EAAAC,EAAAxd,GACA,IAAAgD,EAAAwa,EAAAhb,UAAAS,EAAAua,EAAA/a,WAAAU,EAAAqa,EAAA9a,aAAAQ,EAAAsa,EAAA7a,cACA,MAAA9O,EAAA2pB,EAAA3pB,SACAmM,IACAgD,EAAAA,EAAAI,OAAApD,EAAAnM,GACAoP,EAAAA,EAAAG,OAAApD,EAAAnM,GACAsP,EAAAA,EAAAC,OAAApD,EAAAnM,GACAqP,EAAAA,EAAAE,OAAApD,EAAAnM,IAEA,IAAA4pB,EAAAF,EAAA9oB,SAAAuO,IACAua,EAAA9oB,SAAAwO,IACAsa,EAAA9oB,SAAA0O,IACAoa,EAAA9oB,SAAAyO,IACAga,GAAAG,aAAAE,EAAAva,EAAAC,IACAia,GAAAG,aAAAE,EAAAva,EAAAG,IACA+Z,GAAAG,aAAAE,EAAAta,EAAAC,IACAga,GAAAG,aAAAE,EAAApa,EAAAD,GACA,IAAAua,EAAA,CAKA,GAJAza,EAAAua,EAAA/a,UACAS,EAAAsa,EAAA9a,WACAU,EAAAoa,EAAA7a,aACAQ,EAAAqa,EAAA5a,cACA3C,EAAA,CACA,MAAA0d,EAAA,IAAA1d,EACAgD,EAAAA,EAAAI,OAAAsa,EAAA7pB,GACAoP,EAAAA,EAAAG,OAAAsa,EAAA7pB,GACAsP,EAAAA,EAAAC,OAAAsa,EAAA7pB,GACAqP,EAAAA,EAAAE,OAAAsa,EAAA7pB,EACA,CACA4pB,EAAAD,EAAA/oB,SAAAuO,IACAwa,EAAA/oB,SAAAwO,IACAua,EAAA/oB,SAAA0O,IACAqa,EAAA/oB,SAAAyO,EACA,CACA,OAAAua,CACA,GAGArO,GAAA,CAAArb,EAAAhB,IAAAgB,EAAAqb,IAAArc,GAIA,MAAA4qB,GACA,WAAA1mB,CAAAjB,EAAAC,EAAAwD,EAAAJ,EAAAb,EAAAolB,GACApxB,KAAAwJ,EAAAA,GAAA,EACAxJ,KAAAyJ,EAAAA,GAAA,EACAzJ,KAAAiN,EAAAA,GAAA,EACAjN,KAAA6M,EAAAA,GAAA,EACA7M,KAAAgM,EAAAA,GAAA,EACAhM,KAAAoxB,EAAAA,GAAA,CACA,CACA,UAAAC,CAAAvnB,GACA,MAAA4C,EAAA,IAAAykB,GAOA,OANAzkB,EAAAlD,EAAAM,EAAAN,EACAkD,EAAAjD,EAAAK,EAAAL,EACAiD,EAAAO,EAAAnD,EAAAmD,EACAP,EAAAG,EAAA/C,EAAA+C,EACAH,EAAAV,EAAAlC,EAAAkC,EACAU,EAAA0kB,EAAAtnB,EAAAsnB,EACA1kB,CACA,EAKA,MAAA4kB,GACA,WAAA7mB,CAAAjB,EAAAC,EAAAwD,EAAAJ,EAAAb,EAAAolB,GACApxB,KAAAwJ,EAAAA,GAAA,EACAxJ,KAAAyJ,EAAAA,GAAA,EACAzJ,KAAAiN,EAAAA,GAAA,EACAjN,KAAA6M,EAAAA,GAAA,EACA7M,KAAAgM,EAAAA,GAAA,EACAhM,KAAAoxB,EAAAA,GAAA,CACA,CACA,IAAAzd,CAAA7J,GACA9J,KAAAwJ,GAAAM,EAAAN,EACAxJ,KAAAyJ,GAAAK,EAAAL,EACAzJ,KAAAiN,GAAAnD,EAAAmD,EACAjN,KAAA6M,GAAA/C,EAAA+C,EACA7M,KAAAgM,GAAAlC,EAAAkC,EACAhM,KAAAoxB,GAAAtnB,EAAAsnB,CACA,CACA,KAAAxd,CAAA9J,GACA9J,KAAAwJ,GAAAM,EAAAN,EACAxJ,KAAAyJ,GAAAK,EAAAL,EACAzJ,KAAAiN,GAAAnD,EAAAmD,EACAjN,KAAA6M,GAAA/C,EAAA+C,EACA7M,KAAAgM,GAAAlC,EAAAkC,EACAhM,KAAAoxB,GAAAtnB,EAAAsnB,CACA,CACA,KAAAtd,CAAAhK,GACA,OAAA,IAAAwnB,GAAAtxB,KAAAwJ,EAAAM,EAAAN,EAAAxJ,KAAAiN,EAAAnD,EAAAL,EAAAzJ,KAAAyJ,EAAAK,EAAAN,EAAAxJ,KAAA6M,EAAA/C,EAAAL,EAAAzJ,KAAAwJ,EAAAM,EAAAmD,EAAAjN,KAAAiN,EAAAnD,EAAA+C,EAAA7M,KAAAyJ,EAAAK,EAAAmD,EAAAjN,KAAA6M,EAAA/C,EAAA+C,EAAA7M,KAAAwJ,EAAAM,EAAAkC,EAAAhM,KAAAiN,EAAAnD,EAAAsnB,EAAApxB,KAAAgM,EAAAhM,KAAAyJ,EAAAK,EAAAkC,EAAAhM,KAAA6M,EAAA/C,EAAAsnB,EAAApxB,KAAAoxB,EACA,CACA,KAAA3lB,CAAAkC,GACA,OAAA,IAAA8F,GAAAzT,KAAAwJ,EAAAmE,EAAA7G,EAAA9G,KAAAiN,EAAAU,EAAA3G,EAAAhH,KAAAgM,EAAAhM,KAAAyJ,EAAAkE,EAAA7G,EAAA9G,KAAA6M,EAAAc,EAAA3G,EAAAhH,KAAAoxB,EACA,CACA,SAAAG,CAAAhe,GACA,OAAAmB,GAAAiD,WAAA3X,KAAAyL,MAAA8H,EAAAyC,WAAAhW,KAAAyL,MAAA8H,EAAA4C,eACA,CACA,QAAArR,GACA,MAAA,UAAA9E,KAAAwJ,EAAA,IAAAxJ,KAAAyJ,EAAA,IAAAzJ,KAAAiN,EAAA,IAAAjN,KAAA6M,EAAA,IAAA7M,KAAAgM,EAAA,IAAAhM,KAAAoxB,EAAA,GACA,CACA,oBAAAI,CAAAC,GACA,MAAA3nB,EAAA,IAAAwnB,GAOA,OANAxnB,EAAAN,EAAAioB,EAAAjoB,EACAM,EAAAL,EAAAgoB,EAAAhoB,EACAK,EAAAmD,EAAAwkB,EAAAxkB,EACAnD,EAAA+C,EAAA4kB,EAAA5kB,EACA/C,EAAAkC,EAAAylB,EAAAzlB,EACAlC,EAAAsnB,EAAAK,EAAAL,EACAtnB,CACA,CACA,uBAAA4nB,CAAAhlB,GACA,MAAA5C,EAAA,IAAAwnB,GAOA,OANAxnB,EAAAN,EAAAkD,EAAAlD,EACAM,EAAAL,EAAAiD,EAAAjD,EACAK,EAAAmD,EAAAP,EAAAO,EACAnD,EAAA+C,EAAAH,EAAAG,EACA/C,EAAAkC,EAAAU,EAAAV,EACAlC,EAAAsnB,EAAA1kB,EAAA0kB,EACAtnB,CACA,CACA,eAAA6nB,CAAAjlB,GACA,GAAA,IAAAA,EAAApH,OACA,MAAA,IAAAsD,MAAA,kDAEA,MAAAkB,EAAA,IAAAwnB,GAOA,OANAxnB,EAAAN,EAAAkD,EAAA,GACA5C,EAAAL,EAAAiD,EAAA,GACA5C,EAAAmD,EAAAP,EAAA,GACA5C,EAAA+C,EAAAH,EAAA,GACA5C,EAAAkC,EAAAU,EAAA,GACA5C,EAAAsnB,EAAA1kB,EAAA,GACA5C,CACA,CACA,kBAAA8nB,CAAA9qB,EAAAE,GACA,MAAA8C,EAAA,IAAAwnB,GAOA,OANAxnB,EAAAN,EAAA,EACAM,EAAAL,EAAA,EACAK,EAAAmD,EAAA,EACAnD,EAAA+C,EAAA,EACA/C,EAAAkC,EAAAlF,EACAgD,EAAAsnB,EAAApqB,EACA8C,CACA,CACA,WAAA+nB,GACA,OAAA,IAAAP,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,CACA,eAAAQ,CAAAte,EAAA1M,EAAAE,GACA,MAAA8C,EAAA,IAAAwnB,GAOA,OANAxnB,EAAAN,EAAAxI,KAAAgN,IAAAwF,EAAAxS,KAAAC,GAAA,KACA6I,EAAAL,EAAAzI,KAAAyrB,IAAAjZ,EAAAxS,KAAAC,GAAA,KACA6I,EAAAmD,GAAAnD,EAAAL,EACAK,EAAA+C,EAAA/C,EAAAN,EACAM,EAAAkC,EAAAlF,EAAAA,EAAAgD,EAAAN,EAAAxC,EAAA8C,EAAAL,GAAA,EACAK,EAAAsnB,EAAApqB,EAAAA,EAAA8C,EAAAN,EAAA1C,EAAAgD,EAAAL,GAAA,EACAK,CACA,CACA,cAAAioB,CAAAhb,EAAAC,GACA,MAAAlN,EAAA,IAAAwnB,GAOA,OANAxnB,EAAAN,EAAAuN,EACAjN,EAAAL,EAAA,EACAK,EAAAmD,EAAA,EACAnD,EAAA+C,EAAAmK,EACAlN,EAAAkC,EAAA,EACAlC,EAAAsnB,EAAA,EACAtnB,CACA,CACA,YAAAoL,CAAAxI,GACA,IAAA0c,EAAA4I,EACA,GAAAtlB,EAAA,CAGA,GAAA,YAFAA,EAAAA,EAAAulB,QAEA9lB,MAAA,EAAA,GAAA+L,cAAA,CAGA,GAFA8Z,EAAAtlB,EAAAP,MAAA,EAAAO,EAAApH,OAAA,GAAA2sB,OACA7I,EAAA4I,EAAArlB,MAAA,KACA,IAAAyc,EAAA9jB,OACA,OAAAgsB,GAAAK,SAAA/O,GAAAwG,GAAA,SAAAzb,GACA,OAAA1I,WAAA0I,EACA,KAGA,GADAyb,EAAA4I,EAAArlB,MAAA,KACA,IAAAyc,EAAA9jB,OACA,OAAAgsB,GAAAK,SAAA/O,GAAAwG,GAAA,SAAAzb,GACA,OAAA1I,WAAA0I,EACA,IAEA,CAKA,GAHA,MAAAjB,EAAAP,MAAA,EAAA,IAAA,MAAAO,EAAAP,MAAAO,EAAApH,OAAA,KACAoH,EAAAA,EAAAwlB,OAAA,EAAAxlB,EAAApH,OAAA,IAEAoH,EAAA3E,QAAA,KAAA,IACAqhB,EAAA1c,EAAAC,MAAA,KACA,IAAAyc,EAAA9jB,QACA,OAAAgsB,GAAAK,SAAA/O,GAAAwG,GAAA,SAAAzb,GACA,OAAA1I,WAAA0I,EACA,KAGA,GAAAjB,EAAA3E,QAAA,KAAA,IACAqhB,EAAA1c,EAAAC,MAAA,KACA,IAAAyc,EAAA9jB,QACA,OAAAgsB,GAAAK,SAAA/O,GAAAwG,GAAA,SAAAzb,GACA,OAAA1I,WAAA0I,EACA,IAGA,CACA,OAAAyb,CACA,EAyBA,MAAA+I,GACA,WAAA1nB,CAAAkD,EAAAoI,EAAAF,GACA7V,KAAAqV,MAAA1H,EACA3N,KAAA+V,KAAAA,EACA/V,KAAA6V,MAAAA,CACA,EAuFA,MAAAuc,GACA,WAAA3nB,CAAAwK,EAAAD,GACAhV,KAAAiV,MAAAA,EACAjV,KAAAgV,OAAAA,CACA,CACA,YAAAqd,GACA,OAAA,IAAAD,GAAA,EAAA,EACA,EAGA,MAAAE,GACA,WAAA7nB,CAAA+I,EAAA1M,EAAAE,GACAhH,KAAA8G,EAAAA,GAAA,EACA9G,KAAAgH,EAAAA,GAAA,EACAhH,KAAAwT,MAAAA,CACA,CACA,QAAA1O,GACA,OAAA9E,KAAA8G,GAAA9G,KAAAgH,EACA,UAAAhH,KAAAwT,SAAAxT,KAAA8G,KAAA9G,KAAAgH,KAGA,UAAAhH,KAAAwT,QAEA,CACA,QAAA+e,GACA,OAAAjB,GAAAQ,SAAA9xB,KAAAwT,MAAAxT,KAAA8G,EAAA9G,KAAAgH,EACA,CACA,MAAAK,GACA,OAAA,IAAAoM,GAAAzT,KAAA8G,EAAA9G,KAAAgH,EACA,CACA,MAAAwrB,GACA,OAAA,IAAAF,GA51IA,IA41IAtyB,KAAAwT,MAAAxT,KAAA8G,EAAA9G,KAAAgH,EACA,CACA,aAAAyrB,CAAAX,GACA,OAAA,IAAAQ,GAAAR,EAAAte,MAAAse,EAAAhrB,EAAAgrB,EAAA9qB,EACA,CACA,YAAAkO,CAAAC,GACA,MAAAud,EAAAvd,EAAAhJ,MAAA,EAAAgJ,EAAA7P,OAAA,GAAAqH,MAAA,KACA6G,EAAAvO,WAAAytB,EAAA,IACA5rB,EAAA7B,WAAAytB,EAAA,IACA1rB,EAAA/B,WAAAytB,EAAA,IACA,OAAA,IAAAJ,GAAA9e,EAAA1M,EAAAE,EACA,EAEAsrB,GAAAK,KAAA,IAAAL,GAAA,GAEA,MAAAM,GACA,WAAAnoB,CAAA3D,EAAAE,GACAhH,KAAA8G,EAAAA,EACA9G,KAAAgH,EAAAA,CACA,CACA,QAAAurB,GACA,OAAAjB,GAAAS,QAAA/xB,KAAA8G,EAAA9G,KAAAgH,EACA,CACA,QAAAlC,GACA,MAAA,SAAA9E,KAAA8G,KAAA9G,KAAAgH,IACA,CACA,MAAAwrB,GACA,OAAA,IAAAI,GAAA,EAAA5yB,KAAA8G,EAAA,EAAA9G,KAAAgH,EACA,EAIA,MAAA6rB,GACA,WAAApoB,CAAA3D,EAAAE,GACAhH,KAAA8G,EAAAA,EACA9G,KAAAgH,EAAAA,CACA,CACA,cAAA8rB,GACA,OAAA,IAAA3B,GAAA,EAAA,EAAA,EAAA,EAAAnxB,KAAA8G,EAAA9G,KAAAgH,EACA,CACA,QAAAurB,GACA,OAAAjB,GAAAM,YAAA5xB,KAAA8G,EAAA9G,KAAAgH,EACA,CACA,QAAAlC,GACA,MAAA,aAAA9E,KAAA8G,KAAA9G,KAAAgH,IACA,CACA,IAAA2M,CAAAyD,GACApX,KAAA8G,GAAAsQ,EAAAtQ,EACA9G,KAAAgH,GAAAoQ,EAAApQ,CACA,CACA,KAAA8M,CAAAO,GACArU,KAAA8G,GAAAuN,EACArU,KAAAgH,GAAAqN,CACA,CACA,MAAA/O,GACA,OAAAtE,KAAAgM,KAAAhN,KAAA8G,EAAA9G,KAAA8G,EAAA9G,KAAAgH,EAAAhH,KAAAgH,EACA,CACA,SAAA+M,GACA,IAAA/T,KAAA+yB,QAGA/yB,KAAA8T,MAAA,EAAA9T,KAAAsF,SACA,CACA,MAAAktB,GACA,OAAA,IAAAK,IAAA7yB,KAAA8G,GAAA9G,KAAAgH,EACA,EAGA,MAAAgsB,GACA,WAAAvoB,CAAA3D,EAAAE,EAAA+P,EAAAC,EAAAxD,EAAAnM,GACArH,KAAAizB,UAAA,IAAAJ,GAAA/rB,EAAAE,QACA2B,IAAAoO,QAAApO,IAAAqO,IACAhX,KAAA8W,MAAA,IAAA8b,GAAA7b,EAAAC,SAEArO,IAAA6K,IACAxT,KAAA4W,OAAAvP,EAAA,IAAAirB,GAAA9e,EAAAnM,EAAAP,EAAAO,EAAAL,GAAA,IAAAsrB,GAAA9e,GAEA,CACA,QAAA1O,GACA,MAAAA,EAAA,SAAAouB,GACA,OAAAA,EAAAA,EAAApuB,WAAA,EACA,EACA,OAAAA,EAAA9E,KAAAizB,WACAnuB,EAAA9E,KAAA4W,QACA9R,EAAA9E,KAAA8W,MACA,CACA,MAAAqc,CAAAjV,GACAA,EAAAkV,WAAApzB,KACAke,EAAAmV,kBACA,CACA,QAAAd,GACA,IAAAzoB,EAAAwnB,GAAAO,OAUA,OATA7xB,KAAAizB,YACAnpB,EAAAA,EAAAgK,MAAA9T,KAAAizB,UAAAV,aAEAvyB,KAAA4W,SACA9M,EAAAA,EAAAgK,MAAA9T,KAAA4W,OAAA2b,aAEAvyB,KAAA8W,QACAhN,EAAAA,EAAAgK,MAAA9T,KAAA8W,MAAAyb,aAEAzoB,CACA,CACA,MAAA0oB,GACA,MAAA5b,EAAA5W,KAAA4W,OAAA5W,KAAA4W,OAAA4b,cAAA7pB,EAAA2qB,EAAA1c,EAAAA,EAAA2b,WAAAjB,GAAAO,OAAA/a,EAAA9W,KAAA8W,MAAA9W,KAAA8W,MAAA0b,cAAA7pB,EAAA4qB,EAAAzc,EAAAA,EAAAyb,WAAAjB,GAAAO,OACA,IAAA2B,EAAA,IAAA/f,IAAAzT,KAAAizB,UAAAnsB,GAAA9G,KAAAizB,UAAAjsB,GACAwsB,EAAAF,EAAAxf,MAAAyf,GAAA9nB,MAAA+nB,GACA,MAAAP,EAAA,IAAAJ,GAAAW,EAAA1sB,EAAA0sB,EAAAxsB,GACAksB,EAAA,IAAAF,GAIA,OAHAE,EAAAD,UAAAA,EACAC,EAAAtc,OAAAA,EACAsc,EAAApc,MAAAA,EACAoc,CACA,EAGA,SAAAO,GAAA/oB,EAAAgpB,GACA,MAAAC,EAAA3zB,KAAA0K,QACA,IACA3G,EAAA6vB,EADAC,GAAA,EAEA,IAAA,IAAA/tB,EAAA,EAAAA,EAAA4tB,EAAApuB,OAAAQ,IACA8tB,EAAAF,EAAA5tB,GACA/B,EAAA2G,EAAAkpB,GACA7uB,EAAAhB,IAAA4vB,EAAAC,KAAA7vB,IACA4vB,EAAAC,GAAA7vB,EACA8vB,GAAA,GAGA,OAAAA,CACA,CAEA,MAAAC,GACA,WAAArpB,CAAAC,GACA1K,KAAA0K,QAAAmP,GAAA,CAAA,EAAA7Z,KAAA0K,QAAAA,GACA1K,KAAA8R,GAAA9R,KAAA0K,QAAAoH,GACA9R,KAAA+zB,YAAArf,GAAAgD,QACA1X,KAAAozB,WAAA,IAAAJ,EACA,CACA,OAAAtD,CAAA3rB,GACA,OAAA/D,KAAAg0B,mBAAAtE,QAAA3rB,EACA,CACA,MAAAkwB,CAAAvpB,GACAA,GAAAA,EAAAoH,KACA9R,KAAA8R,GAAApH,EAAAoH,GAEA,CACA,QAAA3I,CAAArC,EAAAE,GACA,MAAA0D,EAAA1K,KAAA0K,QACA,IAAAvG,EAAA2C,GACA,OAAA,IAAA2M,GAAA/I,EAAA5D,EAAA4D,EAAA1D,GAEA7C,EAAA6C,IACA0D,EAAA5D,EAAAA,EACA4D,EAAA1D,EAAAA,GAEAF,aAAA2M,KACA/I,EAAA5D,EAAAA,EAAAA,EACA4D,EAAA1D,EAAAF,EAAAE,GAEAhH,KAAAozB,WAAAH,UAAA,IAAAJ,GAAAnoB,EAAA5D,EAAA4D,EAAA1D,GACAhH,KAAAqzB,kBACA,CACA,MAAAzc,CAAApD,EAAAnM,GAKA,OAJAlD,EAAAqP,KACAxT,KAAAozB,WAAAxc,OAAA,IAAA0b,GAAA9e,EAAAnM,EAAAP,EAAAO,EAAAL,GACAhH,KAAAqzB,oBAEArzB,KAAAozB,WAAAxc,QAAA0b,GAAAK,IACA,CACA,gBAAAqB,GACA,OAAAh0B,KAAAk0B,cACA,CACA,gBAAAb,GACA,MAAAc,EAAAn0B,KAAAozB,WAAAb,WACAvyB,KAAAg0B,mBAAAd,UAAA,IAAAjzB,EAAAm0B,EAAAD,EAAA3qB,EAAA2qB,EAAA1qB,EAAA0qB,EAAAlnB,EAAAknB,EAAAtnB,EAAAsnB,EAAAnoB,EAAAmoB,EAAA/C,GACA,CACA,MAAAiD,GAAA,CACA,mBAAAC,CAAA5pB,EAAAgpB,GACA,OAAAD,GAAA9uB,KAAA3E,KAAA0K,EAAAgpB,EACA,CACA,QAAAa,CAAA5H,GACA,IAAAtW,EACA,IAAArW,KAAAw0B,WAAA7H,EAAA,CACA,MAAA8H,EAAAz0B,KAAA00B,gBAAA,IAAAz0B,EAAA00B,EAAA,CAAA,EAAA,GAAA,CAAA,EAAA,IACAC,EAAAH,EAAAze,UACAK,EAAA,IAAA3B,GAAAkgB,EAAA9tB,EAAA8tB,EAAA5tB,EAAAytB,EAAAxf,QAAAwf,EAAAzf,UACAhV,KAAA+zB,YAAA1d,EACArW,KAAA60B,aAAAxe,EAAApB,MACAjV,KAAA80B,cAAAze,EAAArB,OACAhV,KAAAw0B,WAAA,CACA,MAEAne,EAAArW,KAAA+zB,YAEA,OAAA1d,CACA,CACA,YAAAqe,GACA,OAAA10B,KAAAk0B,eAAAa,SACA,EAGA,SAAAC,GAAAtqB,GACA,MAAA,CACA5D,EAAA4D,EAAA5D,GAAA,EACAE,EAAA0D,EAAA1D,GAAA,EACAiO,MAAAvK,EAAAuK,OAAA,EACAD,OAAAtK,EAAAsK,QAAA,EAEA,CACA,SAAAigB,GAAAvqB,GACA,GAAAA,EAAA,CACA,IAAAwqB,EAAAxqB,EASA,OARA9F,EAAAswB,KACAA,EAAA,CACA5K,MAAA4K,IAGAA,EAAA5K,QACA4K,EAAA5K,MAAA6K,GAAAD,EAAA5K,QAEA4K,CACA,CACA,CACA,SAAAC,GAAApxB,GACA,IAAAumB,EAOA,OALAA,EADAvmB,IAAAxD,EACA,IAAAN,EAAAm1B,EAAArxB,GAAAsxB,QAGAtxB,EAEAumB,CACA,CAOA,SAAAgL,GAAAxuB,EAAAE,GACA,OAAA,IAAA/G,EAAAs1B,EAAA,IAAAt1B,EAAAyT,EAAA5M,EAAAE,GACA,CACA,SAAAwuB,GAAAnf,GACA,GAAAA,EACA,OAAA,IAAApW,EAAA00B,EAAA,CAAAte,EAAAvP,EAAAuP,EAAArP,GAAA,CAAAqP,EAAApB,MAAAoB,EAAArB,QAEA,CAOA,MAAAygB,GAAA,CACAC,OAAA,CACApL,MAAA,OACArV,MAAA,GAEA0U,KAAA,CACAW,MAAA/pB,IAGA,MAAAo1B,WAAA7B,GACA,WAAArpB,CAAAC,GAEAwH,MADAxH,EAAAmP,GAAA,CAAA,EAAA4b,GAAA/qB,KAEAA,EAAA1K,KAAA0K,SACAif,KAAAsL,GAAAvqB,EAAAif,MACAjf,EAAAgrB,OAAAT,GAAAvqB,EAAAgrB,OACA,CACA,IAAA/L,CAAAW,EAAAsL,GACA51B,KAAA61B,MAAA,CACAvL,MAAA6K,GAAA7K,GACAsL,QAAAA,GAEA,CACA,MAAAF,CAAApL,EAAArV,EAAA2gB,GACA51B,KAAA81B,QAAA,CACAxL,MAAA6K,GAAA7K,GACArV,MAAAA,EACA2gB,QAAAA,GAEA,CACA,MAAA3B,CAAAvpB,GACA,GAAAA,EAAA,CACA,MAAAgrB,EAAAhrB,EAAAgrB,OACA/L,EAAAjf,EAAAif,KACA+L,GACA11B,KAAA81B,QAAAb,GAAAS,IAEA/L,GACA3pB,KAAA61B,MAAAZ,GAAAtL,IAEAzX,MAAA+hB,OAAAvpB,EACA,CACA,CACA,MAAA2pB,CAAA0B,GACA,MAAA7B,EAAAl0B,KAAAk0B,eACAxpB,EAAA1K,KAAA0K,QACAsrB,EAAAtrB,EAAAsrB,MACA,GAAAA,GAAAA,EAAArM,KAAA,CACA,MAAAA,EAAAoM,EAAAd,GAAAe,EAAArM,MAAAjf,EAAAif,KACAuK,EAAAvK,KAAAA,EAAAW,MAAAX,EAAAiM,QACA,CACA,CACA,OAAAE,CAAAG,GACA,MAAAvrB,EAAA1K,KAAA0K,QACAmP,GAAAnP,EAAA,CACAgrB,OAAAO,IAGA,IAAAP,EAAA,MADAO,EAAAvrB,EAAAgrB,QAEAzgB,MAAA,IACAygB,EAAA,CACApL,MAAA2L,EAAA3L,MACArV,MAAAghB,EAAAhhB,MACA2gB,QAAAK,EAAAL,QACAM,SAAAD,EAAAC,WAGAl2B,KAAAk0B,eAAAxpB,QAAAoG,IAAA,SAAA4kB,EACA,CACA,KAAAG,CAAAM,GACA,MAAAzrB,EAAA1K,KAAA0K,QACAmP,GAAAnP,EAAA,CACAif,KAAAwM,GAAA,CAAA,IAEA,MAAAxM,EAAAjf,EAAAif,KACA,GAAAA,EAAAyM,SAAA,CACA,MAAAA,EAAAzM,EAAAyM,SACAC,EAAA,WAAAD,EAAA7oB,KAAAtN,EAAA6F,EAAA7F,EAAAq2B,EACAt2B,KAAAk0B,eAAAvK,KAAA,IAAA0M,EAAAD,GACA,MAEAp2B,KAAAk0B,eAAAvK,KAAAA,EAAAW,MAAAX,EAAAiM,QAEA,EAGA,MAAAW,GAAA,CACAb,OAAA,CACApL,MAAA/pB,EACA0U,MAAA,GAEA0U,KAAA,CACAW,MAAA,UAGA,MAAAkM,WAAAb,GACA,WAAAlrB,CAAAC,GAEAwH,MADAxH,EAAAmP,GAAA,CAAA,EAAA0c,GAAA7rB,IAEA,MAAA+rB,EAAAz2B,KAAA0K,QAAA+rB,QAAA,CAAA,EACAz2B,KAAAy2B,OAAA,IAAAx2B,EAAAyT,EAAA+iB,EAAA3vB,EAAA2vB,EAAAzvB,GACAhH,KAAA02B,eACA,CACA,aAAAA,GAAA,CACA,gBAAAC,CAAAthB,EAAAuhB,GACA,MAAA1D,EAAA0D,EAAA1D,YAIA,OAHA7d,GAAA6d,IACA7d,EAAAA,EAAAwhB,cAAA3D,IAEA7d,CACA,CACA,MAAA4e,CAAAvpB,GACAA,IACAA,EAAAvB,WACAnJ,KAAA0K,QAAAvB,SAAAuB,EAAAvB,UAEA+I,MAAA+hB,OAAAvpB,GAEA,EAGA,MAAAosB,GAAA,CACAF,KAAA,8BACAH,OAAA,CACA3vB,EAAA,GACAE,EAAA,IAGA,MAAA+vB,WAAAP,GACA,WAAA/rB,CAAAC,GAEAwH,MADAxH,EAAAmP,GAAA,CAAA,EAAAid,GAAApsB,GAEA,CACA,aAAAgsB,GACA,MAAAhsB,EAAA1K,KAAA0K,QACA1K,KAAAk0B,eAAAj0B,EAAAwJ,EAAAyL,MAAAxK,EAAAksB,KAAA,CACAjN,KAAAjf,EAAAif,KACA+L,OAAAhrB,EAAAgrB,QAEA,CACA,cAAAsB,CAAAJ,GACA,MAAAjtB,EAAA3J,KAAAi3B,YAAAL,GACAjwB,EAAAgD,EAAAhD,MACAC,EAAA+C,EAAA/C,IACAswB,EAAAj3B,EAAAmkB,IAIA,GAHAzd,GACAuwB,EAAAtgB,OAtKA,SAAAxD,EAAAC,GACA,MAAA8jB,EAAA9jB,EAAAvM,EAAAsM,EAAAtM,EACAswB,EAAA/jB,EAAArM,EAAAoM,EAAApM,EAEA,OADA/G,EAAAyM,EAAA1L,KAAA8L,MAAAsqB,EAAAD,GAEA,CAiKAE,CAAA1wB,EAAAC,GAAAA,GAEAA,EAAA,CACA,MAAA6vB,EAAAz2B,KAAAy2B,OACAxD,EAAArsB,EAAA2K,QAAA0hB,WAAAwD,EAAA3vB,GAAA2vB,EAAAzvB,GACAkwB,EAAAjE,UAAAA,EAAAnsB,EAAAmsB,EAAAjsB,EACA,CACAhH,KAAAk0B,eAAAhB,UAAAgE,EACA,CACA,WAAAD,CAAAL,GACA,MAAAlsB,EAAA1K,KAAA0K,QACAkmB,EAAAgG,EAAAhG,SACA,IAAAgE,EAAA0C,EAAAC,EACA,GAAA7sB,EAAAvB,WAAA3I,GAEA,GADA+2B,EAAA3G,EAAA,GACA2G,EAAA,CACAD,EAAAC,EAAAd,SACA7B,EAAA2C,EAAAC,aACA,MAAAC,EAAA7G,EAAA,IACAgE,GAAA6C,IACA7C,EAAA6C,EAAAhB,SAEA,OAIA,GADAc,EAAA3G,EAAAA,EAAAtrB,OAAA,GACAiyB,EAAA,CACAD,EAAAC,EAAAd,SACA7B,EAAA2C,EAAAG,YACA,MAAAC,EAAA/G,EAAAA,EAAAtrB,OAAA,IACAsvB,GAAA+C,IACA/C,EAAA+C,EAAAlB,SAEA,CAEA,GAAAa,EACA,MAAA,CACA3wB,MAAA3G,KAAA22B,iBAAA/B,EAAAgC,GACAhwB,IAAA5G,KAAA22B,iBAAAW,EAAAV,GAGA,EAGA,IAAAgB,GAAA,MACA,WAAAntB,CAAAvB,EAAAwB,GACA1K,KAAA63B,WAAA,CAAA/wB,EAAAE,KACA,MAAA8wB,EAAA93B,KAAA+3B,SAMA,OALA5zB,EAAA2C,IAAA3C,EAAA6C,KACA8wB,EAAAhxB,EAAAA,EACAgxB,EAAA9wB,EAAAA,EACAhH,KAAAg4B,QAAA/E,UAAA,CAAAnsB,EAAAA,EAAAE,EAAAA,KAEA,CACAF,EAAAgxB,EAAAhxB,EACAE,EAAA8wB,EAAA9wB,EACA,EAEA0D,EAAAA,GAAA,CAAA,EACA1K,KAAAkJ,QAAAA,EACAlJ,KAAAg4B,QAAA/3B,EAAA8J,EAAA0oB,OAAAvpB,EAAAwB,GACAtG,EAAApE,KAAAg4B,QAAA/E,aACAjzB,KAAAizB,UAAAjzB,KAAA63B,YAEA73B,KAAAk0B,eAAA,IAAAj0B,EAAAg4B,EACAj4B,KAAA+3B,SAAA,IAAArjB,GAAA,EAAA,EAAAhK,EAAAuK,MAAAvK,EAAAsK,QACAhV,KAAA4F,KAAA5F,KAAA+3B,SACA,CACA,MAAA9b,GACA,MAAAwY,EAAAz0B,KAAAk0B,eAAAgE,cACA,OAAA,IAAAxjB,GAAA,EAAA,EAAA+f,EAAAxf,QAAAwf,EAAAzf,SACA,CACA,IAAApP,CAAAA,GACA,MAAAkyB,EAAA93B,KAAA+3B,SAMA,OALA5zB,EAAAyB,KACAkyB,EAAA7iB,MAAArP,EAAAqP,MACA6iB,EAAA9iB,OAAApP,EAAAoP,OACAhV,KAAAg4B,QAAAG,QAAAvyB,IAEA,CACAqP,MAAA6iB,EAAA7iB,MACAD,OAAA8iB,EAAA9iB,OAEA,CACA,IAAAojB,GACAp4B,KAAAg4B,QAAAI,KAAAp4B,KAAAk0B,eACA,CACA,MAAAmE,CAAAna,GAEA,OADAle,KAAAk0B,eAAAmE,OAAAna,EAAA8V,oBACAh0B,IACA,CACA,MAAA4H,CAAAsW,GACAle,KAAAk0B,eAAAtsB,OAAAsW,EAAA8V,mBACA,CACA,YAAAsE,GAAA,CACA,KAAAhvB,GACAtJ,KAAAk0B,eAAA5qB,OACA,CACA,OAAAuB,CAAA0tB,GACAv4B,KAAAg4B,QAAAntB,UACA0tB,KA5PA,SAAArvB,GACA,KAAAA,EAAAsvB,YACAtvB,EAAAuvB,YAAAvvB,EAAAsvB,WAEA,CAyPAE,CAAA14B,KAAAkJ,SACAlJ,KAAAkJ,QAAAtB,SAEA,GAGA,MAAA+wB,GAAA,CACAC,UAAA,WACA,MAAAluB,EAAA1K,KAAA0K,QACAmuB,EAAA74B,KAAA60B,aACAiE,EAAA94B,KAAA80B,cACA,IAAA/d,EAAArM,EAAAuK,MAAA4jB,EACA7hB,EAAAtM,EAAAsK,OAAA8jB,EACA/zB,EAAAgS,KACAA,EAAA,GAEAhS,EAAAiS,KACAA,EAAA,GAEAhX,KAAAozB,WAAAtc,MAAA,IAAA8b,GAAA7b,EAAAC,EACA,EACA+hB,cAAA,WACA,MAAAruB,EAAA1K,KAAA0K,QACA5D,EAAA4D,EAAA5D,GAAA,EACAE,EAAA0D,EAAA1D,GAAA,EACAhH,KAAAozB,WAAAH,UAAA,IAAAJ,GAAA/rB,EAAAE,EACA,EACAgyB,UAAA,WACA,MAAAtuB,EAAA1K,KAAA0K,QACA,IAAAwoB,GAAA,GACA,IAAAxoB,EAAAuuB,WAAAh1B,EAAAyG,EAAAuK,QAAAhR,EAAAyG,EAAAsK,WACAhV,KAAAu0B,UAAA,GACAv0B,KAAA44B,YACA1F,GAAA,IAEAjvB,EAAAyG,EAAA5D,IAAA7C,EAAAyG,EAAA1D,MACAhH,KAAA+4B,gBACA7F,GAAA,GAEAA,GACAlzB,KAAAqzB,kBAEA,EACA6F,YAAA,SAAAxuB,GACA,IAAAuF,GAAA,EAaA,OAZA,IAAAjQ,KAAA0K,QAAAuuB,UAAAj5B,KAAAs0B,oBAAA5pB,EAAA,CAAAvK,EAAAC,MACA6P,GAAA,EACAjQ,KAAAu0B,UAAA,GACAv0B,KAAA44B,aAEA54B,KAAAs0B,oBAAA5pB,EAAA,CAAArK,EAAAC,MACA2P,GAAA,EACAjQ,KAAA+4B,iBAEA9oB,GACAjQ,KAAAqzB,mBAEApjB,CACA,GAGA,MAAAkpB,WAAAxD,GACA,WAAAlrB,CAAAC,GACAwH,MAAAxH,GAEA1K,KAAA44B,UAAAD,GAAAC,UAAA9vB,KAAA9I,MACAA,KAAA+4B,cAAAJ,GAAAI,cAAAjwB,KAAA9I,MACAA,KAAAg5B,UAAAL,GAAAK,UAAAlwB,KAAA9I,MACAA,KAAAk5B,YAAAP,GAAAO,YAAApwB,KAAA9I,MACAA,KAAAo5B,cACAp5B,KAAAg5B,WACA,CACA,MAAA/E,CAAAvpB,GACA,GAAAA,EAAA,CACA,MAAA2uB,EAAAr5B,KAAA0K,QACAA,EAAArD,SACAwS,GAAAwf,EAAA,CACAhyB,OAAAqD,EAAArD,SAEArH,KAAAsY,QAAA7W,KAAA43B,EAAAhyB,OAAAP,EAAAuyB,EAAAhyB,OAAAL,IAEAhH,KAAAs0B,oBAAA5pB,EAAA,CAAA,YACA1K,KAAAs5B,QAAAC,UAAAF,EAAA3P,QAEA1pB,KAAAk5B,YAAAxuB,GACAwH,MAAA+hB,OAAAtvB,KAAA3E,KAAA0K,EACA,CACA,CACA,WAAA0uB,GACA,MAAA1uB,EAAA1K,KAAA0K,QACA,IAAAuK,EAAAvK,EAAAuK,MACAD,EAAAtK,EAAAsK,OACA0U,EAAAhf,EAAAgf,OACAvlB,EAAAulB,KACAvlB,EAAA8Q,KACAA,EAAAD,GAEA7Q,EAAA6Q,KACAA,EAAAC,GAEAvK,EAAAgf,OAAAA,EAAA1oB,KAAAqO,IAAA4F,EAAAD,GAAA,GAEA,MAAA3N,EAAAqD,EAAArD,QAAA,CAAAP,EAAA4iB,EAAA1iB,EAAA0iB,GACA1pB,KAAAsY,QAAA,IAAArY,EAAAyT,EAAArM,EAAAP,EAAAO,EAAAL,GACAhH,KAAAs5B,QAAA,IAAAr5B,EAAA8oB,EAAA/oB,KAAAsY,QAAAoR,GACA1pB,KAAAk0B,eAAA,IAAAj0B,EAAAmxB,EAAApxB,KAAAs5B,QAAA,CACA5D,OAAAhrB,EAAAgrB,SAEA11B,KAAA61B,OACA,EAGA,MAAA2D,GAAA,CACA9P,OAAA,EACA+M,OAAA,CACA3vB,EAAA,EACAE,EAAA,IAGA,MAAAyyB,WAAAjD,GACA,WAAA/rB,CAAAC,GAEAwH,MADAxH,EAAAmP,GAAA,CAAA,EAAA2f,GAAA9uB,GAEA,CACA,aAAAgsB,GACA,MAAAhsB,EAAA1K,KAAA0K,QACA1K,KAAAk0B,eAAA,IAAAj0B,EAAAmxB,EAAA,IAAAnxB,EAAA8oB,EAAA/oB,KAAAy2B,OAAA/rB,EAAAgf,QAAA,CACAC,KAAAjf,EAAAif,KACA+L,OAAAhrB,EAAAgrB,QAEA,CACA,cAAAsB,CAAAJ,GACA,MACAztB,EADAnJ,KAAA0K,QACAvB,SACAynB,EAAAgG,EAAAhG,SACA,IAAA2G,EACAliB,EAEAkiB,EADApuB,IAAA3I,EACAowB,EAAA,GAGAA,EAAAA,EAAAtrB,OAAA,GAEAiyB,IACAliB,EAAArV,KAAA22B,iBAAAY,EAAAd,SAAAG,GACA52B,KAAAk0B,eAAAhB,UAAAjzB,EAAAmkB,IAAA6O,UAAA5d,EAAAvO,EAAAuO,EAAArO,IAEA,EAGA,MAAA0yB,WAAA5F,GACA,WAAArpB,CAAAC,GAEAwH,MADAxH,EAAAmP,GAAA,CAAAof,UAAA,GAAAvuB,IAEA1K,KAAAkf,SAAA,GACAlf,KAAA25B,iBAAA,EAEA35B,KAAA44B,UAAAD,GAAAC,UAAA9vB,KAAA9I,MACAA,KAAA+4B,cAAAJ,GAAAI,cAAAjwB,KAAA9I,MACAA,KAAAg5B,UAAAL,GAAAK,UAAAlwB,KAAA9I,MACAA,KAAAk5B,YAAAP,GAAAO,YAAApwB,KAAA9I,MACAA,KAAAk0B,eAAA,IAAAj0B,EAAAg4B,EACAj4B,KAAAg5B,WACA,CACA,MAAAX,CAAAna,GACAle,KAAAk0B,eAAAmE,OAAAna,EAAA8V,oBACAh0B,KAAAkf,SAAAtV,KAAAsU,GACAle,KAAA25B,iBAAA,CACA,CAEA,MAAA/xB,CAAAsW,GACAle,KAAA45B,QAAA1b,KACAle,KAAA25B,iBAAA,EAEA,CACA,OAAAC,CAAA1b,GACA,MAAAuE,EAAAziB,KAAAkf,SAAAnX,QAAAmW,GACA,GAAAuE,GAAA,EAGA,OAFAziB,KAAAk0B,eAAA2F,SAAApX,GACAziB,KAAAkf,SAAAlX,OAAAya,EAAA,IACA,CAEA,CACA,KAAAnZ,GACAtJ,KAAAk0B,eAAA5qB,QACAtJ,KAAAkf,SAAA,GACAlf,KAAA25B,iBAAA,CACA,CACA,OAAAG,CAAAC,GACA,IAAA7b,EACA,IAAA,IAAApY,EAAA,EAAAA,EAAAi0B,EAAAz0B,OAAAQ,IACAoY,EAAA6b,EAAAj0B,GACA9F,KAAA45B,QAAA1b,IACAle,KAAAq4B,OAAAna,EAGA,CAEA,MAAA8b,CAAAD,GACA/5B,KAAAi6B,iBAAAF,EAAA,EACA,CACA,OAAAG,CAAAH,EAAA/T,GACAhmB,KAAAi6B,iBAAAF,EAAA/T,EACA,CACA,gBAAAiU,CAAAF,EAAA/T,GACA,MAAAmU,EAAAn6B,KAAAk0B,eACAkG,EAAAD,EAAAjb,SAAA/S,MAAA,GACA+S,EAAAlf,KAAAkf,SACAmb,EAAAt1B,EAAAihB,GACA,IAAAlgB,EAAA2c,EAAAyX,EAAAhG,EAAAhW,EACA,IAAApY,EAAA,EAAAA,EAAAi0B,EAAAz0B,OAAAQ,IACAoY,EAAA6b,EAAAj0B,GACAouB,EAAAhW,EAAA8V,mBACAvR,EAAAvD,EAAAnX,QAAAmW,GACAuE,GAAA,IACA2X,EAAApyB,OAAAya,EAAA,GACAvD,EAAAlX,OAAAya,EAAA,GACAyX,EAAAG,EAAArU,EAAAA,EAAAlgB,GACAs0B,EAAApyB,OAAAkyB,EAAA,EAAAhG,GACAhV,EAAAlX,OAAAkyB,EAAA,EAAAhc,IAGAic,EAAA7wB,QACA6wB,EAAA9B,UAAA+B,EACA,CACA,MAAAnG,CAAAvpB,GACAA,IACA1K,KAAA25B,iBACA35B,KAAA25B,iBAAA,EACA35B,KAAAk5B,YAAAxuB,IACA1K,KAAAg5B,aAIAh5B,KAAAk5B,YAAAxuB,GAEAwH,MAAA+hB,OAAAvpB,GAEA,CACA,YAAAgqB,GACA,MAAAxV,EAAAlf,KAAAkf,SACA,IAAAob,EACApc,EAAAqc,EACA,IAAA,IAAAz0B,EAAA,EAAAA,EAAAoZ,EAAA5Z,OAAAQ,IACAoY,EAAAgB,EAAApZ,GACAoY,EAAAwR,YAAA,IAAAxR,EAAAsc,iBACAD,EAAArc,EAAA8V,mBAAAkE,YAAA,MACAqC,IAEAD,EADAA,EACAr6B,EAAA00B,EAAA5f,MAAAulB,EAAAC,GAGAA,IAKA,OAAAD,CACA,EAGA,MAAAG,WAAA3G,GACA,WAAArpB,CAAAC,GACAwH,MAAAxH,GACA1K,KAAA06B,YACA,CACA,MAAAzG,CAAAvpB,GACAA,IACAA,EAAAjF,QACAzF,KAAAk0B,eAAAyG,IAAAjwB,EAAAjF,QAEAzF,KAAAs0B,oBAAA5pB,EAAA,CAAAvK,EAAAC,EAAAC,EAAAC,KACAN,KAAAk0B,eAAA7d,KAAArW,KAAA46B,SAEA1oB,MAAA+hB,OAAAvpB,GAEA,CACA,UAAAgwB,GACA,MAAAhwB,EAAA1K,KAAA0K,QACA2L,EAAArW,KAAA46B,QACA56B,KAAAk0B,eAAA,IAAAj0B,EAAA46B,EAAAnwB,EAAAjF,OAAA4Q,EACA,CACA,KAAAukB,GACA,MAAAE,EAAA9F,GAAAh1B,KAAA0K,SACAmF,EAAA,IAAA5P,EAAAyT,EAAAonB,EAAAh0B,EAAAg0B,EAAA9zB,GACApB,EAAA,IAAA3F,EAAAiU,EAAA4mB,EAAA7lB,MAAA6lB,EAAA9lB,QACA,OAAA,IAAA/U,EAAA00B,EAAA9kB,EAAAjK,EACA,EA6BA,MAAAm1B,GAAA,CACAC,SAAA,SAAA7xB,GACA,IAAAytB,EAAA52B,KAAAk0B,eASA,GARA0C,aAAA32B,EAAA8O,IAEA6nB,EADAztB,IAAA3I,EACAo2B,EAAAqE,MAAA,GAGArE,EAAAqE,MAAArE,EAAAqE,MAAA31B,OAAA,IAGAsxB,GAAAA,EAAAhG,SAAAtrB,OACA,OAAAsxB,CAEA,EACAsE,wBAAA,SAAAxwB,GACA,MAAAywB,EAAAzwB,EAAAywB,SACAC,EAAA1wB,EAAA0wB,OACAx2B,EAAAu2B,KACAzwB,EAAAywB,SAAA,CACA5tB,KAAA4tB,IAGAv2B,EAAAw2B,KACA1wB,EAAA0wB,OAAA,CACA7tB,KAAA6tB,GAGA,EACAC,cAAA,SAAAlyB,GACA,MAAAmyB,EAAAt7B,KAAAu7B,SAAApyB,GACAmyB,IACAt7B,KAAAg0B,mBAAApsB,OAAA0zB,EAAApH,uBACAl0B,KAAAu7B,SAAApyB,GAEA,EACAqyB,eAAA,WACA,MAAA9wB,EAAA1K,KAAA0K,QACA1K,KAAAk7B,wBAAAxwB,GACA1K,KAAAu7B,SAAA,CAAA,EACAv7B,KAAAu7B,SAAA/6B,GAAAR,KAAAy7B,cAAA/wB,EAAAywB,SAAA36B,GACAR,KAAAu7B,SAAA96B,GAAAT,KAAAy7B,cAAA/wB,EAAA0wB,OAAA36B,EACA,EACAg7B,cAAA,SAAA/wB,EAAAvB,GACA,MAAAoE,GAAA7C,GAAA,CAAA,GAAA6C,KACAqpB,EAAA52B,KAAAg7B,SAAA7xB,GACA,IAAAuyB,EAAAJ,EACA,GAAA1E,EAaA,OATArpB,IAAA7M,EAAAG,aACA66B,EAAAjC,GAEAlsB,IAAA7M,EAAAE,YAAA2M,IAAA7M,EAAAI,SACA46B,EAAA3E,GAGA/2B,KAAAq7B,cAAAlyB,GAEAuyB,GACAJ,EAAA,IAAAI,EAAA7hB,GAAA,CAAA,EAAAnP,EAAA,CACAvB,SAAAA,KAEAmyB,EAAAtE,eAAAJ,GACA52B,KAAAg0B,mBAAAqE,OAAAiD,EAAApH,gBACAoH,QANA,EAZAt7B,KAAAq7B,cAAAlyB,EAoBA,EACAwyB,gBAAA,SAAAxyB,GACA,MAAAmyB,EAAAt7B,KAAAu7B,SAAApyB,GACA,GAAAmyB,EAAA,CACA,MAAA1E,EAAA52B,KAAAg7B,SAAA7xB,GACAytB,EACA0E,EAAAtE,eAAAJ,GAGA52B,KAAAq7B,cAAAlyB,EAEA,CACA,EACAyyB,QAAA,CACAj1B,MAAA,WACAC,IAAA,UAEAi1B,cAAA,SAAAC,EAAA3yB,EAAAuB,GACA1K,KAAAk7B,wBAAAxwB,GACA,MAAAqxB,EAAA/7B,KAAA0K,QACAsxB,EAAAh8B,KAAA47B,QAAAzyB,GACA8yB,GAAAF,EAAAC,IAAA,CAAA,GAAAzuB,KACA2uB,EAAAxxB,EAAAsxB,GACA,IAAAG,GAAA,EAgBA,OAfAD,GACAH,EAAAC,GAAAniB,GAAA,CAAA,EAAAkiB,EAAAC,GAAAE,GACAA,EAAA3uB,MAAA0uB,IAAAC,EAAA3uB,MACAvN,KAAAq7B,cAAAlyB,GACAnJ,KAAAu7B,SAAApyB,GAAAnJ,KAAAy7B,cAAAM,EAAAC,GAAA7yB,GACAgzB,GAAA,GAEAn8B,KAAAu7B,SAAApyB,IACAnJ,KAAAu7B,SAAApyB,GAAA8qB,OAAAiI,IAGAJ,IAAA97B,KAAAu7B,SAAApyB,IAAA4yB,EAAAC,KACAh8B,KAAAu7B,SAAApyB,GAAAnJ,KAAAy7B,cAAAM,EAAAC,GAAA7yB,GACAgzB,GAAA,GAEAA,CACA,EACAC,eAAA,SAAAN,EAAApxB,IACA1K,KAAA67B,cAAAC,EAAAt7B,EAAAkK,IAAAoxB,GACA97B,KAAA27B,gBAAAn7B,IAEAR,KAAA67B,cAAAC,EAAAr7B,EAAAiK,IAAAoxB,GACA97B,KAAA27B,gBAAAl7B,EAEA,GAgEA,MAAA47B,WAAA1G,GACA,WAAAlrB,CAAAC,GAEAwH,MADAxH,EAAAmP,GAAA,CAAAof,UAAA,GAAAvuB,IAEA1K,KAAA47B,QAAAb,GAAAa,QACA57B,KAAA6X,UAAA,IAAA5X,EAAAg4B,EACAj4B,KAAA44B,UAAAD,GAAAC,UAAA9vB,KAAA9I,MACAA,KAAA+4B,cAAAJ,GAAAI,cAAAjwB,KAAA9I,MACAA,KAAAg5B,UAAAL,GAAAK,UAAAlwB,KAAA9I,MACAA,KAAAk5B,YAAAP,GAAAO,YAAApwB,KAAA9I,MACAA,KAAAg7B,SAAAD,GAAAC,SAAAlyB,KAAA9I,MACAA,KAAAk7B,wBAAAH,GAAAG,wBAAApyB,KAAA9I,MACAA,KAAAq7B,cAAAN,GAAAM,cAAAvyB,KAAA9I,MACAA,KAAAw7B,eAAAT,GAAAS,eAAA1yB,KAAA9I,MACAA,KAAAy7B,cAAAV,GAAAU,cAAA3yB,KAAA9I,MACAA,KAAA27B,gBAAAZ,GAAAY,gBAAA7yB,KAAA9I,MACAA,KAAA67B,cAAAd,GAAAc,cAAA/yB,KAAA9I,MACAA,KAAAo8B,eAAArB,GAAAqB,eAAAtzB,KAAA9I,MACAA,KAAAs8B,kBACAt8B,KAAAg5B,WACA,CACA,gBAAAhF,GACA,OAAAh0B,KAAA6X,SACA,CACA,IAAA8G,CAAA5a,GACA,MAAA2G,EAAA1K,KAAA0K,QACA,IAAA3G,EASA,OAAA2G,EAAAiU,KARAjU,EAAAiU,OAAA5a,IACA2G,EAAAiU,KAAA5a,EACA/D,KAAAu8B,SAAAx4B,GACA/D,KAAAg5B,YACAh5B,KAAAo8B,gBAAA,EAAA,CAAA,GAMA,CACA,MAAAnI,CAAAvpB,GACA,GAAAA,EAAA,CACAwH,MAAA+hB,OAAAvpB,GACA,MAAAqxB,EAAA/7B,KAAA0K,QACAiU,EAAAjU,EAAAiU,KACAxa,EAAAwa,IAAAod,EAAApd,OAAAA,GACAod,EAAApd,KAAAA,EACA3e,KAAAu8B,SAAA5d,GACA3e,KAAAk5B,YAAAxuB,IACA1K,KAAAg5B,YAEAh5B,KAAAo8B,gBAAA,EAAA1xB,KAGA1K,KAAAk5B,YAAAxuB,GACA1K,KAAAo8B,gBAAA,EAAA1xB,GAEA,CACA,CACA,eAAA4xB,GACA,MAAA5xB,EAAA1K,KAAA0K,QACA1K,KAAAk0B,eAAAj0B,EAAAwJ,EAAAyL,MAAAxK,EAAAiU,MAAA,GAAA,CACA+W,OAAAhrB,EAAAgrB,SAEA11B,KAAA61B,QACA71B,KAAA6X,UAAAwgB,OAAAr4B,KAAAk0B,gBACAl0B,KAAAw7B,gBACA,CACA,QAAAe,CAAA5d,GACA,MAAAuV,EAAAl0B,KAAAk0B,eACAsI,EAAAv8B,EAAAwJ,EAAAyL,MAAAyJ,GAAA,IACAsc,EAAAuB,EAAAvB,MAAA9uB,MAAA,GACAqwB,EAAAvB,MAAAwB,SAAA,IACAvI,EAAA+G,MAAAwB,SAAAxB,EACA,EAGA,MAAAyB,WAAA/G,GACA,WAAAlrB,CAAAC,GAEAwH,MADAxH,EAAAmP,GAAA,CAAAlQ,OAAA,IAAAe,IAEA1K,KAAA47B,QAAAb,GAAAa,QACA57B,KAAA6X,UAAA,IAAA5X,EAAAg4B,EACAj4B,KAAAg7B,SAAAD,GAAAC,SAAAlyB,KAAA9I,MACAA,KAAAk7B,wBAAAH,GAAAG,wBAAApyB,KAAA9I,MACAA,KAAAq7B,cAAAN,GAAAM,cAAAvyB,KAAA9I,MACAA,KAAAw7B,eAAAT,GAAAS,eAAA1yB,KAAA9I,MACAA,KAAAy7B,cAAAV,GAAAU,cAAA3yB,KAAA9I,MACAA,KAAA27B,gBAAAZ,GAAAY,gBAAA7yB,KAAA9I,MACAA,KAAA67B,cAAAd,GAAAc,cAAA/yB,KAAA9I,MACAA,KAAAo8B,eAAArB,GAAAqB,eAAAtzB,KAAA9I,MACAA,KAAA28B,YACA38B,KAAAw7B,gBACA,CACA,gBAAAxH,GACA,OAAAh0B,KAAA6X,SACA,CACA,MAAAlO,CAAAA,GACA,MAAAe,EAAA1K,KAAA0K,QACA,IAAAf,EAKA,OAAAe,EAAAf,OAJAe,EAAAf,OAAAA,EACA3J,KAAA48B,aAKA,CACA,MAAA3I,CAAAvpB,GACA,GAAAA,EAAA,CACA,MAAAf,EAAAe,EAAAf,OACAuI,MAAA+hB,OAAAtvB,KAAA3E,KAAA0K,GACAf,GAAA3J,KAAA68B,cAAAlzB,IACA3J,KAAA2J,OAAAA,GACA3J,KAAAo8B,gBAAA,EAAA1xB,IAGA1K,KAAAo8B,gBAAA,EAAA1xB,EAEA,CACA,CACA,SAAAiyB,GACA,MAAAjyB,EAAA1K,KAAA0K,QACA1K,KAAAk0B,eAAA,IAAAj0B,EAAAwJ,EAAA,CACAisB,OAAAhrB,EAAAgrB,SAEA11B,KAAA61B,QACA71B,KAAA6X,UAAAwgB,OAAAr4B,KAAAk0B,gBACAxpB,EAAAf,QACA3J,KAAA48B,aAEA,CACA,aAAAC,CAAAlzB,GACA,MAAAmzB,EAAA98B,KAAA0K,QAAAf,OACA,IAAAozB,EAAAD,EAAAx3B,SAAAqE,EAAArE,OACA,IAAAy3B,EACA,IAAA,IAAAj3B,EAAA,EAAAA,EAAA6D,EAAArE,OAAAQ,IACA,GAAAg3B,EAAAh3B,GAAAgB,IAAA6C,EAAA7D,GAAAgB,GAAAg2B,EAAAh3B,GAAAkB,IAAA2C,EAAA7D,GAAAkB,EAAA,CACA+1B,GAAA,EACA,KACA,CAGA,OAAAA,CACA,CACA,WAAAH,GACA,MAAA1I,EAAAl0B,KAAAk0B,eAEAvqB,EADA3J,KAAA0K,QACAf,OACAinB,EAAA,GACA,IAAAvb,EACA,IAAA,IAAAvP,EAAA,EAAAA,EAAA6D,EAAArE,OAAAQ,IACAuP,EAAA1L,EAAA7D,GACA8qB,EAAAhnB,KAAA0rB,GAAAjgB,EAAAvO,EAAAuO,EAAArO,IAEAktB,EAAAtD,SAAA6L,SAAA7L,EACA,EAGA,MAAAoM,WAAArH,GACA,WAAAlrB,CAAAC,GACAwH,MAAAxH,GACA1K,KAAA28B,YACA38B,KAAAi9B,cACA,CACA,YAAAA,GACA,MAAAvyB,EAAA1K,KAAA0K,QACA5D,EAAA4D,EAAA5D,EACAE,EAAA0D,EAAA1D,GACA7C,EAAA2C,IAAA3C,EAAA6C,KACAhH,KAAAmJ,SAAArC,GAAA,EAAAE,GAAA,EAEA,CACA,MAAAitB,CAAAvpB,GACAA,IACAwH,MAAA+hB,OAAAvpB,GACA1K,KAAAs0B,oBAAA5pB,EAAA,CAAAvK,EAAAC,KACAJ,KAAAk9B,YAEAl9B,KAAAs0B,oBAAA5pB,EAAA,CAAArK,EAAAC,KACAN,KAAAi9B,eAGA,CACA,SAAAN,GACA,MAAAjyB,EAAA1K,KAAA0K,QACA1K,KAAAk0B,eAAA,IAAAj0B,EAAAwJ,EAAA,CACAisB,OAAAhrB,EAAAgrB,OACAyH,QAAA,IAEAn9B,KAAA61B,QACA71B,KAAAk9B,WACA,CACA,SAAAA,GACA,MAAAhJ,EAAAl0B,KAAAk0B,eACA4G,EAAA9F,GAAAh1B,KAAA0K,SACAuK,EAAA6lB,EAAA7lB,MACAD,EAAA8lB,EAAA9lB,OACAkf,EAAAtD,SAAA6L,SAAA,CACAnH,GAAA,EAAA,GACAA,GAAArgB,EAAA,GACAqgB,GAAArgB,EAAAD,GACAsgB,GAAA,EAAAtgB,IAEA,EAGA,MAAAooB,GAAA1yB,IACAA,GAAAA,EAAA4f,QACA5f,EAAAmP,GAAA,CAAA,EAAAnP,EAAA,CACAif,KAAA,CACAW,MAAA5f,EAAA4f,UAIA5f,GAEA2yB,GAAA,CACAC,SAAA,GACAC,WAAA,aACA7H,OAAA,CACAzgB,MAAA,GAEA0U,KAAA,CACAW,MAAA,SAEA2O,UAAA,GAEA,MAAAuE,WAAA7H,GACA,WAAAlrB,CAAAC,GACAA,EAAAmP,GAAA,CAAA,EAAAwjB,GAAA3yB,GAEAwH,MADAxH,EAAA0yB,GAAA1yB,IAEA1K,KAAA44B,UAAAD,GAAAC,UAAA9vB,KAAA9I,MACAA,KAAA+4B,cAAAJ,GAAAI,cAAAjwB,KAAA9I,MACAA,KAAAg5B,UAAAL,GAAAK,UAAAlwB,KAAA9I,MACAA,KAAAk5B,YAAAP,GAAAO,YAAApwB,KAAA9I,MACAA,KAAAy9B,QACAz9B,KAAA09B,YACA19B,KAAAg5B,WACA,CACA,SAAA0E,GACA,MAAAhzB,EAAA1K,KAAA0K,QACA1K,KAAAk0B,eAAA,IAAAj0B,EAAA09B,EAAAx5B,EAAAuG,EAAAkzB,MAAAlzB,EAAAkzB,KAAA,GAAA,IAAA39B,EAAAyT,EAAA,CACAmqB,KAAAnzB,EAAAmzB,OAEA79B,KAAA61B,QACA71B,KAAA81B,SACA,CACA,KAAA2H,GACA,MAAA/yB,EAAA1K,KAAA0K,QACA,GAAAA,EAAA6yB,YAAAp5B,EAAAuG,EAAA4yB,UAAA,CACA,MAAAQ,EAAA,GACApzB,EAAAqzB,WACAD,EAAAl0B,KAAAc,EAAAqzB,WAEArzB,EAAAszB,YACAF,EAAAl0B,KAAAc,EAAAszB,YAEAF,EAAAl0B,KAAAc,EAAA4yB,UAAAv4B,EAAA2F,EAAA4yB,UAAA,KAAA,KACAQ,EAAAl0B,KAAAc,EAAA6yB,YACA7yB,EAAAmzB,KAAAC,EAAAlwB,KAAA,IACA,aAEAlD,EAAAmzB,IAEA,CACA,OAAA9lB,CAAA6lB,GACA,OAAA59B,KAAAk0B,eAAAnc,QAAA6lB,EACA,CACA,MAAA3J,CAAAvpB,GACA,GAAAA,EAAA,CACA,IAAAuzB,GAAA,EACA,MAAAC,EAAAl+B,KAAA0K,QACAA,EAAA0yB,GAAA1yB,GACAwH,MAAA+hB,OAAAvpB,IACAA,EAAA6yB,YAAAp5B,EAAAuG,EAAA4yB,WAAA5yB,EAAAqzB,WAAArzB,EAAAszB,cACAnkB,GAAAqkB,EAAA,CACAX,WAAA7yB,EAAA6yB,WACAD,SAAA5yB,EAAA4yB,SACAS,UAAArzB,EAAAqzB,UACAC,WAAAtzB,EAAAszB,aAEAh+B,KAAAy9B,QACAz9B,KAAAk0B,eAAAxpB,QAAAoG,IAAA,OAAAotB,EAAAL,MACAI,GAAA,GAEAvzB,EAAAkzB,OACA59B,KAAA+X,QAAArN,EAAAkzB,MACAK,GAAA,IAEAj+B,KAAAk5B,YAAAxuB,IAAAuzB,GACAj+B,KAAAg5B,WAEA,CACA,EAQA,MAAAmF,WAAAviB,GACA,WAAAnR,CAAAgT,GAEA,GADAvL,QACA7N,EAAAoZ,GACA,MAAA,IAAA7U,MAAA,6BAEA5I,KAAAyd,QAAAA,CACA,CACA,MAAAiO,CAAAhhB,GACA1K,KAAAud,gBAAA7S,GACA,MACAye,EADA,IAAAwC,GAAA3rB,KAAAyd,SACAmO,QAAAlhB,GACA,GAAAye,EAAAhkB,UACA,OAGA,MAAA4W,EAAAoN,EAAAlH,yBACA,GAAA9c,EAAA4W,GACA,OAEA,IAAA,IAAAjW,EAAA,EAAAA,EAAAiW,EAAAzW,OAAAQ,IAAA,CACA,MAAAwW,EAAAP,EAAAjW,GACA9F,KAAA2qB,YAAArO,EAAA5R,EACA,CACA,MAAAmhB,EAAA7rB,KAAA8b,qBAAAC,GACA,OAAA,IAAAyB,GAAAxd,KAAAyd,QAAAoO,EACA,CAMA,sBAAAuS,GACA,IAAA,IAAAhsB,EAAA,EAAAA,EAAApS,KAAAmpB,MAAA1M,MAAAnX,OAAA8M,IAAA,CACA,MAAA6K,EAAAjd,KAAAmpB,MAAA1M,MAAArK,GACA6K,EAAAohB,OAAA,EACAphB,EAAAqhB,oBAAA,EACArhB,EAAAshB,kBAAA,EACAthB,EAAA2B,WAAA,EACA3B,EAAAuhB,YAAA,EACAvhB,EAAAwhB,YAAA,EACAxhB,EAAAyhB,iBAAA,EACAzhB,EAAA0hB,mBAAA,EACA1hB,EAAA2hB,aAAA,CACA,CACA,CACA,QAAAC,CAAA1V,GACA,MAAA9P,EAAA,GACA,IAAAvT,EAAAsoB,EAAAjR,EAEA,MAAA2hB,EAAA,IAAA9sB,GACA,IACA+sB,EAAA5lB,EAAAhL,EADA6wB,EAAA,EAQA,IANA13B,GAAA6hB,EAAA1M,OAAA,SAAAQ,GACA,IAAAA,EAAAwB,SAAAnZ,SACAw5B,EAAAhuB,IAAAmM,EAAA,GACA5D,EAAAzP,KAAAqT,GAEA,IACA5D,EAAA/T,OAAA,GAEA,IADA6T,EAAAE,EAAA4lB,QACAn5B,EAAA,EAAAA,EAAAqT,EAAAqF,SAAAlZ,OAAAQ,IACAqX,EAAAhE,EAAAqF,SAAA1Y,GACAqI,EAAAgP,EAAAhP,OAEA4wB,EADAD,EAAA/tB,YAAA5C,GACAnN,KAAAoO,IAAA0vB,EAAAluB,IAAAuI,GAAA,EAAA2lB,EAAAluB,IAAAzC,IAGA2wB,EAAAluB,IAAAuI,GAAA,EAEA2lB,EAAAhuB,IAAA3C,EAAA4wB,GACAA,EAAAC,IACAA,EAAAD,GAEA92B,GAAAoR,EAAAlL,IACAkL,EAAAzP,KAAAuE,GAIA,MAAA+wB,EAAAJ,EAAAtsB,OACA0sB,EAAAr1B,MAAA,SAAAgL,EAAAsqB,GACA,MAAAC,EAAAN,EAAAluB,IAAAiE,GACAwqB,EAAAP,EAAAluB,IAAAuuB,GACA,OAAAj4B,GAAAm4B,EAAAD,EACA,IACA,IAAA,IAAAr1B,EAAA,EAAAA,EAAAm1B,EAAA55B,SAAAyE,EAAA,CACA,MAAAkT,EAAAiiB,EAAAn1B,GACA,IAAAu1B,EAAA37B,OAAAD,UACA,GAAA,IAAAuZ,EAAAuB,SAAAlZ,OAAA,CAGA,IAAA8oB,EAAA,EAAAA,EAAAnR,EAAAuB,SAAAlZ,SAAA8oB,EACAjR,EAAAF,EAAAuB,SAAA4P,GACAkR,EAAAt+B,KAAAqO,IAAAiwB,EAAAR,EAAAluB,IAAAuM,EAAAhP,SAEAmxB,EAAA,GACAR,EAAAhuB,IAAAmM,EAAAqiB,EAAA,EANA,CAQA,CAEA,IAAAjB,EACA,IAFAr+B,KAAAu/B,OAAA,GAEAz5B,EAAA,EAAAA,EAAAk5B,EAAA,EAAAl5B,IACAu4B,EAAA,GACAA,EAAAmB,QAAA,CAAA,EACAx/B,KAAAu/B,OAAA31B,KAAAy0B,GAOA,IALAS,EAAAx3B,SAAA,SAAA2V,EAAAwiB,GACAxiB,EAAAohB,MAAAoB,EACAz/B,KAAAu/B,OAAAE,GAAA71B,KAAAqT,EACA,GAAAjd,MAEAouB,EAAA,EAAAA,EAAApuB,KAAAu/B,OAAAj6B,OAAA8oB,IAEA,IADAiQ,EAAAr+B,KAAAu/B,OAAAnR,GACAtoB,EAAA,EAAAA,EAAAu4B,EAAA/4B,OAAAQ,IACAu4B,EAAAv4B,GAAA84B,aAAA94B,CAGA,CAIA,WAAA6kB,CAAAxB,EAAAze,GACA,GAAArG,EAAA8kB,GACA,MAAA,IAAAvgB,MAAA,2DAEA3E,EAAAyG,IACA1K,KAAAud,gBAAA7S,GAEA1K,KAAAmpB,MAAAA,EAEAA,EAAAjH,iBAEA,MAAA6F,EAAAoB,EAAAzC,cAEA1mB,KAAAo+B,yBACAp+B,KAAA6+B,SAAA1V,GACAnpB,KAAA0/B,WACA1/B,KAAA2/B,qBACA3/B,KAAA4/B,aACA5/B,KAAA6/B,eACA7/B,KAAA8/B,oBACA9/B,KAAA+/B,aAEAz4B,GAAAygB,GAAA,SAAA/b,GACAA,EAAArC,QACAqC,EAAArC,OAAAoG,SAEA,GACA,CACA,UAAAiwB,CAAAl2B,EAAAm2B,EAAAC,GACA,MAAA9R,EAAAtkB,EAAAu0B,MACAv4B,EAAAgE,EAAAq2B,WAEA,IAAAx8B,OAAAy8B,UAAAhS,KAAAzqB,OAAAy8B,UAAAt6B,IAAAsoB,EAAA,GAAAtoB,EAAA,EACA,MAAA,IAAA8C,MAAA,iCAEA5I,KAAAqgC,aAAAjS,GAAAtoB,GAAAo6B,CACA,CACA,UAAAI,CAAAx2B,EAAAC,GACA,IAAAw2B,EAAA,EACA,MAAAC,EAAA12B,EAAAq2B,WAAAM,EAAA12B,EAAAo2B,WAAA/R,EAAAtkB,EAAAu0B,MAAAhvB,EAAArO,KAAAqO,IAAAmxB,EAAAC,GAAArxB,EAAApO,KAAAoO,IAAAoxB,EAAAC,GAEA,IAAA,IAAAruB,EAAA/C,EAAA+C,EAAAhD,IAAAgD,EACAmuB,GAAAvgC,KAAAqgC,aAAAjS,GAAAhc,GAEA,OAAAmuB,CACA,CACA,gBAAAG,CAAAC,GACA,MAAAC,EAAA,IAAA5uB,GACA,IAAAjI,EAAAkT,EACA,IAAA,IAAAhQ,EAAA,EAAAA,EAAAjN,KAAAu/B,OAAAj6B,SAAA2H,EAAA,CACA,MAAA4zB,EAAAF,EAAA1zB,GACA,IAAA4zB,EACA,SAEA,IAAA92B,EAAA,EAAAA,EAAA82B,EAAAv7B,OAAAyE,IACAkT,EAAA4jB,EAAA92B,GACA62B,EAAA7vB,YAAAkM,IACAjd,KAAA8gC,UAAA7jB,EAAA2jB,EAAA3zB,GAIA,IAAAJ,EAAAlJ,OAAAo9B,kBACA,IAAAh3B,EAAA,EAAAA,EAAA82B,EAAAv7B,OAAAyE,IAAA,CACAkT,EAAA4jB,EAAA92B,GACA,MAAAi3B,EAAAhhC,KAAAghC,aAAA/jB,GACA+jB,GAAAhhC,KAAAihC,cAAArwB,IAAAowB,KAAA/zB,IACAJ,EAAA7L,KAAAqO,IAAAxC,EAAA+zB,EAAAhwB,IAAAowB,GAAAJ,EAAAhwB,IAAAqM,GAAAjd,KAAAsgC,WAAArjB,EAAA+jB,IAEA,CACA,GAAAn0B,IAAAlJ,OAAAo9B,kBAAA,CACA,MAAAG,EAAA,GACA,IAAAn3B,EAAA,EAAAA,EAAA82B,EAAAv7B,OAAAyE,IAAA,CACAkT,EAAA4jB,EAAA92B,GACA,MAAAgW,EAAA,GACA/V,GAAA+V,EAAA/f,KAAAmhC,QAAAvwB,IAAAqM,IACAjT,GAAA+V,EAAA/f,KAAAohC,UAAAxwB,IAAAqM,IACA,IAAA,IAAAjR,EAAA,EAAAA,EAAA+T,EAAAza,OAAA0G,IAAA,CACA,MAAAq1B,EAAAthB,EAAA/T,GACAhM,KAAAihC,cAAArwB,IAAAywB,GAAAp0B,GACAi0B,EAAAt3B,KAAAg3B,EAAAhwB,IAAAywB,GAAAT,EAAAhwB,IAAAqM,GAEA,CACA,CACAikB,EAAAr3B,OAEAgD,EADA,IAAAq0B,EAAA57B,OACA,EAEA47B,EAAA57B,OAAA,GAAA,EACA47B,EAAAlhC,KAAAshC,OAAAJ,EAAA57B,OAAA,KAGA47B,EAAAlhC,KAAAshC,OAAAJ,EAAA57B,OAAA,GAAA,GAAA47B,EAAAlhC,KAAAshC,OAAAJ,EAAA57B,OAAA,KAAA,CAEA,CACA,IAAAyE,EAAA,EAAAA,EAAA82B,EAAAv7B,OAAAyE,IACAkT,EAAA4jB,EAAA92B,GACA62B,EAAA9vB,IAAAmM,EAAA2jB,EAAAhwB,IAAAqM,GAAApQ,EAEA,CACA,OAAA+zB,CACA,CACA,gBAAAW,CAAAC,GACA,MAAAC,EAAA,IAAAzvB,GACA,IAAAjI,EAAAkT,EACA,IAAA,IAAAhQ,EAAA,EAAAA,EAAAjN,KAAAu/B,OAAAj6B,SAAA2H,EAAA,CACA,MAAA4zB,EAAAW,EAAAv0B,GACA,IAAA4zB,EACA,SAEA,IAAA92B,EAAA,EAAAA,EAAA82B,EAAAv7B,OAAAyE,IACAkT,EAAA4jB,EAAA92B,GACA03B,EAAA1wB,YAAAkM,IACAjd,KAAA0hC,WAAAzkB,EAAAwkB,EAAAx0B,GAIA,IAAAJ,EAAAlJ,OAAAg+B,kBACA,IAAA53B,EAAA,EAAAA,EAAA82B,EAAAv7B,OAAAyE,IAAA,CACAkT,EAAA4jB,EAAA92B,GACA,MAAA63B,EAAA5hC,KAAA4hC,YAAA3kB,GACA2kB,GAAA5hC,KAAA6hC,eAAAjxB,IAAAgxB,KAAA30B,IACAJ,EAAA7L,KAAAoO,IAAAvC,EAAA40B,EAAA7wB,IAAAgxB,GAAAH,EAAA7wB,IAAAqM,GAAAjd,KAAAsgC,WAAAsB,EAAA3kB,IAEA,CACA,GAAApQ,IAAAlJ,OAAAg+B,kBAAA,CACA,MAAAT,EAAA,GACA,IAAAn3B,EAAA,EAAAA,EAAA82B,EAAAv7B,OAAAyE,IAAA,CACAkT,EAAA4jB,EAAA92B,GACA,MAAAgW,EAAA,GACA/V,GAAA+V,EAAA/f,KAAAmhC,QAAAvwB,IAAAqM,IACAjT,GAAA+V,EAAA/f,KAAAohC,UAAAxwB,IAAAqM,IACA,IAAA,IAAAjR,EAAA,EAAAA,EAAA+T,EAAAza,OAAA0G,IAAA,CACA,MAAAq1B,EAAAthB,EAAA/T,GACAhM,KAAA6hC,eAAAjxB,IAAAywB,GAAAp0B,GACAi0B,EAAAt3B,KAAA63B,EAAA7wB,IAAAqM,GAAAwkB,EAAA7wB,IAAAywB,GAEA,CACA,CACAH,EAAAr3B,OAEAgD,EADA,IAAAq0B,EAAA57B,OACA,EAEA47B,EAAA57B,OAAA,GAAA,EACA47B,EAAAlhC,KAAAshC,OAAAJ,EAAA57B,OAAA,KAGA47B,EAAAlhC,KAAAshC,OAAAJ,EAAA57B,OAAA,GAAA,GAAA47B,EAAAlhC,KAAAshC,OAAAJ,EAAA57B,OAAA,KAAA,CAEA,CACA,IAAAyE,EAAA,EAAAA,EAAA82B,EAAAv7B,OAAAyE,IACAkT,EAAA4jB,EAAA92B,GACA03B,EAAA3wB,IAAAmM,EAAAwkB,EAAA7wB,IAAAqM,GAAApQ,EAEA,CACA,OAAA40B,CACA,CACA,YAAAK,GACA,MAAAC,EAAA,CAAAh+B,MAAA,MACAsF,EAAArJ,KAAAgiC,eAAAD,EAAA,GAEA,OADA/hC,KAAAihC,cAAAc,EAAAh+B,MACAsF,CACA,CACA,aAAA44B,GACA,MAAAC,EAAA,CAAAn+B,MAAA,MACAsF,EAAArJ,KAAAgiC,eAAAE,GAAA,GAEA,OADAliC,KAAA6hC,eAAAK,EAAAn+B,MACAsF,CACA,CACA,cAAA24B,CAAAG,EAAAt1B,GACA,IAAAu1B,EAAA,EACA,MAAAC,EAAAF,EAAAp+B,MAAA,IAAAiO,GACA,IAAA,IAAAoc,EAAA,EAAAA,EAAApuB,KAAAu/B,OAAAj6B,SAAA8oB,EAAA,CACAgU,EAAAhU,EACA,MAAAiQ,EAAAr+B,KAAAu/B,OAAAnR,GACA,IAAA,IAAArkB,EAAA,IAAA8C,EAAA,EAAAwxB,EAAA/4B,OAAA,EAAAyE,GAAA,GAAAA,EAAAs0B,EAAA/4B,OAAAyE,GAAA8C,EAAA,CACA,MAAAoQ,EAAAohB,EAAAt0B,GACA,GAAAs4B,EAAAtxB,YAAAkM,GAWAmlB,EAAAC,EAAAzxB,IAAAqM,QATA,GADAolB,EAAAvxB,IAAAmM,EAAAmlB,GACAnlB,EAAA2B,UAAA,CACA,MAAA0jB,EAAAtiC,KAAAuiC,aAAAtlB,GACA,IAAA,IAAA6K,EAAA,EAAAA,EAAAwa,EAAAh9B,OAAAwiB,IAAA,CACA,MAAA0a,EAAAF,EAAAxa,GACAua,EAAAvxB,IAAA0xB,EAAAJ,EACA,CACA,CAKA,CACA,CACA,MAAAK,EAAA,GACA,IAAA,IAAA38B,EAAA,EAAAA,EAAA9F,KAAAu/B,OAAAj6B,OAAAQ,IACA28B,EAAA74B,KAAA,MAQA,OANAy4B,EAAA/6B,SAAA,SAAA2V,EAAAylB,GACA,OAAAD,EAAAC,KACAD,EAAAC,GAAA,IAEAD,EAAAC,GAAA94B,KAAAqT,EACA,IACAwlB,CACA,CACA,iBAAAE,GACA,MAAA,OAAA3iC,KAAA0K,QAAAsP,QAAA9B,eAAA,SAAAlY,KAAA0K,QAAAsP,QAAA9B,eAAA,aAAAlY,KAAA0K,QAAAsP,QAAA9B,aACA,CACA,mBAAA0qB,GACA,MAAA,UAAA5iC,KAAA0K,QAAAsP,QAAA9B,eAAA,SAAAlY,KAAA0K,QAAAsP,QAAA9B,eAAA,eAAAlY,KAAA0K,QAAAsP,QAAA9B,aACA,CACA,mBAAA2qB,GAEA,MAAA,UAAA7iC,KAAA0K,QAAAsP,QAAA9B,eAAA,SAAAlY,KAAA0K,QAAAsP,QAAA9B,aACA,CACA,iBAAA4nB,GACA,IAAAh6B,EAAAsoB,EAAAnR,EAAAohB,EAAAt0B,EAAA6W,EAEA,IAAAwN,EAAA,EAAAA,EAAApuB,KAAAu/B,OAAAj6B,SAAA8oB,EACAiQ,EAAAr+B,KAAAu/B,OAAAnR,GACAiQ,EAAAx0B,KAAA7J,KAAA8iC,sBAAAh6B,KAAA9I,OAGA,IADAA,KAAAqgC,aAAA,GACAjS,EAAA,EAAAA,EAAApuB,KAAAu/B,OAAAj6B,SAAA8oB,EAGA,IAFAiQ,EAAAr+B,KAAAu/B,OAAAnR,GACApuB,KAAAqgC,aAAAjS,GAAA,GACArkB,EAAA,EAAAA,EAAAs0B,EAAA/4B,SAAAyE,EACAkT,EAAAohB,EAAAt0B,GACAkT,EAAAkjB,WAAAp2B,EACA/J,KAAAqgC,aAAAjS,GAAArkB,GAAA/J,KAAA0K,QAAA2P,aACAtQ,EAAAs0B,EAAA/4B,OAAA,IACAtF,KAAA2iC,oBACA3iC,KAAAqgC,aAAAjS,GAAArkB,KAAAkT,EAAAhI,MAAAopB,EAAAt0B,EAAA,GAAAkL,OAAA,EAGAjV,KAAAqgC,aAAAjS,GAAArkB,KAAAkT,EAAAjI,OAAAqpB,EAAAt0B,EAAA,GAAAiL,QAAA,GAgCA,IA3BAhV,KAAAohC,UAAA,IAAApvB,GACAhS,KAAAmhC,QAAA,IAAAnvB,GACA1K,GAAAtH,KAAAmpB,MAAA1M,OAAA,SAAAsmB,GACA/iC,KAAAohC,UAAAtwB,IAAAiyB,EAAA,IACA/iC,KAAAmhC,QAAArwB,IAAAiyB,EAAA,GACA,GAAA/iC,MACAsH,GAAAtH,KAAAmpB,MAAAzM,OAAA,SAAAS,GACA,MAAAtN,EAAAsN,EAAA1X,OACAu9B,EAAA7lB,EAAAhP,OACA,IAAA80B,EAAA,KAAAC,EAAA,KACArzB,EAAAwuB,MAAA2E,EAAA3E,OACA4E,EAAA9lB,EAAA1X,OACAy9B,EAAA/lB,EAAAhP,SAGA+0B,EAAA/lB,EAAA1X,OACAw9B,EAAA9lB,EAAAhP,QAEAnO,KAAAohC,UAAAxwB,IAAAsyB,GAAAt5B,KAAAq5B,GACAjjC,KAAAmhC,QAAAvwB,IAAAqyB,GAAAr5B,KAAAs5B,EACA,GAAAljC,MACAA,KAAAohC,UAAA9uB,cAAA,SAAA/J,GACAA,EAAAsB,KAAA7J,KAAA8iC,sBACA,GAAA9iC,MACAA,KAAAmhC,QAAA7uB,cAAA,SAAA/J,GACAA,EAAAsB,KAAA7J,KAAA8iC,sBACA,GAAA9iC,MACAouB,EAAA,EAAAA,EAAApuB,KAAAu/B,OAAAj6B,OAAA,IAAA8oB,EAEA,IADAiQ,EAAAr+B,KAAAu/B,OAAAnR,GACAxN,EAAA,EAAAA,EAAAyd,EAAA/4B,OAAA,EAAAsb,IAAA,CACA,MAAAuiB,EAAA9E,EAAAzd,GACA,IAAAuiB,EAAAvkB,UACA,SAEA,MAAAwkB,EAAApjC,KAAAohC,UAAAxwB,IAAAuyB,GAAA,GACA,GAAAC,EAAAxkB,UAGA,IAAA7U,EAAA6W,EAAA,EAAA7W,EAAAs0B,EAAA/4B,SAAAyE,EAAA,CAEA,GADAkT,EAAAohB,EAAAt0B,IACAkT,EAAA2B,UACA,SAEA,MAAAykB,EAAArjC,KAAAohC,UAAAxwB,IAAAqM,GAAA,GACA,GAAAomB,EAAAzkB,WAGAwkB,EAAAxE,aAAAyE,EAAAzE,aAAA,CACA,MAAA7wB,EAAAq1B,EAAAxE,aACAwE,EAAAxE,aAAAyE,EAAAzE,aACAyE,EAAAzE,aAAA7wB,EACA,MAAAyyB,EAAA4C,EAAAjD,WACAM,EAAA4C,EAAAlD,WACAngC,KAAAu/B,OAAAnR,EAAA,GAAAoS,GAAA6C,EACArjC,KAAAu/B,OAAAnR,EAAA,GAAAqS,GAAA2C,EACAA,EAAAjD,WAAAM,EACA4C,EAAAlD,WAAAK,CACA,CACA,CACA,CAEA,MAAAG,EAAA3gC,KAAA8hC,eACAN,EAAAxhC,KAAAiiC,gBACArB,EAAA5gC,KAAA0gC,iBAAAC,GACAc,EAAAzhC,KAAAuhC,iBAAAC,GACA16B,EAAA,IAAAkL,GACA1K,GAAAtH,KAAAmpB,MAAA1M,OAAA,SAAAsmB,GACAj8B,EAAAgK,IAAAiyB,GAAAnC,EAAAhwB,IAAAmyB,GAAAtB,EAAA7wB,IAAAmyB,IAAA,EACA,IACA,MAAAO,EAAA,IAAAtxB,GACAuxB,EAAA,IAAAvxB,GACA,IAAAoc,EAAA,EAAAA,EAAApuB,KAAAu/B,OAAAj6B,SAAA8oB,EAAA,CACAiQ,EAAAr+B,KAAAu/B,OAAAnR,GACA,IAAAoV,GAAA,EACA,IAAAz5B,EAAA,EAAAA,EAAAs0B,EAAA/4B,SAAAyE,EACAkT,EAAAohB,EAAAt0B,GACAu5B,EAAAxyB,IAAAmM,EAAA,GACAsmB,EAAAzyB,IAAAmM,GAAA,GACAA,EAAA2B,aACA,IAAA4kB,GAGAA,IAAAz5B,EAAA,IAKAu5B,EAAAxyB,IAAAutB,EAAAmF,GAAA,GACA18B,EAAA8J,IAAAqM,GAAAnW,EAAA8J,IAAAytB,EAAAmF,MAAAxjC,KAAAsgC,WAAAjC,EAAAmF,GAAAvmB,GACAsmB,EAAAzyB,IAAAutB,EAAAmF,IAAA,GAGAD,EAAAzyB,IAAAutB,EAAAmF,IAAA,IAZAA,EAAAz5B,EAkBA,CAEAzC,GADA,CAAA,GAAA,IACA,SAAAuF,GAEA,IAAA,IAAA42B,EADA,IAAA52B,EAAA,EAAA7M,KAAAu/B,OAAAj6B,OAAA,EACAm+B,GAAA,GAAAA,EAAAzjC,KAAAu/B,OAAAj6B,OAAAm+B,GAAA52B,EAAA,CACA,MAAA62B,EAAA1jC,KAAAu/B,OAAAkE,GACA,IAAAE,EAAA3jC,KAAA4jC,kBAAAF,GACAG,EAAA,KACAC,EAAA,KACA,IAAA,IAAAH,EAGA,IAFAE,EAAAH,EAAAC,GACAG,EAAA,GACAh+B,EAAA,EAAAA,EAAA69B,EAAA79B,IACAg+B,EAAAl6B,KAAA85B,EAAA59B,SAIA+9B,EAAA,KACAC,EAAAJ,EAEA,GAAAI,EAAAx+B,OAAA,EAAA,CAEA,IADAtF,KAAA+jC,WAAAj9B,EAAA,KAAA+8B,EAAAh3B,EAAAi3B,GACAh+B,EAAA,EAAAA,EAAAg+B,EAAAx+B,OAAA,IAAAQ,EACA9F,KAAAggC,WAAA8D,EAAAh+B,GAAAg+B,EAAAh+B,EAAA,GAAAgB,EAAA8J,IAAAkzB,EAAAh+B,EAAA,IAAAgB,EAAA8J,IAAAkzB,EAAAh+B,KAEA+9B,GACA7jC,KAAAggC,WAAA8D,EAAAA,EAAAx+B,OAAA,GAAAu+B,EAAA/8B,EAAA8J,IAAAizB,GAAA/8B,EAAA8J,IAAAkzB,EAAAA,EAAAx+B,OAAA,IAEA,CACA,KAAAu+B,GAAA,CACA,MAAAG,EAAAhkC,KAAAikC,gBAAAP,EAAAG,GACA,GAAAG,GAcA,GAAAV,EAAA1yB,IAAAizB,KAAAh3B,EAAA,CACA82B,EAAAE,EAAA1D,WACA,MAAA+D,EAAAF,EAAA7D,WAEA,IADA2D,EAAA,GACAh+B,EAAA69B,EAAA,EAAA79B,EAAAo+B,EAAAp+B,IACAg+B,EAAAl6B,KAAA85B,EAAA59B,IAEAg+B,EAAAx+B,OAAA,GACAtF,KAAA+jC,WAAAj9B,EAAA+8B,EAAAG,EAAAn3B,EAAAi3B,GAEAP,EAAAzyB,IAAA+yB,GAAA,EACA,MAzBA,CAGA,IAFAF,EAAAE,EAAA1D,WACA2D,EAAA,GACAh+B,EAAA69B,EAAA,EAAA79B,EAAA49B,EAAAp+B,OAAAQ,IACAg+B,EAAAl6B,KAAA85B,EAAA59B,IAEA,GAAAg+B,EAAAx+B,OAAA,EAAA,CAEA,IADAtF,KAAA+jC,WAAAj9B,EAAA+8B,EAAA,KAAAh3B,EAAAi3B,GACAh+B,EAAA,EAAAA,EAAAg+B,EAAAx+B,OAAA,IAAAQ,EACA9F,KAAAggC,WAAA8D,EAAAh+B,GAAAg+B,EAAAh+B,EAAA,GAAAgB,EAAA8J,IAAAkzB,EAAAh+B,EAAA,IAAAgB,EAAA8J,IAAAkzB,EAAAh+B,KAEA9F,KAAAggC,WAAA6D,EAAAC,EAAA,GAAAh9B,EAAA8J,IAAAkzB,EAAA,IAAAh9B,EAAA8J,IAAAizB,GACA,CACA,CAaAA,EAAAG,CACA,CACAhkC,KAAAmkC,iBAAAV,EAAA52B,EAAAy2B,EAAAC,EACA,CACA,GAAAvjC,MACA,MAAAokC,EAAApkC,KAAA6iC,sBAAA,EAAA7iC,KAAAu/B,OAAAj6B,OAAA,EASA++B,EAAArkC,KAAA6iC,sBAAA,GAAA,EACA,IAAAhvB,EAAA,EAIA,SAAAywB,EAAAZ,EAAAa,GACA,IAAAvvB,EAAArR,OAAAC,UACA,IAAA,IAAA4gC,EAAA,EAAAA,EAAAd,EAAAp+B,SAAAk/B,EAAA,CACA,MAAAC,EAAAf,EAAAc,GAEAxvB,EADAuvB,EAAA5B,oBACA3hC,KAAAoO,IAAA4F,EAAAyvB,EAAAzvB,QAGAhU,KAAAoO,IAAA4F,EAAAyvB,EAAAxvB,MAEA,CACA,OAAAD,CACA,CACA,IAAAlP,EAAAs+B,EA1BAhyB,EA0BAtM,GA1BAy+B,EA0BAvkC,MAzBA6iC,sBACAzwB,EAAAmyB,EAAAhF,OAAAj6B,OAGA8M,GAAA,EAqBAtM,GAAAu+B,EAAA,CACAhG,EAAAr+B,KAAAu/B,OAAAz5B,GACA,MAAAkP,EAAAsvB,EAAAjG,EAAAr+B,MACA,IAAA+J,EAAA,EAAAA,EAAAs0B,EAAA/4B,SAAAyE,EACAkT,EAAAohB,EAAAt0B,GACA/J,KAAA2iC,qBACA1lB,EAAAnW,EAAAA,EAAA8J,IAAAqM,GACAA,EAAAjW,EAAA6M,EAAAmB,EAAA,IAGAiI,EAAAnW,EAAA+M,EAAAmB,EAAA,EACAiI,EAAAjW,EAAAF,EAAA8J,IAAAqM,IAGApJ,GAAA7T,KAAA0K,QAAAuQ,gBAAAjG,CACA,CAzCA,IAAA5C,EAAAmyB,CA0CA,CACA,gBAAAJ,CAAA/V,EAAAvhB,EAAAy2B,EAAAC,GACA,GAAAnV,EAAAvhB,EAAA,GAAAuhB,EAAAvhB,GAAA7M,KAAAu/B,OAAAj6B,OACA,OAEA,IAAAo/B,EAAA,KAAAC,EAAA,KACA,MAAAtG,EAAAr+B,KAAAu/B,OAAAnR,EAAAvhB,GACA,IAAA,IAAA9C,EAAA,EAAAA,EAAAs0B,EAAA/4B,SAAAyE,EAAA,CACA,MAAA66B,EAAAvG,EAAAt0B,GACA,GAAA66B,EAAAhmB,UAAA,CACA,MAAAimB,EAAA7kC,KAAA8kC,mBAAAF,EAAAxW,GACA,GAAAyW,EAAAjmB,UAAA,CACA,GAAA8lB,EAAA,CACA,IAAA/2B,EAAA41B,EAAA3yB,IAAA+zB,GACA,MAAAI,EAAA/kC,KAAAu/B,OAAAnR,GACAoS,EAAAmE,EAAAxE,WACAM,EAAAoE,EAAA1E,WACA,IAAA,IAAAr6B,EAAA06B,EAAA,EAAA16B,EAAA26B,IAAA36B,EACAi/B,EAAAj/B,GAAA8Y,YACAjR,EAAAA,GAAA41B,EAAA3yB,IAAAm0B,EAAAj/B,KAGA,GAAA6H,EAAA,CACA21B,EAAAxyB,IAAA4zB,EAAA73B,GACA,MAAAm4B,EAAAN,EAAAvE,WACA8E,EAAAL,EAAAzE,WACA,IAAA,IAAArjB,EAAAkoB,EAAA,EAAAloB,EAAAmoB,IAAAnoB,EACAuhB,EAAAvhB,GAAA8B,WACA0kB,EAAAxyB,IAAAutB,EAAAvhB,GAAAjQ,EAGA,CACA,CACA63B,EAAAE,EACAD,EAAAE,CACA,CACA,CACA,CACA,CACA,kBAAAC,CAAA7nB,EAAAmR,GACA,IAAAiT,EAAArhC,KAAAmhC,QAAAvwB,IAAAqM,GAAA,GACA,OAAAokB,EAAAhD,QAAAjQ,EACAiT,GAEAA,EAAArhC,KAAAohC,UAAAxwB,IAAAqM,GAAA,GACAokB,EAAAhD,QAAAjQ,EACAiT,EAEA,KACA,CACA,UAAA0C,CAAAj9B,EAAA+8B,EAAAG,EAAAkB,EAAApB,GAIA,GAHA,IAAAA,EAAAx+B,QACAtF,KAAAmlC,gBAAAr+B,EAAA+8B,EAAAG,EAAAkB,EAAApB,EAAA,IAEAA,EAAAx+B,OAAA,EAAA,CACA,MAAAiO,EAAAuwB,EAAAx+B,OAAA8e,EAAApkB,KAAAshC,OAAA/tB,EAAA,GACAvT,KAAA+jC,WAAAj9B,EAAA+8B,EAAAG,EAAAkB,EAAApB,EAAA33B,MAAA,EAAAiY,IACApkB,KAAA+jC,WAAAj9B,EAAA+8B,EAAAG,EAAAkB,EAAApB,EAAA33B,MAAAiY,IACApkB,KAAAolC,iBAAAt+B,EAAA+8B,EAAAG,EAAAkB,EAAApB,EACA,CACA,CACA,eAAAqB,CAAAr+B,EAAA+8B,EAAAG,EAAAkB,EAAAjoB,GACA,MAAA8C,GAAA,IAAAmlB,EAAAllC,KAAAohC,UAAAxwB,IAAAqM,GAAAjd,KAAAmhC,QAAAvwB,IAAAqM,GACAlT,EAAAgW,EAAAza,OACA,IAAAyE,IACAA,EAAA,GAAA,EACAjD,EAAAgK,IAAAmM,EAAAnW,EAAA8J,IAAAmP,EAAA/f,KAAAshC,OAAAv3B,EAAA,MAGAjD,EAAAgK,IAAAmM,GAAAnW,EAAA8J,IAAAmP,EAAA/f,KAAAshC,OAAAv3B,EAAA,GAAA,IAAAjD,EAAA8J,IAAAmP,EAAA/f,KAAAshC,OAAAv3B,EAAA,MAAA,GAEA85B,GACA/8B,EAAAgK,IAAAmM,EAAAjc,KAAAoO,IAAAtI,EAAA8J,IAAAqM,GAAAnW,EAAA8J,IAAAizB,GAAA7jC,KAAAsgC,WAAAuD,EAAA5mB,KAEA+mB,GACAl9B,EAAAgK,IAAAmM,EAAAjc,KAAAqO,IAAAvI,EAAA8J,IAAAqM,GAAAnW,EAAA8J,IAAAozB,GAAAhkC,KAAAsgC,WAAArjB,EAAA+mB,KAGA,CACA,gBAAAoB,CAAAt+B,EAAA+8B,EAAAG,EAAAkB,EAAApB,GACA,MAAAvwB,EAAAuwB,EAAAx+B,OAAA8e,EAAApkB,KAAAshC,OAAA/tB,EAAA,GAEA8xB,EAAA,GACA,IAAAv/B,EAAAmH,EAAAlD,EAAAgW,EAAAshB,EAAAiE,EACA,IAAAx/B,EAAA,EAAAA,EAAAse,IAAAte,EAAA,CAGA,IAFAmH,EAAA,EACA8S,GAAA,IAAAmlB,EAAAllC,KAAAohC,UAAAxwB,IAAAkzB,EAAAh+B,IAAA9F,KAAAmhC,QAAAvwB,IAAAkzB,EAAAh+B,IACAiE,EAAA,EAAAA,EAAAgW,EAAAza,SAAAyE,EACAs3B,EAAAthB,EAAAhW,GACAjD,EAAA8J,IAAAywB,IAAAv6B,EAAA8J,IAAAkzB,EAAAh+B,IACAmH,KAGAA,IACAo4B,EAAAz7B,KAAA,CAAAwI,EAAAtL,EAAA8J,IAAAywB,GAAArhC,KAAAsgC,WAAAwD,EAAAh+B,GAAAg+B,EAAA1f,EAAA,IAAA1X,EAAA,KAGA24B,EAAAz7B,KAAA,CAAAwI,EAAAtL,EAAA8J,IAAAkzB,EAAAh+B,IAAA9F,KAAAsgC,WAAAwD,EAAAh+B,GAAAg+B,EAAA1f,EAAA,IAAA1X,EAAAO,GACA,CACA42B,GACAwB,EAAAz7B,KAAA,CAAAwI,EAAAtL,EAAA8J,IAAAizB,GAAA7jC,KAAAsgC,WAAAuD,EAAAC,EAAA1f,EAAA,IAAA1X,EAAA/I,OAAAD,YAEA2hC,EAAAx7B,KAAA7J,KAAAulC,4BAAAz8B,KAAA9I,OAEA,MAAAwlC,EAAA,GACA,IAAA1/B,EAAAse,EAAAte,EAAAyN,IAAAzN,EAAA,CAGA,IAFAmH,EAAA,EACA8S,GAAA,IAAAmlB,EAAAllC,KAAAohC,UAAAxwB,IAAAkzB,EAAAh+B,IAAA9F,KAAAmhC,QAAAvwB,IAAAkzB,EAAAh+B,IACAiE,EAAA,EAAAA,EAAAgW,EAAAza,SAAAyE,EACAs3B,EAAAthB,EAAAhW,GACAjD,EAAA8J,IAAAywB,IAAAv6B,EAAA8J,IAAAkzB,EAAAh+B,IACAmH,KAGAA,IACAu4B,EAAA57B,KAAA,CAAAwI,EAAAtL,EAAA8J,IAAAywB,GAAArhC,KAAAsgC,WAAAwD,EAAAh+B,GAAAg+B,EAAA1f,IAAA1X,EAAA,KAGA84B,EAAA57B,KAAA,CAAAwI,EAAAtL,EAAA8J,IAAAkzB,EAAAh+B,IAAA9F,KAAAsgC,WAAAwD,EAAAh+B,GAAAg+B,EAAA1f,IAAA1X,EAAAO,GACA,CACA+2B,GACAwB,EAAA57B,KAAA,CAAAwI,EAAAtL,EAAA8J,IAAAozB,GAAAhkC,KAAAsgC,WAAA0D,EAAAF,EAAA1f,IAAA1X,EAAA/I,OAAAD,YAEA8hC,EAAA37B,KAAA7J,KAAAylC,2BAAA38B,KAAA9I,OACA,IAAA0lC,EAAA,EAAAC,EAAA,EACA,MAAA77B,EAAA9J,KAAAsgC,WAAAwD,EAAA1f,EAAA,GAAA0f,EAAA1f,IACA,KAAAtd,EAAA8J,IAAAkzB,EAAA1f,IAAAtd,EAAA8J,IAAAkzB,EAAA1f,EAAA,IAAAta,GACA,GAAA47B,EAAAC,EAAA,CACA,GAAA,IAAAN,EAAA//B,OAAA,CACAwB,EAAAgK,IAAAgzB,EAAA1f,EAAA,GAAAtd,EAAA8J,IAAAkzB,EAAA1f,IAAAta,GACA,KACA,CAEAw7B,EAAAD,EAAApG,QACAyG,GAAAJ,EAAA54B,EACA5F,EAAAgK,IAAAgzB,EAAA1f,EAAA,GAAAkhB,EAAAlzB,GACAtL,EAAAgK,IAAAgzB,EAAA1f,EAAA,GAAApjB,KAAAoO,IAAAtI,EAAA8J,IAAAkzB,EAAA1f,EAAA,IAAAtd,EAAA8J,IAAAkzB,EAAA1f,IAAAta,GAEA,KACA,CACA,GAAA,IAAA07B,EAAAlgC,OAAA,CACAwB,EAAAgK,IAAAgzB,EAAA1f,GAAAtd,EAAA8J,IAAAkzB,EAAA1f,EAAA,IAAAta,GACA,KACA,CAEAw7B,EAAAE,EAAAvG,QACA0G,GAAAL,EAAA54B,EACA5F,EAAAgK,IAAAgzB,EAAA1f,GAAAkhB,EAAAlzB,GACAtL,EAAAgK,IAAAgzB,EAAA1f,GAAApjB,KAAAqO,IAAAvI,EAAA8J,IAAAkzB,EAAA1f,IAAAtd,EAAA8J,IAAAkzB,EAAA1f,EAAA,IAAAta,GAEA,CAEA,IAAAhE,EAAAse,EAAA,EAAAte,GAAA,EAAAA,IACAgB,EAAAgK,IAAAgzB,EAAAh+B,GAAA9E,KAAAqO,IAAAvI,EAAA8J,IAAAkzB,EAAAh+B,IAAAgB,EAAA8J,IAAAkzB,EAAA1f,EAAA,IAAApkB,KAAAsgC,WAAAwD,EAAAh+B,GAAAg+B,EAAA1f,EAAA,MAEA,IAAAte,EAAAse,EAAA,EAAAte,EAAAyN,EAAAzN,IACAgB,EAAAgK,IAAAgzB,EAAAh+B,GAAA9E,KAAAoO,IAAAtI,EAAA8J,IAAAkzB,EAAAh+B,IAAAgB,EAAA8J,IAAAkzB,EAAA1f,IAAApkB,KAAAsgC,WAAAwD,EAAAh+B,GAAAg+B,EAAA1f,KAEA,CACA,SAAA0c,CAAA7jB,EAAA2jB,EAAAgF,GACA,IAAA73B,EAAApK,OAAAg+B,kBACAr6B,GAAAtH,KAAA6lC,cAAA5oB,IAAA,SAAAvQ,GACA,MAAAk1B,EAAA5hC,KAAA4hC,YAAAl1B,GACAk1B,GAAA5hC,KAAAihC,cAAArwB,IAAAgxB,KAAA5hC,KAAAihC,cAAArwB,IAAAlE,KACAk0B,EAAA7vB,YAAA6wB,IACA5hC,KAAA8gC,UAAAc,EAAAhB,EAAAgF,GAEA73B,EAAA/M,KAAAoO,IAAArB,EAAA6yB,EAAAhwB,IAAAgxB,GAAA5hC,KAAAsgC,WAAAsB,EAAAl1B,IAEA,GAAA1M,MACA+N,IAAApK,OAAAg+B,oBACA5zB,EAAA,GAEAzG,GAAAtH,KAAA6lC,cAAA5oB,IAAA,SAAAvQ,GACAk0B,EAAA9vB,IAAApE,EAAAqB,EACA,GACA,CACA,UAAA2zB,CAAAzkB,EAAAwkB,EAAAqE,GACA,IAAA/3B,EAAApK,OAAAo9B,kBACAz5B,GAAAtH,KAAA6lC,cAAA5oB,IAAA,SAAAvQ,GACA,MAAAs0B,EAAAhhC,KAAAghC,aAAAt0B,GACAs0B,GAAAhhC,KAAA6hC,eAAAjxB,IAAAowB,KAAAhhC,KAAA6hC,eAAAjxB,IAAAlE,KACA+0B,EAAA1wB,YAAAiwB,IACAhhC,KAAA0hC,WAAAV,EAAAS,EAAAqE,GAEA/3B,EAAA/M,KAAAqO,IAAAtB,EAAA0zB,EAAA7wB,IAAAowB,GAAAhhC,KAAAsgC,WAAA5zB,EAAAs0B,IAEA,GAAAhhC,MACA+N,IAAApK,OAAAo9B,oBACAhzB,EAAA,GAEAzG,GAAAtH,KAAA6lC,cAAA5oB,IAAA,SAAAvQ,GACA+0B,EAAA3wB,IAAApE,EAAAqB,EACA,GACA,CACA,WAAA6zB,CAAA3kB,GACA,MAAAohB,EAAAr+B,KAAAu/B,OAAAtiB,EAAAohB,OAAA8B,EAAAljB,EAAAkjB,WACA,OAAA,IAAAA,EAAA,KAAA9B,EAAA8B,EAAA,EACA,CACA,YAAAa,CAAA/jB,GACA,MAAAohB,EAAAr+B,KAAAu/B,OAAAtiB,EAAAohB,OACA8B,EAAAljB,EAAAkjB,WACA,OAAAA,IAAA9B,EAAA/4B,OAAA,EAAA,KAAA+4B,EAAA8B,EAAA,EACA,CACA,aAAA0F,CAAA5oB,GACA,OAAAA,EAAA2B,UAAA5e,KAAAuiC,aAAAtlB,GAAA,CAAAA,EACA,CACA,YAAA4iB,GACA,IAAA/5B,EAAAsoB,EAAAnL,EAAAob,EAAAphB,EAEA,IAAAmR,EAAA,EAAAA,EAAApuB,KAAAu/B,OAAAj6B,OAAA8oB,IAEA,IADAiQ,EAAAr+B,KAAAu/B,OAAAnR,GACAnL,EAAA,EAAAA,EAAAob,EAAA/4B,OAAA2d,IACAhG,EAAAohB,EAAApb,GACAhG,EAAAyhB,iBAAAzhB,EAAAshB,kBACAthB,EAAA0hB,mBAAA1hB,EAAAqhB,oBAMA,IAAA,IAAAyH,EAAA,EAAAA,EADA,EACAA,IAAA,CACA,IAAAjgC,EAAA9F,KAAAu/B,OAAAj6B,OAAA,EAAAQ,GAAA,EAAAA,IACA9F,KAAAgmC,aAAA,EAAAlgC,GAEA,IAAAA,EAAA,EAAAA,EAAA9F,KAAAu/B,OAAAj6B,OAAA,EAAAQ,IACA9F,KAAAgmC,aAAA,EAAAlgC,EAEA,CAEA,IAAAmgC,EAAAtiC,OAAAD,UACA,IAAA0qB,EAAA,EAAAA,EAAApuB,KAAAu/B,OAAAj6B,OAAA8oB,IAEA,IADAiQ,EAAAr+B,KAAAu/B,OAAAnR,GACAnL,EAAA,EAAAA,EAAAob,EAAA/4B,OAAA2d,IACAhG,EAAAohB,EAAApb,GACAgjB,EAAAjlC,KAAAqO,IAAA42B,EAAAhpB,EAAA2hB,cAGA,GAAAqH,EAAA,EACA,IAAA7X,EAAA,EAAAA,EAAApuB,KAAAu/B,OAAAj6B,OAAA8oB,IAEA,IADAiQ,EAAAr+B,KAAAu/B,OAAAnR,GACAnL,EAAA,EAAAA,EAAAob,EAAA/4B,OAAA2d,IACAhG,EAAAohB,EAAApb,GACAhG,EAAA2hB,aAAA3hB,EAAA2hB,aAAAqH,CAIA,CAOA,WAAAD,CAAA/C,EAAA5E,GACA,IAAA6H,EACAC,EAEAA,EADAlD,EACAjjC,KAAAu/B,OAAA2G,EAAA7H,EAAA,GAGAr+B,KAAAu/B,OAAA2G,EAAA7H,EAAA,GAGA,MAAA+H,EAAA,GACA,IAAA,IAAAr8B,EAAA,EAAAA,EAAAo8B,EAAA7gC,OAAAyE,IACAq8B,EAAAx8B,KAAAu8B,EAAAp8B,IAEAq8B,EAAAv8B,MAAA,SAAA6a,EAAAC,GACA,MAAA0hB,GAAA3hB,EAAAga,iBAAAha,EAAAia,oBAAA,EACA2H,GAAA3hB,EAAA+Z,iBAAA/Z,EAAAga,oBAAA,EACA,OAAA39B,KAAAgD,IAAAqiC,EAAAC,GAAA,KACA,EAEAD,EAAAC,EACA,GAEA,CACA,IAEAh/B,GAAA8+B,GAAA,SAAAnpB,GACA,IAAAspB,EAAAtpB,EAAA2hB,aACA,MAAA4H,EAAAxmC,KAAAymC,eAAAxpB,GACAypB,GAAAzpB,EAAAyhB,iBAAAzhB,EAAA0hB,oBAAA,EACA,KAAA39B,KAAAgD,IAAAuiC,EAAAC,GAAA,MAIAxlC,KAAAgD,IAAAuiC,EAAAC,GAAA,OAIA,GAAAD,EAAAC,EAGA,KAAAD,EAAAC,GACAxmC,KAAA2mC,UAAA1pB,EAAAkpB,EAAAO,IAGAH,EAAAtpB,EAAA2hB,kBAMA,KAAA2H,EAAAC,GACAxmC,KAAA4mC,SAAA3pB,EAAAkpB,EAAAO,IAGAH,EAAAtpB,EAAA2hB,YAGA,GAAA5+B,MAGAkmC,EAAA,GACAlmC,KAAA6mC,aAAAX,EAAA,GAEAA,EAAAlmC,KAAAu/B,OAAAj6B,OAAA,GACAtF,KAAA8mC,WAAAZ,EAAA,EAEA,CAOA,SAAAS,CAAA1pB,EAAAohB,EAAA0I,GACA,MAAAtkB,EAAA1a,GAAAs2B,EAAAphB,GACA,GAAAwF,IAAA4b,EAAA/4B,OAAA,EAGA,OADA2X,EAAA2hB,aAAA3hB,EAAA2hB,aAAA,IACA,EAEA,MAAAoI,EAAA3I,EAAA5b,EAAA,GACAwkB,GAAAD,EAAAtI,iBAAAsI,EAAArI,oBAAA,EAEA,OAAAqI,EAAApI,aAAA3hB,EAAA2hB,aAAA,GACA3hB,EAAA2hB,aAAA3hB,EAAA2hB,aAAA,IACA,KAGAqI,EAAAF,GACA/lC,KAAAgD,IAAAijC,EAAAF,GAAA,UAIA/mC,KAAA2mC,UAAAK,EAAA3I,EAAA0I,KACA9pB,EAAA2hB,aAAA3hB,EAAA2hB,aAAA,IACA,GAGA,CAOA,QAAAgI,CAAA3pB,EAAAohB,EAAA0I,GACA,MAAAtkB,EAAA1a,GAAAs2B,EAAAphB,GACA,GAAA,IAAAwF,EAGA,OADAxF,EAAA2hB,aAAA3hB,EAAA2hB,aAAA,IACA,EAEA,MAAAsI,EAAA7I,EAAA5b,EAAA,GACA0kB,GAAAD,EAAAxI,iBAAAwI,EAAAvI,oBAAA,EAEA,OAAAuI,EAAAtI,aAAA3hB,EAAA2hB,aAAA,GACA3hB,EAAA2hB,aAAA3hB,EAAA2hB,aAAA,IACA,KAGAuI,EAAAJ,GACA/lC,KAAAgD,IAAAmjC,EAAAJ,GAAA,UAIA/mC,KAAA4mC,SAAAM,EAAA7I,EAAA0I,KACA9pB,EAAA2hB,aAAA3hB,EAAA2hB,aAAA,IACA,GAGA,CACA,cAAAwI,CAAAnqB,EAAAE,GACAnd,KAAAqnC,cAAAv2B,IAAAmM,EAAAE,GACAnd,KAAAsnC,cAAAv2B,YAAAoM,IACAnd,KAAAsnC,cAAAx2B,IAAAqM,EAAA,IAEAnd,KAAAsnC,cAAA12B,IAAAuM,GAAAvT,KAAAqT,EACA,CACA,YAAAslB,CAAAtlB,GACA,OAAAjd,KAAAsnC,cAAA12B,IAAA5Q,KAAAqnC,cAAAz2B,IAAAqM,GACA,CAIA,QAAAyiB,GACA1/B,KAAAsnC,cAAA,IAAAt1B,GACAhS,KAAAqnC,cAAA,IAAAr1B,GACA,MAAA0K,EAAA1c,KAAAmpB,MAAAzM,MAAAvQ,MAAA,GACAozB,EAAAv/B,KAAAu/B,OACA,IAAAlB,EAAAtwB,EAAA8W,EAAA5H,EAAA1J,EAAA4P,EAAArd,EAAAsoB,EACA,MAAAmZ,EAAA,SAAAC,EAAAC,EAAAtqB,GACAoiB,EAAAiI,GAAAhI,QAAAiI,GAAAlI,EAAAiI,GAAAhI,QAAAiI,IAAA,GACAlI,EAAAiI,GAAAhI,QAAAiI,GAAA79B,KAAAuT,EACA,EACA,IAAAiR,EAAA,EAAAA,EAAA1R,EAAApX,OAAA8oB,IAAA,CACA,MAAAjR,EAAAT,EAAA0R,GACAsZ,EAAAvqB,EAAA1X,OACAoH,EAAAsQ,EAAAhP,OACAw5B,EAAAD,EAAArJ,MACAuJ,EAAA/6B,EAAAwxB,MACAwJ,EAAAH,EAAA9I,aACAkJ,EAAAj7B,EAAA+xB,aACA1S,GAAA4b,EAAAD,GAAA7mC,KAAAgD,IAAA4jC,EAAAD,GACA,IAAAh6B,EAAA+5B,EACA,GAAAC,EAAAC,EAAA,EAAA,CACA,IAAA9hC,EAAA6hC,EAAA,EAAA7hC,EAAA8hC,EAAA9hC,IAAA,CA4BA,IA3BA+e,EAAA,IAAAtG,KACAsG,EAAA/d,EAAA4gC,EAAA5gC,EACA+d,EAAA7d,EAAA0gC,EAAA1gC,EACA6d,EAAA5P,MAAAyyB,EAAAzyB,MAAA,IACA4P,EAAA7P,OAAA0yB,EAAA1yB,OAAA,IACAqpB,EAAAkB,EAAAz5B,GACAiI,GAAAjI,EAAA8hC,GAAA1b,EAAA2b,EACA95B,EAAAswB,EAAA/4B,SACAyI,EAAAswB,EAAA/4B,QAGAuiC,GAAAtI,EAAAoI,GAAAriC,OAAA,GACAwiC,GAAAvI,EAAAqI,GAAAtiC,OAAA,EACAyI,EAAAswB,EAAA/4B,OAEA,IAAAuiC,GAAA,IAAAC,IACA/5B,EAAA,GAEA8W,EAAAwZ,MAAAv4B,EACA+e,EAAA2Z,YAAA,EACA3Z,EAAA4Z,YAAA,EACA5Z,EAAA0Z,kBAAA,EACA1Z,EAAAyZ,oBAAA,EACAzZ,EAAA+Z,aAAA7wB,EACA8W,EAAAjG,WAAA,EACA3V,GAAAo1B,EAAAxZ,EAAA9W,GAEAwF,EAAAxF,EAAA,EAAAwF,EAAA8qB,EAAA/4B,OAAAiO,IACA0J,EAAAohB,EAAA9qB,GACA0J,EAAA2hB,aAAA3hB,EAAA2hB,aAAA,EAEAzb,EAAA,IAAAnD,GAAArS,EAAAkX,GACA1B,EAAA4kB,iBAAA,EACAR,EAAAzhC,EAAA,EAAAA,EAAAqd,GACAxV,EAAAkX,EAEA7kB,KAAAmpB,MAAApG,SAAA8B,GACA7kB,KAAAmpB,MAAA/F,QAAAD,GACA0B,EAAApC,MAAAziB,KAAAmpB,MAAA1M,MAAAnX,OAAA,EACAtF,KAAAonC,eAAAviB,EAAA1H,EACA,CAEAoqB,EAAAK,EAAA,EAAAA,EAAAzkB,GACAhG,EAAAsD,aAAA9S,GACAwP,EAAA4qB,iBAAAJ,EAAAC,EAAA,CACA,MACA,GAAAD,EAAAC,GAAA,EAAA,CACA,IAAA9hC,EAAA6hC,EAAA,EAAA7hC,EAAA8hC,EAAA9hC,IAAA,CA6BA,IA5BA+e,EAAA,IAAAtG,KACAsG,EAAA/d,EAAA4gC,EAAA5gC,EACA+d,EAAA7d,EAAA0gC,EAAA1gC,EACA6d,EAAA5P,MAAAyyB,EAAAzyB,MAAA,IACA4P,EAAA7P,OAAA0yB,EAAA1yB,OAAA,IACAqpB,EAAAkB,EAAAz5B,GACAiI,GAAAjI,EAAA6hC,GAAAzb,EAAA2b,EACA95B,EAAAswB,EAAA/4B,SACAyI,EAAAswB,EAAA/4B,QAGAuiC,GAAAtI,EAAAoI,GAAAriC,OAAA,GACAwiC,GAAAvI,EAAAqI,GAAAtiC,OAAA,EACAyI,EAAAswB,EAAA/4B,OAEA,IAAAuiC,GAAA,IAAAC,IACA/5B,EAAA,GAEA8W,EAAAwZ,MAAAv4B,EACA+e,EAAA2Z,YAAA,EACA3Z,EAAA4Z,YAAA,EACA5Z,EAAA0Z,kBAAA,EACA1Z,EAAAyZ,oBAAA,EACAzZ,EAAA+Z,aAAA7wB,EACA8W,EAAAjG,WAAA,EACA7Q,EAAA/M,KAAAmF,MAAA4H,GACA9E,GAAAo1B,EAAAxZ,EAAA9W,GAEAwF,EAAAxF,EAAA,EAAAwF,EAAA8qB,EAAA/4B,OAAAiO,IACA0J,EAAAohB,EAAA9qB,GACA0J,EAAA2hB,aAAA3hB,EAAA2hB,aAAA,EAEAzb,EAAA,IAAAnD,GAAArS,EAAAkX,GACA1B,EAAA4kB,iBAAA,EACAR,EAAAzhC,EAAA,EAAAA,EAAAqd,GACAxV,EAAAkX,EAEA7kB,KAAAmpB,MAAApG,SAAA8B,GACA7kB,KAAAmpB,MAAA/F,QAAAD,GACA0B,EAAApC,MAAAziB,KAAAmpB,MAAA1M,MAAAnX,OAAA,EACAtF,KAAAonC,eAAAviB,EAAA1H,EACA,CACAoqB,EAAAK,EAAA,EAAAA,EAAAzqB,GAEAA,EAAAsD,aAAA9S,GACAwP,EAAA4qB,iBAAAH,EAAAD,EAAA,CACA,MAEAJ,EAAAI,EAAAC,EAAAzqB,EAEA,CACA,CAKA,UAAA4iB,GACA,IAAAiI,GAAA,EACA,KAAAA,GAAA,CACAA,GAAA,EACA,IAAA,IAAA5Z,EAAA,EAAAA,EAAApuB,KAAAmpB,MAAAzM,MAAApX,OAAA8oB,IAAA,CACA,MAAAjR,EAAAnd,KAAAmpB,MAAAzM,MAAA0R,GACA,IAAAjR,EAAA4qB,iBACA,SAEA,MAAAp+B,EAAA,GAEAA,EAAAkC,QAAA,CAAA/E,EAAAqW,EAAAhP,OAAArH,EAAAE,EAAAmW,EAAAhP,OAAAnH,IACA2C,EAAAkC,QAAA,CAAA/E,EAAAqW,EAAA1X,OAAAqB,EAAAE,EAAAmW,EAAA1X,OAAAuB,IAEA,IAAAwN,EAAA2I,EACA,MAAA4qB,EAAA5qB,EAAA4qB,iBACA,IAAA,IAAAl7B,EAAA,EAAAA,EAAAk7B,EAAAl7B,IAAA,CACA,MACAo7B,EADAzzB,EAAA/O,OACAgZ,SAAA,GACA9U,EAAAkC,QAAA,CAAA/E,EAAAmhC,EAAAxiC,OAAAqB,EAAAE,EAAAihC,EAAAxiC,OAAAuB,IACAwN,EAAAyzB,CACA,CAEA9qB,EAAAsD,aAAAjM,EAAA/O,QAEA0X,EAAA4qB,iBAAA,EAEAp+B,EAAArE,OAAA,GAEAqE,EAAA3B,OAAA,EAAA,GACA2B,EAAA3B,OAAA2B,EAAArE,OAAA,GACA6X,EAAAxT,OAAAA,GAGAwT,EAAAxT,OAAA,GAIAq+B,GAAA,EACA,KACA,CACA,CACA,CAIA,kBAAArI,GACA,IAAA75B,EAAAoiC,GAAA,EAEA,IAAAC,EAAA,EACA,KAAA,IAAAD,KACAC,IAHA,IAEA,CAKA,IADAD,EAAA,EACApiC,EAAA9F,KAAAu/B,OAAAj6B,OAAA,EAAAQ,GAAA,EAAAA,IACAoiC,GAAAloC,KAAAooC,wBAAA,EAAAtiC,GAEA,IAAAA,EAAA,EAAAA,EAAA9F,KAAAu/B,OAAAj6B,OAAA,EAAAQ,IACAoiC,GAAAloC,KAAAooC,wBAAA,EAAAtiC,EAEA,CACA,CACA,UAAAghC,CAAAzI,GACA,GAAA,IAAAA,EACA,OAEA,MAAA8H,EAAAnmC,KAAAu/B,OAAAlB,GACA,IAAAv4B,EAAAsoB,EAAAjR,EACA,MAAAqqB,EAAA,IAAAa,IACA7zB,EAAAxU,KAAAu/B,OAAAlB,EAAA,GACA,IAAAv4B,EAAA,EAAAA,EAAA0O,EAAAlP,OAAAQ,IACA0hC,EAAAhmC,IAAAgT,EAAA1O,IAEA,IAAAA,EAAA,EAAAA,EAAAqgC,EAAA7gC,OAAAQ,IAAA,CACA,MAAAmX,EAAAkpB,EAAArgC,GAEA,IAAAwiC,EAAA,EACAC,EAAA,EACA,IAAAna,EAAA,EAAAA,EAAAnR,EAAAwB,SAAAnZ,OAAA8oB,IACAjR,EAAAF,EAAAwB,SAAA2P,GACAoZ,EAAAhjC,IAAA2Y,EAAA1X,UACA8iC,IACAD,GAAAnrB,EAAA1X,OAAAm5B,cAGA,IAAAxQ,EAAA,EAAAA,EAAAnR,EAAAuB,SAAAlZ,OAAA8oB,IACAjR,EAAAF,EAAAuB,SAAA4P,GACAoZ,EAAAhjC,IAAA2Y,EAAAhP,UACAo6B,IACAD,GAAAnrB,EAAAhP,OAAAywB,cAGA2J,EAAA,GACAtrB,EAAAuhB,YAAA8J,EAAAC,EACAtrB,EAAAshB,kBAAAgK,IAGAtrB,EAAAuhB,YAAA14B,EACAmX,EAAAshB,kBAAA,EAEA,CACA,CACA,YAAAsI,CAAAxI,GACA,GAAAA,IAAAr+B,KAAAu/B,OAAAj6B,OAAA,EACA,OAEA,MAAA6gC,EAAAnmC,KAAAu/B,OAAAlB,GACA,IAAAv4B,EAAAsoB,EAAAjR,EACA,MAAAsqB,EAAA,IAAAY,IACA7zB,EAAAxU,KAAAu/B,OAAAlB,EAAA,GACA,IAAAv4B,EAAA,EAAAA,EAAA0O,EAAAlP,OAAAQ,IACA2hC,EAAAjmC,IAAAgT,EAAA1O,IAEA,IAAAA,EAAA,EAAAA,EAAAqgC,EAAA7gC,OAAAQ,IAAA,CACA,MAAAmX,EAAAkpB,EAAArgC,GAEA,IAAAwiC,EAAA,EACAC,EAAA,EACA,IAAAna,EAAA,EAAAA,EAAAnR,EAAAwB,SAAAnZ,OAAA8oB,IACAjR,EAAAF,EAAAwB,SAAA2P,GACAqZ,EAAAjjC,IAAA2Y,EAAA1X,UACA8iC,IACAD,GAAAnrB,EAAA1X,OAAAm5B,cAGA,IAAAxQ,EAAA,EAAAA,EAAAnR,EAAAuB,SAAAlZ,OAAA8oB,IACAjR,EAAAF,EAAAuB,SAAA4P,GACAqZ,EAAAjjC,IAAA2Y,EAAAhP,UACAo6B,IACAD,GAAAnrB,EAAAhP,OAAAywB,cAGA2J,EAAA,GACAtrB,EAAAwhB,YAAA6J,EAAAC,EACAtrB,EAAAqhB,oBAAAiK,IAGAtrB,EAAAwhB,YAAA34B,EACAmX,EAAAqhB,oBAAA,EAEA,CACA,CASA,sBAAA8J,CAAAnF,EAAA5E,GACA,IAAA6H,EACAC,EAEAA,EADAlD,EACAjjC,KAAAu/B,OAAA2G,EAAA7H,EAAA,GAGAr+B,KAAAu/B,OAAA2G,EAAA7H,EAAA,GAGA,MAAAmK,EAAArC,EAAAh6B,MAAA,GAEA82B,EACAjjC,KAAA8mC,WAAAZ,GAGAlmC,KAAA6mC,aAAAX,GAGAC,EAAAt8B,MAAA,CAAA6a,EAAAC,KACA,MAAA8jB,EAAAzoC,KAAAymC,eAAA/hB,GAAAgkB,EAAA1oC,KAAAymC,eAAA9hB,GACA,GAAA3jB,KAAAgD,IAAAykC,EAAAC,GAAA,KAEA,OAAAhkB,EAAA/E,WAAAgF,EAAAhF,SACA3f,KAAA2oC,eAAAjkB,EAAAC,GAEAD,EAAA/E,SAAAgF,EAAAhF,SACA,GAEA,EAEA,MAAAipB,EAAA,KAAAF,EAAAD,GACA,OAAAG,EAAA,GACA,EAEAA,EAAA,EACA,EAEA5oC,KAAA2oC,eAAAjkB,EAAAC,EAAA,IAGA,IAAA7e,EAAAoiC,EAAA,EACA,IAAApiC,EAAA,EAAAA,EAAAqgC,EAAA7gC,OAAAQ,IACAqgC,EAAArgC,KAAA0iC,EAAA1iC,IACAoiC,IAGA,GAAAA,EAAA,EAAA,CAEA,IAAAW,EAAA,EACA,IAAA/iC,EAAA,EAAAA,EAAAqgC,EAAA7gC,OAAAQ,IAAA,CACAqgC,EAAArgC,GACA84B,aAAAiK,GACA,CACA,CACA,OAAAX,CACA,CAMA,UAAAtI,GACA,MAAAkJ,EAAA9oC,KAAA0K,QAAAwQ,kBACA,IAAAitB,EAAA,EACA,OACAA,IAAAW,IADA,CAIA,MAAAC,EAAAZ,EAAA,GAAA,EACAa,EAAAb,EAAA,GAAA,EACA,IAAA,IAAA/Z,EAAA2a,EAAA,EAAA/oC,KAAAu/B,OAAAj6B,OAAA,EAAAyjC,EAAA3a,GAAApuB,KAAAu/B,OAAAj6B,OAAA,EAAA8oB,GAAA,EAAAA,GAAA2a,EAAA,GAAA,EAAA,CACA,MAAA1K,EAAAr+B,KAAAu/B,OAAAnR,GACA,IAAA6a,GAAA,EAGAC,GAAA,EACAC,EAAA,EACA,IAAA,IAAAp/B,EAAA,EAAAA,EAAAs0B,EAAA/4B,OAAA,EAAAyE,IAAA,CAEA,IAAAm5B,EAAA,EACAD,EAAA,EACAmG,EAAA,EAmBA,GAlBAF,GACA,IAAA9a,IACA8U,EAAAljC,KAAAqpC,mCAAAjb,EAAA,EAAAA,IAEAA,IAAApuB,KAAAu/B,OAAAj6B,OAAA,IACA29B,EAAAjjC,KAAAqpC,mCAAAjb,EAAAA,EAAA,IAEA2a,EACA7F,GAAA,EAGAD,GAAA,EAEAmG,EAAAlG,EAAAD,GAGAmG,EAAAD,EAEA,IAAAC,EACA,SAGA,IAAAE,EAAAjL,EAAAt0B,GACA06B,EAAApG,EAAAt0B,EAAA,GACAw/B,EAAAD,EAAA1K,aACA4K,EAAA/E,EAAA7F,aACAP,EAAAt0B,GAAA06B,EACApG,EAAAt0B,EAAA,GAAAu/B,EACAA,EAAA1K,aAAA4K,EACA/E,EAAA7F,aAAA2K,EAEArG,EAAA,EACA,IAAA9U,IACA8U,EAAAljC,KAAAqpC,mCAAAjb,EAAA,EAAAA,IAEA6U,EAAA,EACA7U,IAAApuB,KAAAu/B,OAAAj6B,OAAA,IACA29B,EAAAjjC,KAAAqpC,mCAAAjb,EAAAA,EAAA,IAEA2a,EACA7F,GAAA,EAGAD,GAAA,EAEA,MAAAwG,EAAAvG,EAAAD,EACA,IAAAyG,GAAA,EAEAA,EADAV,EACAS,GAAAL,EAGAK,EAAAL,EAEAM,GACAJ,EAAAjL,EAAAt0B,GACA06B,EAAApG,EAAAt0B,EAAA,GACAw/B,EAAAD,EAAA1K,aACA4K,EAAA/E,EAAA7F,aACAP,EAAAt0B,GAAA06B,EACApG,EAAAt0B,EAAA,GAAAu/B,EACAA,EAAA1K,aAAA4K,EACA/E,EAAA7F,aAAA2K,EAGAJ,EAAAC,EACAF,GAAA,IAGAD,GAAA,EACAC,GAAA,EAEA,CACAD,IACA7a,IAAApuB,KAAAu/B,OAAAj6B,OAAA,GACAtF,KAAA8mC,WAAA1Y,EAAA,GAEA,IAAAA,GACApuB,KAAA6mC,aAAAzY,EAAA,GAGA,CACA,CACA,CAOA,kCAAAib,CAAAM,EAAAC,GACA,MAAAltB,EAAA1c,KAAAu/B,OAAAoK,GAAAnK,QAAAoK,GACA,IAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EACAC,EAAA,EACA,MAAA/kC,EAAAoX,EAAApX,OACA,IAAA6kC,EAAA,EAAAA,EAAA7kC,EAAA6kC,IAEA,IADAN,EAAAntB,EAAAytB,GACAC,EAAAD,EAAA,EAAAC,EAAA9kC,EAAA8kC,IAAA,CACAN,EAAAptB,EAAA0tB,GACAP,EAAA17B,OAAAkwB,QAAAuL,GACAG,EAAAF,EAAApkC,OACAukC,EAAAH,EAAA17B,SAGA47B,EAAAF,EAAA17B,OACA67B,EAAAH,EAAApkC,QAEAqkC,EAAA37B,OAAAkwB,QAAAuL,GACAK,EAAAH,EAAArkC,OACAykC,EAAAJ,EAAA37B,SAGA87B,EAAAH,EAAA37B,OACA+7B,EAAAJ,EAAArkC,QAEA,MAAA6kC,EAAAP,EAAAnL,aACA2L,EAAAP,EAAApL,cAGA0L,EAFAL,EAAArL,eAEA2L,EADAL,EAAAtL,cACA,GACAyL,GAEA,CAEA,OAAAA,CACA,CACA,cAAA5D,CAAAxpB,GACA,MAAAshB,EAAAthB,EAAAshB,kBACAD,EAAArhB,EAAAqhB,oBACAE,EAAAvhB,EAAAuhB,YACAC,EAAAxhB,EAAAwhB,YACA,OAAAF,EAAA,GAAAD,EAAA,GACAE,EAAAC,GAAA,EAEAF,EAAA,EACAC,EAEAF,EAAA,EACAG,EAEA,CACA,CACA,qBAAAqE,CAAAh8B,EAAAE,GACA,OAAAF,EAAA83B,aAAA53B,EAAA43B,cACA,EAEA93B,EAAA83B,aAAA53B,EAAA43B,aACA,EAEA,CACA,CACA,0BAAA6G,CAAA3+B,EAAAE,GACA,OAAAF,EAAAsL,EAAApL,EAAAoL,GAAA,EAAAtL,EAAAsL,EAAApL,EAAAoL,EAAA,EAAA,CACA,CACA,2BAAAmzB,CAAAz+B,EAAAE,GACA,OAAAF,EAAAsL,EAAApL,EAAAoL,EAAA,EAAAtL,EAAAsL,EAAApL,EAAAoL,GAAA,EAAA,CACA,CACA,iBAAAwxB,CAAAvF,GACA,IAAA,IAAApxB,EAAA,EAAAA,EAAAoxB,EAAA/4B,OAAA2H,IACA,GAAAoxB,EAAApxB,GAAA2R,UACA,OAAA3R,EAGA,OAAA,CACA,CACA,cAAA07B,CAAA9zB,EAAAsqB,GACA,MAAAqB,EAAA3rB,EAAA4N,MACAge,EAAAtB,EAAA1c,MACA,OAAA+d,EAAAC,EACA,EAEAD,EAAAC,GACA,EAEA,CACA,CACA,MAAAa,CAAAkJ,EAAAC,GACA,OAAAD,EAAAA,EAAAC,GAAAA,CACA,CACA,eAAAxG,CAAA5F,EAAAphB,GAEA,IAAA,IAAAnX,EADAmX,EAAAkjB,WACA,EAAAr6B,EAAAu4B,EAAA/4B,SAAAQ,EACA,GAAAu4B,EAAAv4B,GAAA8Y,UACA,OAAAyf,EAAAv4B,GAGA,OAAA,IACA,EAGA,MAAA4kC,GACA,WAAAjgC,CAAAC,GACA1K,KAAAqH,OAAA,KACArH,KAAA0K,QAAAA,CACA,CACA,MAAAghB,CAAAif,EAAA5oB,GAEA,GADA/hB,KAAAmpB,MAAAwhB,EACA3qC,KAAAmpB,MAAA1M,OAAA,IAAAzc,KAAAmpB,MAAA1M,MAAAnX,OAAA,CAGA,IAAA2C,GAAAjI,KAAAmpB,MAAA1M,MAAAsF,GACA,MAAA,IAAAnZ,MAAA,uCAEA5I,KAAAqH,OAAA0a,EACA/hB,KAAAmpB,MAAA3H,qBAeAxhB,KAAA4qC,cApBA,CAuBA,CACA,UAAAC,CAAA90B,GACA/V,KAAA8qC,qBAAA9qC,KAAAqH,OAAA,QAAA,GACArH,KAAA+qC,kBAAA/qC,KAAAqH,OAAA,WAAA,GACA,IAAAL,EAAAlB,EAAAmX,EAAAlO,EAAA,EAAA6R,EAAA,EACA,IAAA9a,EAAA,EAAAA,EAAAiQ,EAAAzQ,OAAAQ,IAAA,CACAmX,EAAAlH,EAAAjQ,GACAmX,EAAA+tB,cAAA,OACA,MAAAv+B,EAAAzM,KAAAirC,QAAAhuB,EAAAmV,GAAAC,MAAAvpB,KAAA9I,OACA4gB,EAAA5f,KAAAoO,IAAAwR,EAAAnU,EAAAwI,OACAlG,GAAAtC,EAAAuI,OAAAhV,KAAA0K,QAAA8P,kBACA,CACAzL,GAAA/O,KAAA0K,QAAA8P,mBACA,MAAA1T,EAAA9G,KAAAqH,OAAAP,EAAA9G,KAAA0K,QAAA6P,qBAEA,IADAvT,EAAAhH,KAAAqH,OAAAL,GAAAhH,KAAAqH,OAAA2N,OAAAjG,GAAA,EACAjJ,EAAA,EAAAA,EAAAiQ,EAAAzQ,OAAAQ,IAAA,CACAmX,EAAAlH,EAAAjQ,GACA,MAAA6H,EAAA,IAAA8F,GAAA3M,EAAAmW,EAAAmV,KAAAnd,MAAAjO,GACAhH,KAAAkrC,QAAAjuB,EAAAtP,GACA3G,GAAAiW,EAAAmV,KAAApd,OAAAhV,KAAA0K,QAAA8P,kBACA,CACA,CACA,WAAA2wB,CAAAt1B,GACA7V,KAAA8qC,qBAAA9qC,KAAAqH,OAAA,SAAA,GACArH,KAAA+qC,kBAAA/qC,KAAAqH,OAAA,WAAA,GACA,IAAAL,EAAAlB,EAAAmX,EAAAlO,EAAA,EAAA6R,EAAA,EACA,IAAA9a,EAAA,EAAAA,EAAA+P,EAAAvQ,OAAAQ,IAAA,CACAmX,EAAApH,EAAA/P,GACAmX,EAAA+tB,cAAA,QACA,MAAAv+B,EAAAzM,KAAAirC,QAAAhuB,EAAAmV,GAAAC,MAAAvpB,KAAA9I,OACA4gB,EAAA5f,KAAAoO,IAAAwR,EAAAnU,EAAAwI,OACAlG,GAAAtC,EAAAuI,OAAAhV,KAAA0K,QAAA8P,kBACA,CACAzL,GAAA/O,KAAA0K,QAAA8P,mBACA,MAAA1T,EAAA9G,KAAAqH,OAAAP,EAAA9G,KAAA0K,QAAA6P,qBAAAva,KAAAqH,OAAA4N,MAEA,IADAjO,EAAAhH,KAAAqH,OAAAL,GAAAhH,KAAAqH,OAAA2N,OAAAjG,GAAA,EACAjJ,EAAA,EAAAA,EAAA+P,EAAAvQ,OAAAQ,IAAA,CACAmX,EAAApH,EAAA/P,GACA,MAAA6H,EAAA,IAAA8F,GAAA3M,EAAAE,GACAhH,KAAAkrC,QAAAjuB,EAAAtP,GACA3G,GAAAiW,EAAAmV,KAAApd,OAAAhV,KAAA0K,QAAA8P,kBACA,CACA,CACA,QAAA4wB,CAAAlI,GACAljC,KAAA8qC,qBAAA9qC,KAAAqH,OAAA,MAAA,GACArH,KAAA+qC,kBAAA/qC,KAAAqH,OAAA,WAAA,GACA,IAAAL,EAAAiW,EAAAnX,EAAA8a,EAAA,EACA,IAAA9a,EAAA,EAAAA,EAAAo9B,EAAA59B,OAAAQ,IAAA,CACAmX,EAAAimB,EAAAp9B,GACAmX,EAAA+tB,cAAA,KAEApqB,GADA5gB,KAAAirC,QAAAhuB,EAAAmV,GAAAC,MAAAvpB,KAAA9I,OACAiV,MAAAjV,KAAA0K,QAAA6P,oBACA,CACAqG,GAAA5gB,KAAA0K,QAAA6P,qBACA,IAAAzT,EAAA9G,KAAAqH,OAAAP,EAAA9G,KAAAqH,OAAA4N,MAAA,EAAA2L,EAAA,EAEA,IAAA9a,EAAA,EAAAA,EAAAo9B,EAAA59B,OAAAQ,IAAA,CACAmX,EAAAimB,EAAAp9B,GACAkB,EAAAhH,KAAAqH,OAAAL,EAAAhH,KAAA0K,QAAA8P,mBAAAyC,EAAAmV,KAAApd,OACA,MAAArH,EAAA,IAAA8F,GAAA3M,EAAAE,GACAhH,KAAAkrC,QAAAjuB,EAAAtP,GACA7G,GAAAmW,EAAAmV,KAAAnd,MAAAjV,KAAA0K,QAAA6P,oBACA,CACA,CACA,UAAA8wB,CAAApI,GACA,IAAAhmB,EAAAnX,EACA9F,KAAA8qC,qBAAA9qC,KAAAqH,OAAA,QAAA,GACArH,KAAA+qC,kBAAA/qC,KAAAqH,OAAA,WAAA,GACA,IAAAuZ,EAAA,EACA,IAAA9a,EAAA,EAAAA,EAAAm9B,EAAA39B,OAAAQ,IAAA,CACAmX,EAAAgmB,EAAAn9B,GACAmX,EAAAquB,cAAA,OAEA1qB,GADA5gB,KAAAirC,QAAAhuB,EAAAmV,GAAAC,MAAAvpB,KAAA9I,OACAiV,MAAAjV,KAAA0K,QAAA6P,oBACA,CACAqG,GAAA5gB,KAAA0K,QAAA6P,qBACA,IAAAzT,EAAA9G,KAAAqH,OAAAP,EAAA9G,KAAAqH,OAAA4N,MAAA,EAAA2L,EAAA,EACA,MAAA5Z,EAAAhH,KAAAqH,OAAAL,EAAAhH,KAAA0K,QAAA8P,mBAAAxa,KAAAqH,OAAA2N,OACA,IAAAlP,EAAA,EAAAA,EAAAm9B,EAAA39B,OAAAQ,IAAA,CACAmX,EAAAgmB,EAAAn9B,GACA,MAAA6H,EAAA,IAAA8F,GAAA3M,EAAAE,GACAhH,KAAAkrC,QAAAjuB,EAAAtP,GACA7G,GAAAmW,EAAAmV,KAAAnd,MAAAjV,KAAA0K,QAAA6P,oBACA,CACA,CACA,gBAAAgxB,GAEAvrC,KAAA8qC,qBAAA9qC,KAAAqH,OAAA,UAAA,GACArH,KAAA+qC,kBAAA/qC,KAAAqH,OAAA,WAAA,GACArH,KAAAwrC,aAAA,KACA,MAAAC,EAAAzrC,KAAA0K,QAAAyQ,iBAAApa,EACA2qC,EAAA1rC,KAAA0K,QAAA0Q,eAAAra,EACA,GAAA2qC,GAAAD,EACA,MAAA,IAAA7iC,MAAA,wDAEA5I,KAAA2rC,SAAA,EACA3rC,KAAA6P,OAAA,IAAA4D,GAAAzT,KAAAqH,OAAAP,EAAA9G,KAAAqH,OAAAL,GACAhH,KAAA4rC,sBAAA5rC,KAAAqH,OAAA,GAEArH,KAAA2rC,SAAA,GACA3rC,KAAA6rC,aAAA7rC,KAAAqH,OAAArH,KAAA0K,QAAA4Q,2BAAAmwB,EAAAC,GAGA1rC,KAAAqH,OAAAykC,MAAAJ,EAAAD,CACA,CACA,WAAAM,CAAA9I,EAAA+I,GACA3nC,EAAA2nC,KACAA,EAAA,GAEAhsC,KAAA8qC,qBAAA9qC,KAAAqH,OAAA,QAAA,GACArH,KAAA+qC,kBAAA/qC,KAAAqH,OAAA,WAAA,GACArH,KAAA+qC,kBAAA/qC,KAAAqH,OAAA,cAAA,EAAA2kC,GACA,IAAA/uB,EAAAnX,EAAA8a,EAAA,EACA,IAAA9a,EAAA,EAAAA,EAAAm9B,EAAA39B,OAAAQ,IAAA,CACAmX,EAAAgmB,EAAAn9B,GAEAmX,EAAA+tB,cAAA,OAEApqB,GADA5gB,KAAAirC,QAAAhuB,EAAAmV,GAAAC,MAAAvpB,KAAA9I,OACAiV,MAAAjV,KAAA0K,QAAA6P,oBACA,CACAqG,GAAA5gB,KAAA0K,QAAA6P,qBAEAqG,GAAAqiB,EAAAA,EAAA39B,OAAA,GAAA2P,MACA2L,GAAAqiB,EAAAA,EAAA39B,OAAA,GAAA2Y,gBAAAhC,SAAAhH,MACA,IAAAnO,EAAA9G,KAAAqH,OAAAP,EAAA9G,KAAAqH,OAAA4N,MAAA,EAAA2L,EAAA,EACA,MAAA5Z,EAAAhH,KAAAqH,OAAAL,EAAAhH,KAAA0K,QAAA8P,mBAAAxa,KAAAqH,OAAA2N,OACA,IAAAlP,EAAA,EAAAA,EAAAm9B,EAAA39B,OAAAQ,IAAA,CACAmX,EAAAgmB,EAAAn9B,GAEA,MAAA6H,EAAA,IAAA8F,GAAA3M,EAAAE,GACAhH,KAAAkrC,QAAAjuB,EAAAtP,GACA7G,GAAAmW,EAAAmV,KAAAnd,MAAAjV,KAAA0K,QAAA6P,oBACA,CASA,CACA,qBAAAqxB,CAAA7hC,EAAA8C,GACAA,EAAA7M,KAAA2rC,WACA3rC,KAAA2rC,SAAA9+B,GAEA,MAAAo/B,EAAA,IAAAp/B,EAAA,EAAA7L,KAAAgM,KAAA,KAAAH,EACA,IAAAq/B,EAAA,EACA,GAAAniC,EAAAmV,SAAA5Z,OAAA,EAAA,CAEA,IAAA,IAAAQ,EAAA,EAAAsL,EAAArH,EAAAmV,SAAA5Z,OAAAQ,EAAAsL,EAAAtL,IAAA,CACA,MAAAgc,EAAA/X,EAAAmV,SAAApZ,GACAomC,GAAAlsC,KAAA4rC,sBAAA9pB,EAAAjV,EAAA,EACA,CACAq/B,EAAAlrC,KAAAoO,IAAA68B,EAAAC,EACA,MAEAA,EAAAD,EAGA,OADAliC,EAAAoiC,YAAAD,EACAA,CACA,CACA,YAAAE,CAAAriC,GACA,IAAAjE,EAAAumC,EAAA,EAEA,GAAAtiC,EAAAqV,QAAA9Z,OAAA,EACA,MAAA,IAAAsD,MAAA,+BAEA,MAAA+E,EAAA5D,EAAAqV,QAAA,GACA,GAAAzR,EAAA,CACA,MAAA2+B,EAAA,IAAA74B,GAAA9F,EAAA7G,EAAA6G,EAAA3G,GACAulC,EAAA,IAAA94B,GAAA1J,EAAAjD,EAAAiD,EAAA/C,GACAqlC,EAAArsC,KAAAwsC,eAAAxrC,KAAA8L,MAAAw/B,EAAAtlC,EAAAulC,EAAAvlC,EAAAslC,EAAAxlC,EAAAylC,EAAAzlC,GACA,CACA,MAAA2lC,EAAA1iC,EAAAmV,SAAA5Z,OACA,GAAA,IAAAmnC,EACA,OAAA,KAEA,MAAAj5B,EAAA,GACAlI,EAAA,GACA,IAAAxF,EAAA,EAAAA,EAAA2mC,IAAA3mC,EAAA,CACA,MAAAmH,EAAAlD,EAAAmV,SAAApZ,GACAsoB,EAAA,IAAA3a,GAAAxG,EAAAnG,EAAAmG,EAAAjG,GACAsE,EAAAxF,GAAAA,EACA0N,EAAA1N,GAAA9F,KAAAwsC,gBAAAH,EAAArrC,KAAA8L,MAAAshB,EAAApnB,EAAAonB,EAAApnB,EAAAonB,EAAAtnB,EAAAsnB,EAAAtnB,GACA,CACAyC,GAAAiK,EAAAlI,GACA,MAAAohC,EAAA,GACAxtB,EAAAnV,EAAAmV,SACA,IAAApZ,EAAA,EAAAA,EAAA2mC,IAAA3mC,EACA4mC,EAAA9iC,KAAAsV,EAAA5T,EAAAxF,KAEA,OAAA4mC,CACA,CACA,cAAAF,CAAAh5B,GACA,KAAAA,EAAA,EAAAxS,KAAAC,IACAuS,GAAA,EAAAxS,KAAAC,GAEA,KAAAuS,EAAA,GACAA,GAAA,EAAAxS,KAAAC,GAEA,OAAAuS,CACA,CACA,YAAAq4B,CAAA5uB,EAAAyM,EAAA+hB,EAAAC,GACA,MAAAiB,EAAAjB,EAAAD,EACAmB,EAAAD,EAAA,EACAE,EAAA5vB,EAAAkvB,YACA,IAAAW,EAAA,EACA,MAAA1G,EAAApmC,KAAAosC,aAAAnvB,GACA,IAAA,IAAAnX,EAAA,EAAAsL,EAAAg1B,EAAA9gC,OAAAQ,EAAAsL,EAAAtL,IAAA,CACA,MAAAinC,EAAA3G,EAAAtgC,GACAknC,EAAAD,EACAE,EAAAD,EAAAb,YAAAU,EACAE,EAAA7tB,SAAA5Z,OAAA,GACAtF,KAAA6rC,aAAAkB,EAAArjB,EAAA1pB,KAAA0K,QAAA2Q,iBAAAowB,EAAAqB,EAAAH,EAAAlB,GAAAqB,EAAAG,GAAAN,GAEA3sC,KAAAktC,iBAAAH,EAAArjB,EAAA+hB,EAAAqB,EAAAH,EAAAM,EAAAL,GACAI,EAAAx5B,MAAAy5B,EAAAN,EACAG,GAAAG,CACA,CACA,CACA,gBAAAC,CAAAjwB,EAAAyM,EAAAlW,GACAyJ,EAAAnW,EAAA9G,KAAA6P,OAAA/I,EAAA4iB,EAAA1oB,KAAAgN,IAAAwF,GACAyJ,EAAAjW,EAAAhH,KAAA6P,OAAA7I,EAAA0iB,EAAA1oB,KAAAyrB,IAAAjZ,GACAyJ,EAAAkwB,kBAAA,IAAAz4B,GAAAuI,EAAAnW,EAAAmW,EAAAjW,EAAAiW,EAAAhI,MAAAgI,EAAAjI,OACA,CAQA,oBAAA81B,CAAA7tB,EAAAmwB,EAAAC,GACA,MAAAC,EAAArwB,EAAAquB,cACAtrC,KAAAmpB,MAAA3D,oBAAAvI,GAAAlT,IACAA,EAAAuhC,cAAA8B,CAAA,IAEAC,IACApwB,EAAAquB,cAAAgC,EAEA,CASA,iBAAAvC,CAAA9tB,EAAAyO,EAAA2hB,EAAArB,GACA3nC,EAAA2nC,KACAA,EAAA,GAEA,MAAAuB,EAAAtwB,EAAAuwB,eACAxB,EAAA,GAEAhsC,KAAAmpB,MAAAzH,aAAAzE,GAEAjd,KAAAmpB,MAAA3D,oBAAAvI,GAAAxQ,IACAA,EAAAoV,OAAAmqB,EAAA,IACAv/B,EAAA+gC,eAAA9hB,EACA,MAIA1rB,KAAAmpB,MAAA3D,oBAAAvI,GAAAxQ,IACAA,EAAA+gC,eAAA9hB,CAAA,IAGA2hB,IACApwB,EAAAuwB,eAAAD,GAGA,CAQA,OAAAtC,CAAAhuB,EAAAwwB,GACA,IAAAhhC,EAAAmU,EAAA,EAAA7R,EAAA,EACA1F,EAAA,IAAA+oB,GAAA,EAAA,GACA,IAAAnV,EACA,MAAA,IAAArU,MAAA,wBAEA,MAAAa,EAAAwT,EAAAgB,gBAAAhC,SACAyxB,EAAAjkC,EAAAwL,MACA04B,EAAAlkC,EAAAuL,OACA,GAAA,IAAAiI,EAAAmC,QAAA9Z,OACA,MAAA,IAAAsD,MAAA,gCAEA,MAAAoiB,EAAA/N,EAAAmC,QAAA,GAIA,GAHA,cAAAnC,EAAAquB,gBACAruB,EAAAquB,cAAAtgB,EAAAsgB,eAEAnmC,EAAA8X,EAAAiC,UACA7V,EAAA,IAAA+oB,GAAApxB,KAAAgD,IAAA0pC,GAAAxsC,EAAA,GAAAwsC,EAAA1sC,KAAAgD,IAAA2pC,GAAAzsC,EAAA,GAAAysC,QAEA,GAAA,IAAA1wB,EAAAiC,SAAA5Z,OAAA,CACA,OAAA2X,EAAAquB,eACA,IAAA,SACA7+B,EAAAzM,KAAAirC,QAAAhuB,EAAAiC,SAAA,GAAAuuB,GACA7sB,EAAA8sB,EAAA1tC,KAAA0K,QAAA2Q,iBAAAra,KAAAgN,IAAAiP,EAAA2wB,eAAAnhC,EAAAwI,MACAlG,EAAA4+B,EAAA3sC,KAAAgD,IAAAhE,KAAA0K,QAAA2Q,iBAAAra,KAAAyrB,IAAAxP,EAAA2wB,gBAAAnhC,EAAAuI,OACA,MACA,IAAA,OACA,IAAA,QACA,OAAAiI,EAAAuwB,gBACA,IAAA,uBAEA,IAAA,0BACA,MACA,IAAA,aACA/gC,EAAAzM,KAAAirC,QAAAhuB,EAAAiC,SAAA,GAAAuuB,GACA7sB,EAAA8sB,EAAAjhC,EAAAwI,MAAAjV,KAAA0K,QAAAgQ,2BACA3L,EAAA4+B,EAAA3tC,KAAA0K,QAAA+P,4BAAAhO,EAAAuI,OACA,MACA,IAAA,UACAvI,EAAAzM,KAAAirC,QAAAhuB,EAAAiC,SAAA,GAAAuuB,GACA7sB,EAAA8sB,EAAA1tC,KAAA0K,QAAA6P,qBAAA9N,EAAAwI,MACAlG,EAAA/N,KAAAoO,IAAAu+B,EAAAlhC,EAAAuI,QACA,MACA,QACA,MAAA,IAAApM,MAAA,2DAEA,MACA,IAAA,KACA,IAAA,OACA,OAAAqU,EAAAuwB,gBACA,IAAA,uBACA,IAAA,0BACA,MACA,IAAA,aACA/gC,EAAAzM,KAAAirC,QAAAhuB,EAAAiC,SAAA,GAAAuuB,GACA7sB,EAAA5f,KAAAoO,IAAAs+B,EAAAjhC,EAAAwI,MAAAjV,KAAA0K,QAAAgQ,4BACA3L,EAAA4+B,EAAA3tC,KAAA0K,QAAA+P,4BAAAhO,EAAAuI,OACA,MACA,IAAA,UACAvI,EAAAzM,KAAAirC,QAAAhuB,EAAAiC,SAAA,GAAAuuB,GACA1+B,EAAA4+B,EAAA3tC,KAAA0K,QAAA8P,mBAAA/N,EAAAuI,OACA4L,EAAA5f,KAAAoO,IAAAs+B,EAAAjhC,EAAAwI,OACA,MACA,QACA,MAAA,IAAArM,MAAA,yDAEA,MACA,QACA,MAAA,IAAAA,MAAA,oDAEAS,EAAA,IAAA+oB,GAAAxR,EAAA7R,EACA,KACA,CACA,IAAAjJ,EAAAinC,EACA,OAAA9vB,EAAAquB,eACA,IAAA,OACA,IAAA,QACA,OAAAruB,EAAAuwB,gBACA,IAAA,uBACA,IAAA,0BACA,MACA,IAAA,aAGA,IAFA5sB,EAAA8sB,EACA3+B,EAAA4+B,EAAA3tC,KAAA0K,QAAA+P,4BACA3U,EAAA,EAAAA,EAAAmX,EAAAiC,SAAA5Z,OAAAQ,IACAinC,EAAA9vB,EAAAiC,SAAApZ,GACA2G,EAAAzM,KAAAirC,QAAA8B,EAAAU,GACA7sB,EAAA5f,KAAAoO,IAAAwR,EAAAnU,EAAAwI,MAAAjV,KAAA0K,QAAAgQ,4BACA3L,GAAAtC,EAAAuI,OAAAhV,KAAA0K,QAAAiQ,6BAEA5L,GAAA/O,KAAA0K,QAAAiQ,6BACA,MACA,IAAA,UAGA,IAFAiG,EAAA8sB,EACA3+B,EAAA,EACAjJ,EAAA,EAAAA,EAAAmX,EAAAiC,SAAA5Z,OAAAQ,IACAinC,EAAA9vB,EAAAiC,SAAApZ,GACA2G,EAAAzM,KAAAirC,QAAA8B,EAAAU,GACA7sB,EAAA5f,KAAAoO,IAAAwR,EAAA8sB,EAAA1tC,KAAA0K,QAAA6P,qBAAA9N,EAAAwI,OACAlG,GAAAtC,EAAAuI,OAAAhV,KAAA0K,QAAA8P,mBAEAzL,GAAA/O,KAAA0K,QAAA8P,mBACA,MACA,QACA,MAAA,IAAA5R,MAAA,0DAEA,MACA,IAAA,KACA,IAAA,OACA,OAAAqU,EAAAuwB,gBACA,IAAA,uBACA,IAAA,0BACA,MACA,IAAA,aAGA,IAFA5sB,EAAA8sB,EACA3+B,EAAA4+B,EAAA3tC,KAAA0K,QAAA+P,4BACA3U,EAAA,EAAAA,EAAAmX,EAAAiC,SAAA5Z,OAAAQ,IACAinC,EAAA9vB,EAAAiC,SAAApZ,GACA2G,EAAAzM,KAAAirC,QAAA8B,EAAAU,GACA7sB,EAAA5f,KAAAoO,IAAAwR,EAAAnU,EAAAwI,MAAAjV,KAAA0K,QAAAgQ,4BACA3L,GAAAtC,EAAAuI,OAAAhV,KAAA0K,QAAAiQ,6BAEA5L,GAAA/O,KAAA0K,QAAAiQ,6BACA,MACA,IAAA,UAGA,IAFAiG,EAAA,EACA7R,EAAA,EACAjJ,EAAA,EAAAA,EAAAmX,EAAAiC,SAAA5Z,OAAAQ,IACAinC,EAAA9vB,EAAAiC,SAAApZ,GACA2G,EAAAzM,KAAAirC,QAAA8B,EAAAU,GACA7sB,GAAAnU,EAAAwI,MAAAjV,KAAA0K,QAAA6P,qBACAxL,EAAA/N,KAAAoO,IAAAL,EAAAtC,EAAAuI,OAAAhV,KAAA0K,QAAA8P,mBAAAmzB,GAEA/sB,GAAA5gB,KAAA0K,QAAA6P,qBACA,MACA,QACA,MAAA,IAAA3R,MAAA,yDAEA,MACA,QACA,MAAA,IAAAA,MAAA,oDAEAS,EAAA,IAAA+oB,GAAAxR,EAAA7R,EACA,CAGA,OAFAkO,EAAA4wB,YAAA7sC,KAAAgM,KAAA4T,EAAAA,EAAA,EAAA7R,EAAAA,EAAA,GACAkO,EAAAmV,KAAA/oB,EACAA,CACA,CACA,OAAA6hC,CAAAnhC,EAAA4D,GACA,MAAAlE,EAAAM,EAAAkU,gBAAAhC,SACA,IAAAnW,EAAAgoC,EAAAhsB,EAAA7E,EAAA8wB,EACA,MAAAL,EAAAjkC,EAAAwL,MACA04B,EAAAlkC,EAAAuL,OACA,GAAA7P,EAAA4E,EAAAmV,UACAnV,EAAAjD,EAAA6G,EAAA7G,EACAiD,EAAA/C,EAAA2G,EAAA3G,EACA+C,EAAAojC,kBAAA,IAAAz4B,GAAA/G,EAAA7G,EAAA6G,EAAA3G,EAAA0mC,EAAAC,OAEA,CACA,IAAA7mC,EAAAE,EACAgnC,EACA,OAAAjkC,EAAAuhC,eACA,IAAA,OACA,OAAAvhC,EAAAyjC,gBACA,IAAA,uBACA,IAAA,0BACA,MACA,IAAA,aAMA,IALAQ,EAAArgC,EACA5D,EAAAjD,EAAAknC,EAAAlnC,EACAiD,EAAA/C,EAAAgnC,EAAAhnC,EACA+C,EAAAojC,kBAAA,IAAAz4B,GAAA3K,EAAAjD,EAAAiD,EAAA/C,EAAA+C,EAAAkL,MAAAlL,EAAAiL,QACAhO,EAAA2G,EAAA3G,EAAA2mC,EAAA3tC,KAAA0K,QAAA+P,4BACA3U,EAAA,EAAAA,EAAAmX,EAAAiC,SAAA5Z,OAAAQ,IACAmX,EAAAA,EAAAiC,SAAApZ,GACAgB,EAAAknC,EAAAlnC,EAAAmW,EAAAgB,gBAAAhJ,MAAAjV,KAAA0K,QAAAgQ,2BACAozB,EAAA,IAAAr6B,GAAA3M,EAAAE,GACAhH,KAAAkrC,QAAAjuB,EAAA6wB,GACA9mC,GAAAiW,EAAAmV,KAAApd,OAAAhV,KAAA0K,QAAAiQ,6BAEA,MACA,IAAA,UAOA,IANAqzB,EAAA,IAAAv6B,GAAA9F,EAAA7G,EAAAiD,EAAAqoB,KAAAnd,MAAAy4B,EAAA//B,EAAA3G,GAAA+C,EAAAqoB,KAAApd,OAAA24B,GAAA,GACA5jC,EAAAjD,EAAAknC,EAAAlnC,EACAiD,EAAA/C,EAAAgnC,EAAAhnC,EACA+C,EAAAojC,kBAAA,IAAAz4B,GAAA3K,EAAAjD,EAAAiD,EAAA/C,EAAA+C,EAAAkL,MAAAlL,EAAAiL,QACAlO,EAAAknC,EAAAlnC,EAAA9G,KAAA0K,QAAA6P,qBACAvT,EAAA2G,EAAA3G,EACAlB,EAAA,EAAAA,EAAAiE,EAAAmV,SAAA5Z,OAAAQ,IACAmX,EAAAlT,EAAAmV,SAAApZ,GACAgoC,EAAA,IAAAr6B,GAAA3M,EAAAmW,EAAAmV,KAAAnd,MAAAjO,GACAhH,KAAAkrC,QAAAjuB,EAAA6wB,GACA9mC,GAAAiW,EAAAmV,KAAApd,OAAAhV,KAAA0K,QAAA8P,mBAEA,MACA,QACA,MAAA,IAAA5R,MAAA,6BAEA,MACA,IAAA,QACA,OAAAmB,EAAAyjC,gBACA,IAAA,uBACA,IAAA,0BACA,MACA,IAAA,aAQA,IAPAQ,EAAArgC,EACA5D,EAAAjD,EAAAknC,EAAAlnC,EACAiD,EAAA/C,EAAAgnC,EAAAhnC,EACA+C,EAAAojC,kBAAA,IAAAz4B,GAAA3K,EAAAjD,EAAAiD,EAAA/C,EAAA+C,EAAAkL,MAAAlL,EAAAiL,QACAlO,EAAA6G,EAAA7G,EAAA4mC,EAAA1tC,KAAA0K,QAAAgQ,2BAEA1T,EAAA2G,EAAA3G,EAAA2mC,EAAA3tC,KAAA0K,QAAA+P,4BACA3U,EAAA,EAAAA,EAAAiE,EAAAmV,SAAA5Z,OAAAQ,IACAmX,EAAAlT,EAAAmV,SAAApZ,GACAgoC,EAAA,IAAAr6B,GAAA3M,EAAAE,GACAhH,KAAAkrC,QAAAjuB,EAAA6wB,GACA9mC,GAAAiW,EAAAmV,KAAApd,OAAAhV,KAAA0K,QAAAiQ,6BAEA,MACA,IAAA,UAOA,IANAqzB,EAAA,IAAAv6B,GAAA9F,EAAA7G,EAAA6G,EAAA3G,GAAA+C,EAAAqoB,KAAApd,OAAA24B,GAAA,GACA5jC,EAAAjD,EAAAknC,EAAAlnC,EACAiD,EAAA/C,EAAAgnC,EAAAhnC,EACA+C,EAAAojC,kBAAA,IAAAz4B,GAAA3K,EAAAjD,EAAAiD,EAAA/C,EAAA+C,EAAAkL,MAAAlL,EAAAiL,QACAlO,EAAA6G,EAAA7G,EAAA4mC,EAAA1tC,KAAA0K,QAAA6P,qBACAvT,EAAA2G,EAAA3G,EACAlB,EAAA,EAAAA,EAAAiE,EAAAmV,SAAA5Z,OAAAQ,IACAmX,EAAAlT,EAAAmV,SAAApZ,GACAgoC,EAAA,IAAAr6B,GAAA3M,EAAAE,GACAhH,KAAAkrC,QAAAjuB,EAAA6wB,GACA9mC,GAAAiW,EAAAmV,KAAApd,OAAAhV,KAAA0K,QAAA8P,mBAEA,MACA,QACA,MAAA,IAAA5R,MAAA,6BAEA,MACA,IAAA,KAKA,GAJAolC,EAAA,IAAAv6B,GAAA9F,EAAA7G,GAAAiD,EAAAqoB,KAAAnd,MAAAy4B,GAAA,EAAA//B,EAAA3G,EAAA+C,EAAAqoB,KAAApd,OAAA24B,GACA5jC,EAAAjD,EAAAknC,EAAAlnC,EACAiD,EAAA/C,EAAAgnC,EAAAhnC,EACA+C,EAAAojC,kBAAA,IAAAz4B,GAAA3K,EAAAjD,EAAAiD,EAAA/C,EAAA+C,EAAAkL,MAAAlL,EAAAiL,QACAhU,KAAAgD,IAAAgqC,EAAAlnC,EAAA6G,EAAA7G,GAAA5F,EAAA,CAGA,IAFA6sC,EAAA,EAEAjoC,EAAA,EAAAA,EAAAiE,EAAAmV,SAAA5Z,OAAAQ,IACAgc,EAAA/X,EAAAmV,SAAApZ,GACAioC,GAAAjsB,EAAAsQ,KAAAnd,MAAAjV,KAAA0K,QAAA6P,qBAEAwzB,GAAA/tC,KAAA0K,QAAA6P,qBACAzT,EAAA6G,EAAA7G,GAAA4mC,EAAAK,GAAA,CACA,MAEAjnC,EAAA6G,EAAA7G,EAEA,IAAAhB,EAAA,EAAAA,EAAAiE,EAAAmV,SAAA5Z,OAAAQ,IACAmX,EAAAlT,EAAAmV,SAAApZ,GACAkB,EAAAgnC,EAAAhnC,EAAAhH,KAAA0K,QAAA8P,mBAAAyC,EAAAmV,KAAApd,OACA84B,EAAA,IAAAr6B,GAAA3M,EAAAE,GACAhH,KAAAkrC,QAAAjuB,EAAA6wB,GACAhnC,GAAAmW,EAAAmV,KAAAnd,MAAAjV,KAAA0K,QAAA6P,qBAEA,MACA,IAAA,OACA,OAAAxQ,EAAAyjC,gBACA,IAAA,uBACA,IAAA,0BACA,MACA,IAAA,aAOA,IANAQ,EAAArgC,EACA5D,EAAAjD,EAAAknC,EAAAlnC,EACAiD,EAAA/C,EAAAgnC,EAAAhnC,EACA+C,EAAAojC,kBAAA,IAAAz4B,GAAA3K,EAAAjD,EAAAiD,EAAA/C,EAAA+C,EAAAkL,MAAAlL,EAAAiL,QACAlO,EAAA6G,EAAA7G,EAAA9G,KAAA0K,QAAAgQ,2BACA1T,EAAA2G,EAAA3G,EAAA2mC,EAAA3tC,KAAA0K,QAAA+P,4BACA3U,EAAA,EAAAA,EAAAiE,EAAAmV,SAAA5Z,OAAAQ,IACAmX,EAAAlT,EAAAmV,SAAApZ,GACAgoC,EAAA,IAAAr6B,GAAA3M,EAAAE,GACAhH,KAAAkrC,QAAAjuB,EAAA6wB,GACA9mC,GAAAiW,EAAAmV,KAAApd,OAAAhV,KAAA0K,QAAAiQ,6BAEA,MACA,IAAA,UAKA,GAJAqzB,EAAA,IAAAv6B,GAAA9F,EAAA7G,GAAAiD,EAAAqoB,KAAAnd,MAAAy4B,GAAA,EAAA//B,EAAA3G,GACA+C,EAAAjD,EAAAknC,EAAAlnC,EACAiD,EAAA/C,EAAAgnC,EAAAhnC,EACA+C,EAAAojC,kBAAA,IAAAz4B,GAAA3K,EAAAjD,EAAAiD,EAAA/C,EAAA+C,EAAAkL,MAAAlL,EAAAiL,QACAhU,KAAAgD,IAAAgqC,EAAAlnC,EAAA6G,EAAA7G,GAAA5F,EAAA,CAGA,IAFA6sC,EAAA,EAEAjoC,EAAA,EAAAA,EAAAiE,EAAAmV,SAAA5Z,OAAAQ,IACAgc,EAAA/X,EAAAmV,SAAApZ,GACAioC,GAAAjsB,EAAAsQ,KAAAnd,MAAAjV,KAAA0K,QAAA6P,qBAEAwzB,GAAA/tC,KAAA0K,QAAA6P,qBACAzT,EAAA6G,EAAA7G,GAAA4mC,EAAAK,GAAA,CACA,MAEAjnC,EAAA6G,EAAA7G,EAEA,IAAAhB,EAAA,EAAAA,EAAAiE,EAAAmV,SAAA5Z,OAAAQ,IACAmX,EAAAlT,EAAAmV,SAAApZ,GACAkB,EAAAgnC,EAAAhnC,EAAAhH,KAAA0K,QAAA8P,mBAAAmzB,EACAG,EAAA,IAAAr6B,GAAA3M,EAAAE,GACAhH,KAAAkrC,QAAAjuB,EAAA6wB,GACAhnC,GAAAmW,EAAAmV,KAAAnd,MAAAjV,KAAA0K,QAAA6P,qBAEA,MACA,QACA,MAAA,IAAA3R,MAAA,6BAEA,MACA,IAAA,OACA,MACA,QACA,MAAA,IAAAA,MAAA,6BAEA,CACA,CACA,YAAAgiC,GACA,IAAA5qC,KAAAqH,OACA,OAEA,GAAAlC,EAAAnF,KAAAqH,OAAA6X,UACA,OAEA,IAIA+uB,EAAAC,EAAAC,EAAAC,EAJA7gC,EAAAvN,KAAA0K,QAAAsP,QACA3V,EAAAkJ,KACAA,EAAA,QAGA,MAAA2R,EAAAlf,KAAAqH,OAAA6X,SACA,OAAA3R,EAAA2K,eACA,IAAA,SACA,IAAA,aACAlY,KAAAurC,mBACA,MACA,IAAA,oBACA,IAAA,UACA0C,EAAAjuC,KAAAqH,OAAA6X,SACA,IAAAlf,KAAAqH,OAAA6X,SAAA5Z,OACAtF,KAAAmrC,YAAA8C,IAIAG,EAAAlvB,EAAA5Z,OAAA,EACA4oC,EAAA9lC,GAAApI,KAAAqH,OAAA6X,UAAA,SAAAnV,GACA,OAAAhC,GAAAmX,EAAAnV,GAAAqkC,CACA,IACAD,EAAA/lC,GAAApI,KAAAqH,OAAA6X,UAAA,SAAAnV,GACA,OAAAhC,GAAAmX,EAAAnV,IAAAqkC,CACA,IACApuC,KAAA6qC,WAAAqD,GACAluC,KAAAmrC,YAAAgD,IAEA,MACA,IAAA,kBACAF,EAAAjuC,KAAAqH,OAAA6X,SACA,IAAAlf,KAAAqH,OAAA6X,SAAA5Z,OACAtF,KAAAqrC,WAAA4C,IAIAG,EAAAlvB,EAAA5Z,OAAA,EACA4oC,EAAA9lC,GAAApI,KAAAqH,OAAA6X,UAAA,SAAAnV,GACA,OAAAhC,GAAAmX,EAAAnV,GAAAqkC,CACA,IACAD,EAAA/lC,GAAApI,KAAAqH,OAAA6X,UAAA,SAAAnV,GACA,OAAAhC,GAAAmX,EAAAnV,IAAAqkC,CACA,IACApuC,KAAAorC,SAAA8C,GACAluC,KAAAqrC,WAAA8C,IAEA,MACA,IAAA,QACAnuC,KAAAmrC,YAAAnrC,KAAAqH,OAAA6X,UACA,MACA,IAAA,OACAlf,KAAA6qC,WAAA7qC,KAAAqH,OAAA6X,UACA,MACA,IAAA,KACA,IAAA,SACAlf,KAAAorC,SAAAprC,KAAAqH,OAAA6X,UACA,MACA,IAAA,OACA,IAAA,MACAlf,KAAAqrC,WAAArrC,KAAAqH,OAAA6X,UACA,MACA,IAAA,UACA,IAAA,cACA,GAAAlf,KAAA0K,QAAA2jC,sBAAA,EACA,MAAA,IAAAzlC,MAAA,oDAEA5I,KAAA+rC,YAAA/rC,KAAAqH,OAAA6X,SAAAlf,KAAA0K,QAAA2jC,uBAQA,EAQA,MAAAC,WAAA1yB,GACA,WAAAnR,CAAAgT,GAEA,GADAvL,QACA7N,EAAAoZ,GACA,MAAA,IAAA7U,MAAA,yBAEA5I,KAAAyd,QAAAA,CACA,CAIA,MAAAiO,CAAAhhB,GACA1K,KAAAud,gBAAA7S,GAEA,MAAA6jC,EAAA,IAAA5iB,GAAA3rB,KAAAyd,SAMAzd,KAAAmpB,MAAAolB,EAAA3iB,UACA,MAAAC,EAAA7rB,KAAAwuC,mBAGA,OAAA,IAAAhxB,GAAAxd,KAAAyd,QAAAoO,EACA,CACA,gBAAA2iB,GACA,GAAAxuC,KAAAmpB,MAAAhkB,UACA,OAGA,MAAA4W,EAAA/b,KAAAmpB,MAAAlH,yBACA,GAAA9c,EAAA4W,GACA,OAEA,MAAA2P,EAAA,IAAAgf,GAAA1qC,KAAA0K,SACAie,EAAA,GAEA,IAAA,IAAA7iB,EAAA,EAAAA,EAAAiW,EAAAzW,OAAAQ,IAAA,CACA,MAAAwW,EAAAP,EAAAjW,GACA6kC,EAAA3qC,KAAAyuC,QAAAnyB,GACA,IAAAquB,EACA,MAAA,IAAA/hC,MAAA,qDAEA,MAAAmZ,EAAA4oB,EAAA5oB,KACAY,EAAAgoB,EAAAhoB,KACA+I,EAAAA,OAAA/I,EAAAZ,GACA4G,EAAA/e,KAAA+Y,EACA,CACA,OAAA3iB,KAAA8b,qBAAA6M,EACA,CAQA,OAAA8lB,CAAAtlB,GACA,IAAApH,EAAA,KACA,GAAA/hB,KAAA0K,QAAAuP,OAAAja,KAAA0K,QAAAuP,MAAA3U,OAAA,EACA,IAAA,IAAAQ,EAAA,EAAAsL,EAAA+X,EAAA1M,MAAAnX,OAAAQ,EAAAsL,EAAAtL,IAAA,CACA,MAAAmX,EAAAkM,EAAA1M,MAAA3W,GACA,IAAA,IAAAgX,EAAA,EAAAA,EAAA9c,KAAA0K,QAAAuP,MAAA3U,OAAAwX,IAAA,CAEA,GADA9c,KAAA0K,QAAAuP,MAAA6C,KACAG,EAAAgB,gBAAA,CACA8D,EAAA9E,EACA,KACA,CACA,CACA,CAEA,IAAA8E,IAEAA,EAAAoH,EAAApH,QAEAA,GACA,MAAA,IAAAnZ,MAAA,uCAGA,OAAA5I,KAAA0uC,eAAAvlB,EAAApH,EACA,CACA,cAAA2sB,CAAAvlB,EAAApH,GACA,MAAAY,EAAAwG,EAAAzG,gBAAAX,GACA,OAAA1d,EAAAse,IAAAA,EAAAxd,UACA,KAEA,CACAwd,KAAAA,EACAZ,KAAAY,EAAAZ,OAEA,EAGA,MAAA4sB,GACA,WAAAlkC,CAAAgT,EAAA/S,GACA1K,KAAAyd,QAAAA,EACAzd,KAAA0K,QAAAmP,GAAA,CAAA,EAAA7Z,KAAA0K,QAAAA,GACA1K,KAAAke,OAAA,IAAAwb,GACA15B,KAAAyd,QAAAmxB,UAAAhlC,KAAA5J,KACA,CACA,OAAA6uC,GAAA,EAGA,MAAAC,GACA,WAAArkC,CAAAhE,EAAAsoC,EAAAC,GACAhvC,KAAAyG,KAAAA,EACAzG,KAAAivC,YAAAF,EACA/uC,KAAAkvC,YAAAF,EACAhvC,KAAAmvC,YAAA1oC,EAAAhB,SACAzF,KAAAovC,YAAA3oC,EAAA0H,SACAnO,KAAAqvC,MAAAhsC,CACA,CACA,IAAAisC,GACAtvC,KAAAyG,KAAA8oC,iBAAAvvC,KAAAivC,YAAA/rC,GACAlD,KAAAyG,KAAA8oC,iBAAAvvC,KAAAkvC,YAAA/rC,GACAnD,KAAAyG,KAAA+oC,aACA,CACA,IAAAC,GACAzvC,KAAAyG,KAAA8oC,iBAAAvvC,KAAAmvC,YAAAjsC,GACAlD,KAAAyG,KAAA8oC,iBAAAvvC,KAAAovC,YAAAjsC,GACAnD,KAAAyG,KAAA+oC,aACA,EAcA,SAAAE,GAAAC,GACA,OAAAA,EAAAjlC,QAAAhF,KAAAwS,gBAAAhW,EAAAgW,aACA,CACA,SAAA03B,GAAAv6B,EAAAw6B,GACA,IAAAC,EAAAH,EAAAI,EAAAxsC,EACA,IAAA,IAAAuC,EAAA,EAAAA,EAAA+pC,EAAAvqC,OAAAQ,IAEA,GADA6pC,EAAAE,EAAA/pC,IACA4pC,GAAAC,GAAA,CACA,MAAApP,EAAAlrB,EAAA26B,WAAAL,EAAAxmC,YACAo3B,EAAAwP,IACAA,EAAAxP,EACAuP,EAAAH,EAEA,CAEA,OAAAG,CACA,CACA,SAAAG,GAAA9V,EAAAJ,GACA,MAAA/T,EAAA,GACA,IAAAlgB,EAAAoY,EACA,MAAAgB,EAAAib,EAAAnG,mBAAA9U,SACA5Z,EAAA4Z,EAAA5Z,OACA,IAAAQ,EAAA,EAAAA,EAAAi0B,EAAAz0B,OAAAQ,IAAA,CACAoY,EAAA6b,EAAAj0B,GACA,IAAA,IAAAgX,EAAA,EAAAA,EAAAxX,EAAAwX,IACA,GAAAoC,EAAApC,KAAAoB,EAAA8V,mBAAA,CACAhO,EAAApc,KAAAkT,GACA,KACA,CAEA,CACA,OAAAkJ,CACA,CAOA,SAAAkqB,GAAAC,GACA,MAAA9mC,EAAA,CAAA,EAoBA,OAlBAlF,GADAgsC,EAAAA,GAAA,CAAA,GACAvS,OAAA,OAAAuS,EAAAvS,OACAv0B,EAAAu0B,KAAAuS,EAAAvS,MAEAz5B,EAAAgsC,EAAArpC,IAAA,OAAAqpC,EAAArpC,IACAuC,EAAAvC,EAAAqpC,EAAArpC,GAEA3C,EAAAgsC,EAAAnpC,IAAA,OAAAmpC,EAAAnpC,IACAqC,EAAArC,EAAAmpC,EAAAnpC,GAEA7C,EAAAgsC,EAAAl7B,QAAA,OAAAk7B,EAAAl7B,QACA5L,EAAA4L,MAAAk7B,EAAAl7B,OAEA9Q,EAAAgsC,EAAAn7B,SAAA,OAAAm7B,EAAAn7B,SACA3L,EAAA2L,OAAAm7B,EAAAn7B,QAEA7Q,EAAAgsC,EAAA5iC,OAAA,OAAA4iC,EAAA5iC,OACAlE,EAAAkE,KAAA4iC,EAAA5iC,MAEAlE,CACA,CAqCA,MAAA+mC,GACA,WAAA3lC,CAAA4lC,EAAAjyB,EAAAkyB,GACAtwC,KAAAoe,OAAAA,EACApe,KAAAswC,YAAAA,EACAtwC,KAAAqvC,MAAA,WACArvC,KAAAuwC,YAAA,GACAvwC,KAAAwwC,UAAAH,EAAAI,OACAzwC,KAAAqwC,QAAAA,EACArwC,KAAAqH,OAAAgpC,EAAAK,aAAArpC,SACA,IAAA,IAAAvB,EAAA,EAAAA,EAAA9F,KAAAoe,OAAA9Y,OAAAQ,IAAA,CACA,MAAAiY,EAAA/d,KAAAoe,OAAAtY,GACA9F,KAAAuwC,YAAA3mC,KAAAmU,EAAAnH,SAAApD,MACA,CACA,CACA,IAAA87B,GACA,IAAAxpC,EAAAiY,EACA,IAAAjY,EAAA,EAAAA,EAAA9F,KAAAoe,OAAA9Y,OAAAQ,IACAiY,EAAA/d,KAAAoe,OAAAtY,GACAiY,EAAAnH,OAAA5W,KAAAswC,YAAAxqC,GAAA9F,KAAAqH,QAAA,GACA,WAAA0W,GACAA,EAAA2N,OAAA3N,GAEAA,EAAAyxB,cAEAxvC,KAAAqwC,UACArwC,KAAAqwC,QAAAM,cACA3wC,KAAAqwC,QAAAxB,UAEA,CACA,IAAAY,GACA,IAAA3pC,EAAAiY,EACA,IAAAjY,EAAA,EAAAA,EAAA9F,KAAAoe,OAAA9Y,OAAAQ,IACAiY,EAAA/d,KAAAoe,OAAAtY,GACAiY,EAAAnH,OAAA5W,KAAAuwC,YAAAzqC,GAAA9F,KAAAqH,QAAA,GACA,WAAA0W,GACAA,EAAA2N,OAAA3N,GAEAA,EAAAyxB,cAEAxvC,KAAAqwC,UACArwC,KAAAqwC,QAAAM,cACA3wC,KAAAqwC,QAAAxB,UAEA,EAGA,MAAA+B,GAAA,CACA37B,MAAA,EACAD,OAAA,EACA2U,KAAA,CACAW,MAjiQA,UAmiQA0L,MAAA,CAAA,GAEA,MAAA6a,GACA,WAAApmC,CAAAsT,EAAArT,GACA1K,KAAA0K,QAAAmP,GAAA,CAAA,EAAA+2B,GAAAlmC,GACA1K,KAAAqe,YAAA,GACAre,KAAA+d,MAAAA,CACA,CACA,QAAA5U,GACA,OAAAnJ,KAAA0K,QAAAvB,SACAnJ,KAAA0K,QAAAvB,SAAAnJ,KAAA+d,OAGA/d,KAAA+d,MAAA+yB,YAAA9wC,KAAA0K,QAAAhF,KAEA,CACA,MAAAqrC,GACA,MAAA,CACAC,QAAAhxC,KAAA+d,MAAAjZ,WACA6qC,UAAA3vC,KAAA0K,QAAAhF,KAEA,CACA,YAAAwP,CAAAuI,EAAAtI,GACA,MAAA87B,EAAA97B,EAAAxI,MAAA,KAAAmF,EAAAm/B,EAAA,GAAAvrC,EAAAurC,EAAA,IAAA/uC,EACA,IAAA,IAAA4D,EAAA,EAAAA,EAAA2X,EAAAW,OAAA9Y,OAAAQ,IAAA,CACA,MAAAiY,EAAAN,EAAAW,OAAAtY,GACA,GAAAiY,EAAArT,QAAAoH,KAAAA,EACA,OAAAiM,EAAAmzB,aAAAxrC,EAAAusB,OAEA,CACA,EAIA,MAAAkf,GAAA,CAAA,CACAzrC,KAAAvD,GACA,CACAuD,KAAApD,GACA,CACAoD,KAAArD,GACA,CACAqD,KAAAtD,GACA,CACAsD,KAAAxD,EACAiH,SAAA,SAAA4U,GACA,OAAAA,EAAA+yB,YAAA,SACA,IAEArnB,GAAA,SAAA2nB,GACA,MAAAC,EAAA,CACA9jC,KArlQA,YAslQAqpB,KAAA,GACAqC,UAAA,EACA/a,OAAA,KACApX,EAzlQA,EA0lQAE,EA1lQA,EA2lQAsqC,SA3lQA,GA4lQAC,UA5lQA,GA6lQAt8B,MA7lQA,IA8lQAD,OA9lQA,IA+lQAghB,MAAA,CAAA,EACAwb,SAAA,CACAznB,SAAA,EACA0nB,MAAA,IAEA5B,WAAAsB,GACArf,SAAA,CACAte,MAAA,IAIA,OADAjO,EAAA8rC,EAAAD,GACAC,CACA,EAEAK,GAAA,CACA1b,MAAA,CAAA,EACA2b,OAAAvwC,EAAAE,KACAyW,QAAA,CACAD,MAAA,iBAEA85B,YAAA,EACAC,cAAA,EACAC,QAAA,GAEA,MAAAC,WAAAvnC,GACA,WAAAC,CAAAC,GACAwH,QACAlS,KAAAmwC,UAAAzlC,GAAA,CAAA,GAAAylC,SACAnwC,KAAA0K,QAAAmP,GAAA,CAAA/H,GAAAzB,MAAAqhC,GAAAhnC,GACA1K,KAAAgyC,YAAA,EACAhyC,KAAAke,OAAA,IAAAwb,GAAA,CACA5nB,GAAA9R,KAAA0K,QAAAoH,GACAmnB,SAAAj5B,KAAA0K,QAAAuuB,WAEAj5B,KAAA8R,GAAA9R,KAAA0K,QAAAoH,GACA9R,KAAAiyC,WACA,CACA,UAAAC,CAAA78B,GACA,OAAArV,KAAAqwC,QACArwC,KAAAqwC,QAAA6B,WAAA78B,GAEArV,KAAA0K,QAAAinC,MACA,CACA,OAAAjiB,CAAA3rB,GACA,GAAAM,EAAAN,GACA,OAAA/D,KAAAke,OAAAwR,UAGA1vB,KAAAke,OAAAwR,QAAA3rB,EAEA,CACA,MAAAkY,CAAAlY,GACA,OAAAM,EAAAN,GACA,IAGA,CACA,OAAA8qC,GACA7uC,KAAAke,OAAA+V,QACA,CACA,QAAA9qB,CAAAkM,GACArV,KAAA0K,QAAA5D,EAAAuO,EAAAvO,EACA9G,KAAA0K,QAAA1D,EAAAqO,EAAArO,EACAhH,KAAAke,OAAA/U,SAAAkM,EACA,CACA,QAAAvQ,GACA,OAAA9E,KAAA0K,QAAAoH,EACA,CACA,SAAAqgC,GAEA,MAAAC,EAAAv4B,GAAA,CAAA,EAAA,CAAAnP,QAAA1K,KAAA0K,UAIA,OAHA1K,KAAAmwC,WACAiC,EAAAjC,SAAAnwC,KAAAmwC,SAAArrC,YAEAstC,CACA,CACA,QAAAC,CAAAt6B,GACA,QAAApP,IAAAoP,EAAA,CACA,MAAArN,EAAA1K,KAAA0K,QACA9F,EAAAmT,GACArN,EAAAqN,QAAA6lB,KAAA7lB,EAGA8B,GAAAnP,EAAAqN,QAAAA,GAEA,MAAAu6B,EAAA5nC,EAAAqN,QACA/X,KAAAuyC,eAKAvyC,KAAAwyC,qBAAAF,GAHAtyC,KAAAyyC,qBAAAH,EAKA,CACA,OAAAtyC,KAAA0K,QAAAqN,QAAA6lB,IACA,CACA,oBAAA6U,CAAA/nC,GACAA,EAAAkzB,OACA59B,KAAAuyC,eAAA,IAAA/U,GAAA9yB,GACA1K,KAAAuyC,eAAA/X,gBAAA,EACAx6B,KAAAke,OAAAma,OAAAr4B,KAAAuyC,gBAEA,CACA,oBAAAC,CAAA9nC,GACA1K,KAAAuyC,eAAAte,OAAAvpB,EACA,CACA,QAAAgoC,CAAAr9B,GACA,MAAA4G,EAAAjc,KAAAic,SACA,OAAAjc,KAAA0vB,WAAAzT,EAAAhU,SAAAoN,IAAArV,KAAA0K,QAAAonC,MACA,CACA,SAAAG,GACA,GAAAjyC,KAAA0K,QAAAqN,QAAA46B,SAAA,CACA,MAAAh0B,EAAA3e,KAAAmwC,UAAA,CAAA,EAAAyC,EAAA5yC,KAAA0K,QAAAmoC,cAAA7yC,KAAA0K,QAAAqN,QAAA46B,SAAA,CACAG,UAAA,aAEA9yC,KAAA0K,QAAAqN,QAAA6lB,KAAAgV,EAAAj0B,EACA,CACA,CACA,UAAAo0B,GACA,OAAA,IAAA/yC,KAAA0K,QAAAknC,UACA,CACA,MAAAb,GACA,MAAA,CACAj/B,GAAA9R,KAAA0K,QAAAoH,GAEA,EAGA,MAAAkhC,WAAAjB,GACA,WAAAtnC,CAAAC,EAAA+S,GACAvL,MAAAxH,GACA1K,KAAA0K,QAAAmP,GAAA,CAAA,EAAA7Z,KAAA0K,QAAA+e,KAAA/e,GACA1K,KAAAyd,QAAAA,EACAzd,KAAAizC,yBACAvoC,EAAA1K,KAAA0K,QACA1K,KAAA6vC,WAAA,GACA7vC,KAAAuN,KAAA7C,EAAA6C,KACAvN,KAAAkzC,oBACAlzC,KAAAmzC,eACAnzC,KAAA+X,QAAA/X,KAAA+X,WACA/X,KAAAozC,mBACA,CACA,oBAAAC,CAAAC,GACA,MAAAC,EAAArD,GAAAoD,GAAAtzC,KAAAmwC,UACAnwC,KAAA0K,QAAAmP,GAAA,CAAA,EAAA7Z,KAAA0K,QAAA6oC,GACAvzC,KAAAwzC,cACA,CACA,sBAAAP,CAAAK,EAAA1f,GACA,GAAA5zB,KAAAyd,SAAAzd,KAAAyd,QAAAg2B,YAAA,CACA,MAAAF,EAAArD,GAAAoD,GAAAtzC,KAAAmwC,UACA,GAAAmD,GAAA1f,EACA,GAAA3rB,GAAA,CAAA,IAAA,IAAA,QAAA,UAAA2rB,GAaA,CACA,MAAA3X,EAAAjc,KAAAic,SACAA,EAAA2X,GAAA0f,EAAA1f,GACA5zB,KAAAic,OAAAA,EACA,MAhBAjc,KAAA0K,QAAAwT,OACAle,KAAA0zC,gBAEAH,EAAAhmC,OACAvN,KAAA0K,QAAAmP,GAAA,CAAA,EAAA7Z,KAAA0K,QAAA6oC,GACAvzC,KAAA0zC,iBAEA1zC,KAAA0K,QAAAqN,UACA/X,KAAAiyC,YACAjyC,KAAA+X,QAAA/X,KAAA0K,QAAAqN,eAUA/X,KAAA0K,QAAAmP,GAAA,CAAA,EAAA7Z,KAAA0K,QAAA6oC,EAEA,CACA,CACA,aAAAG,GACA1zC,KAAAke,OAAA5U,QACAtJ,KAAAuyC,eAAA,KACAvyC,KAAA0K,QAAAylC,SAAAnwC,KAAAmwC,SACAnwC,KAAAkzC,oBACAlzC,KAAAmzC,cACA,CACA,YAAAK,GACAxzC,KAAA0zC,gBACA1zC,KAAA0K,QAAAqN,UACA/X,KAAAiyC,YACAjyC,KAAA+X,QAAA/X,KAAA0K,QAAAqN,SAEA,CACA,WAAAy3B,CAAAmE,GACA,MAAAl2B,EAAAzd,KAAAyd,QACAA,GAAAA,EAAAg2B,aACAh2B,EAAAm2B,iBAAA5zC,KAAA2zC,EAEA,CACA,YAAAR,GACA,MAAAl3B,EAAAjc,KAAAke,OAAAqW,UAAA,GACA7pB,EAAA1K,KAAA0K,QACA1K,KAAAic,OAAA,IAAAvH,GAAAhK,EAAA5D,EAAA4D,EAAA1D,EAAAiV,EAAAhH,MAAAgH,EAAAjH,SACAhV,KAAA6zC,UACA7zC,KAAA8zC,eACA,CACA,OAAA/7B,CAAAA,GACA,MAAA1O,EAAArJ,KAAAqyC,SAAAt6B,GAEA,OADA/X,KAAA8zC,gBACAzqC,CACA,CACA,aAAAyqC,GACA,MAAAxB,EAAAtyC,KAAA0K,QAAAqN,SAAA,CAAA,EACAg8B,EAAA/zC,KAAAuyC,eACA,GAAAwB,GAAAzB,EAAAx6B,MAAA,CACA,MAAAk8B,EAAAh0C,KAAAke,OAAAqW,WACA0f,EAAA,IAAAr8B,GAAAo8B,GACAE,EAAAH,EAAA7f,eAAAigB,KAAA,MACAC,EAAA,IAAA1/B,GAAA,EAAA,EAAAw/B,EAAAj/B,QAAAi/B,EAAAl/B,UACAq/B,EAAAJ,EAAAn8B,MAAAs8B,EAAA9B,EAAAx6B,OACAi8B,EAAA5qC,SAAAkrC,EAAAr+B,UACA,CACA,CACA,iBAAAo9B,GACA,MAAA1oC,EAAA1K,KAAA0K,QAAApF,EAAAoF,EAAAmlC,WAAAvqC,OAAAgvC,EAAA5pC,EAAA4pC,kBACA,IAAA3E,EAAA7pC,EACA,IAAAA,EAAA,EAAAA,EAAAR,EAAAQ,IACA6pC,EAAA,IAAAkB,GAAA7wC,KAAA6Z,GAAA,CAAA,EAAAy6B,EAAA5pC,EAAAmlC,WAAA/pC,KACA9F,KAAA6vC,WAAAjmC,KAAA+lC,EAEA,CACA,MAAA1zB,CAAAlY,GACA,IAAAkY,EACA,GAAAlY,EACA,GAAAa,EAAAb,GACA,OAAAA,GACA,KAAAF,EACAoY,EAAAjc,KAAAu0C,qBACA,MAEA,IA30QA,WA20QA,CACAt4B,EAAAjc,KAAAu0C,qBACA,MAAAC,EAAAx0C,KAAAyd,QAAAg3B,KACAx4B,EAAAnV,GAAA0tC,EAAA1tC,EACAmV,EAAAjV,GAAAwtC,EAAAxtC,EACA,KACA,CACA,KAAA/D,EACAgZ,EAAAjc,KAAA00C,iBACA,MAEA,QACAz4B,EAAAjc,KAAA20C,aAMA30C,KAAA40C,WAAA7wC,GACA/D,KAAA60C,uBACA70C,KAAAyd,SAAAzd,KAAAyd,QAAAq3B,YACA90C,KAAA+0C,0BAKA94B,EAAAjc,KAAA20C,QAEA,OAAA14B,CACA,CACA,UAAA24B,CAAAv+B,GACA,MAAA3L,EAAA1K,KAAA0K,QACAsL,EAAAK,EAAAL,UACAlP,EAAA4D,EAAA5D,EAAAkP,EAAAlP,EACAE,EAAA0D,EAAA1D,EAAAgP,EAAAhP,EACAiO,EAAAvK,EAAAuK,MAAAjU,KAAAoO,IAAAiH,EAAApB,MAAAvK,EAAA4mC,UACAt8B,EAAAtK,EAAAsK,OAAAhU,KAAAoO,IAAAiH,EAAArB,OAAAtK,EAAA6mC,WACAvxC,KAAA20C,QAAA,IAAAjgC,GAAA5N,EAAAE,EAAAiO,EAAAD,GACAhV,KAAAke,OAAA+V,OAAA,CACAntB,EAAAA,EACAE,EAAAA,EACAiO,MAAAA,EACAD,OAAAA,GAEA,CACA,QAAA7L,CAAAkM,GACA,IAAAA,EAIA,OAAArV,KAAA20C,QAAA3+B,UAHAhW,KAAAic,OAAA,IAAAvH,GAAAW,EAAAvO,EAAAuO,EAAArO,EAAAhH,KAAA20C,QAAA1/B,MAAAjV,KAAA20C,QAAA3/B,QAKA,CAMA,KAAAzD,GACA,MAAA6gC,EAAApyC,KAAAmyC,YAKA,OAJAC,EAAA1nC,QAAAoH,GAAAzB,KACArQ,KAAAyd,SAAAzd,KAAAyd,QAAAg2B,aAAAtvC,EAAAnE,KAAAmwC,YACAiC,EAAA1nC,QAAAylC,SAAAnwC,KAAAyd,QAAA/S,QAAAsqC,cAAAh1C,KAAAmwC,WAEA,IAAA6C,GAAAZ,EAAA1nC,aAAA/B,EACA,CACA,MAAAjH,CAAAqC,GACA,MAAA0Z,EAAAzd,KAAAyd,QACA,IAAAw3B,EAAAC,EAIA,GAHA7wC,EAAAN,KACAA,GAAA,GAEA/D,KAAA+yC,cACA/yC,KAAAgyC,aAAAjuC,EAeA,OAdAkxC,EAAA,GACAC,EAAA,GACAl1C,KAAAgyC,WAAAjuC,EACA/D,KAAAgyC,YACAv0B,EAAA03B,eAAAvrC,KAAA5J,MACAi1C,EAAArrC,KAAA5J,QAGA4H,GAAA6V,EAAA03B,eAAAn1C,MACAk1C,EAAAtrC,KAAA5J,OAEAyd,EAAA23B,oBACA33B,EAAA43B,kBAAAJ,EAAAC,IAEA,CAGA,CACA,MAAAt+B,CAAApD,EAAAnM,EAAAuiB,GACA,MAAAhT,EAAA5W,KAAAke,OAAAtH,SACA,QAAAjO,IAAA6K,EAAA,EACA,IAAAoW,GAAA5pB,KAAAyd,SAAAzd,KAAAyd,QAAA63B,iBAAA9hC,IAAAoD,EAAApD,OACAxT,KAAAyd,QAAA63B,gBAAA9zC,IAAA,IAAA4uC,GAAApwC,KAAAyd,QAAA83B,iBAAA,CAAAv1C,MAAA,CAAA4W,EAAApD,SAAA,GAEA,MAAA/J,EAAAzJ,KAAAic,SAAAu5B,EAAA,IAAA/hC,GAAAhK,EAAAwL,MAAA,EAAAxL,EAAAuL,OAAA,GACA,IAAAygC,EAAAC,EACAruC,IACAouC,EAAAjiC,EAAAoD,EAAApD,MACAkiC,EAAAjsC,EAAApC,SAAAuP,OAAA6+B,EAAApuC,GAAAuM,MAAA4hC,GACAx1C,KAAA21C,gBAAA31C,KAAA21C,gBAAAhiC,KAAA+hC,EAAA9hC,MAAAnK,EAAAuM,YACAhW,KAAAmJ,SAAAusC,IAEA11C,KAAAke,OAAAtH,OAAApD,EAAAgiC,GACAx1C,KAAA0K,QAAAonB,SAAAte,MAAAA,EACAxT,KAAAyd,SAAAzd,KAAAyd,QAAAm4B,oBACA51C,KAAAyd,QAAAm4B,mBAAA/G,UAEA7uC,KAAA+0C,qBACA/0C,KAAAyd,SACAzd,KAAAyd,QAAA3R,QAAApJ,EAAA,CAAA+D,KAAAzG,MAEA,CACA,OAAA4W,CACA,CACA,WAAAyH,CAAA9Q,GACA,MAAAlE,EAAA,GACA,IAAAvD,EAAAgX,EAAA+4B,EAAAC,EAAAC,EACA,IAAAjwC,EAAA,EAAAA,EAAA9F,KAAA6vC,WAAAvqC,OAAAQ,IAGA,IAFAiwC,EAAA/1C,KAAA6vC,WAAA/pC,GACAgwC,EAAAC,EAAA13B,YACAvB,EAAA,EAAAA,EAAAg5B,EAAAxwC,OAAAwX,IAEA,GADA+4B,EAAAC,EAAAh5B,GACA,QAAAvP,EAAA,CACA,MAAA9H,EAAAowC,EAAApwC,SACAA,EAAAsY,OAAAtY,EAAAsY,QAAA/d,MACAqJ,EAAAO,KAAAisC,EAEA,MACA,GAAA,OAAAtoC,EAAA,CACA,MAAAY,EAAA0nC,EAAA1nC,SACAA,EAAA4P,OAAA5P,EAAA4P,QAAA/d,MACAqJ,EAAAO,KAAAisC,EAEA,MAEAxsC,EAAAO,KAAAisC,GAIA,OAAAxsC,CACA,CACA,kBAAA0rC,GACA/0C,KAAAqe,cAAA/W,SAAA,SAAA2Y,GACAA,EAAA4uB,SACA,GACA,CAQA,YAAAqC,CAAA8E,GACA,IAAAlwC,EAAAiwC,EACA,IAAAnxC,EAAAoxC,GASA,OAAAA,aAAAviC,GACAm8B,GAAAoG,EAAAh2C,KAAA6vC,YAGA7vC,KAAA6vC,WAAAvqC,OAAAtF,KAAA6vC,WAAA,GAAA,KAXA,IADAmG,EAAAA,EAAAC,oBACAnwC,EAAA,EAAAA,EAAA9F,KAAA6vC,WAAAvqC,OAAAQ,IAEA,GADAiwC,EAAA/1C,KAAA6vC,WAAA/pC,GACAiwC,EAAArrC,QAAAhF,KAAAuwC,sBAAAD,EACA,OAAAD,CAUA,CACA,WAAAjF,CAAAoF,GACA,MAAAzsC,EAAAzJ,KAAAic,SAAAk6B,EAAAD,EAAA3lC,OAAA,GAAA2H,cAAAg+B,EAAA/pC,MAAA,GACA,OAAA/H,EAAAqF,EAAA0sC,IACAn2C,KAAAo2C,gBAAA3sC,EAAA0sC,MAEA1sC,EAAApC,QACA,CACA,MAAA4sB,CAAAvpB,GACA,GAAAA,EAAA,CACA,IACA2rC,EADAC,EAAAt2C,KAAA0K,QAEA1K,KAAAu2C,YAAAtiB,OAAAj0B,KAAAw2C,eAAA9rC,IACA1K,KAAAs0B,oBAAA5pB,EAAA,CAAAvK,EAAAC,EAAAC,EAAAC,MACAN,KAAAic,OAAA,IAAAvH,GAAA4hC,EAAAxvC,EAAAwvC,EAAAtvC,EAAAsvC,EAAArhC,MAAAqhC,EAAAthC,SACAqhC,GAAA,GAEA3rC,EAAAmlC,aACAyG,EAAAzG,WAAAnlC,EAAAmlC,WACA7vC,KAAAy2C,qBAEAH,EAAAz8B,GAAAy8B,EAAA5rC,IACAA,EAAAonB,UAAAukB,IACAr2C,KAAA6zC,UAEAyC,EAAAv+B,SACA/X,KAAA+X,QAAAu+B,EAAAv+B,QAEA,CACA,CACA,iBAAA0+B,GACA,MAAAp4B,EAAAre,KAAAqe,cAGA,IAAA4B,EACAxa,EACA0I,EAJAnO,KAAA6vC,WAAA,GACA7vC,KAAAozC,oBAIA,IAAA,IAAA9nC,EAAA,EAAAA,EAAA+S,EAAA/Y,OAAAgG,IACA2U,EAAA5B,EAAA/S,GACA7F,EAAAwa,EAAAxa,SACA0I,EAAA8R,EAAA9R,SACA1I,EAAAsY,OAAAtY,EAAAsY,QAAA/d,KACAigB,EAAAxa,OAAAzF,KAAAkxC,aAAAzrC,EAAAiF,QAAAhF,OAAA,MAEAyI,EAAA4P,OAAA5P,EAAA4P,QAAA/d,MACAigB,EAAA9R,OAAAnO,KAAAkxC,aAAA/iC,EAAAzD,QAAAhF,OAAA,MAEAua,EAAAuvB,aAEA,CACA,mBAAAlb,CAAA5pB,EAAAgpB,GACA,OAAAD,GAAA9uB,KAAA3E,KAAA0K,EAAAgpB,EACA,CACA,cAAA8iB,CAAA9rC,GACA,MAAA,CACAiU,KAAAjU,EAAAksB,KACAnxB,OAAAiF,EAAAjF,OACAuwB,MAAAtrB,EAAAsrB,MACArM,KAAAjf,EAAAif,KACA+L,OAAAhrB,EAAAgrB,OAEA,CACA,oBAAAmf,GACA70C,KAAAyd,SACAzd,KAAAyd,QAAA3R,QAAAnJ,EAAA,CAAA8D,KAAAzG,KAAAic,OAAAjc,KAAA20C,QAAApjC,SAEA,CACA,eAAA6kC,CAAA/gC,GACA,MAAAuB,EAAA5W,KAAA4W,SAAAJ,EAAAxW,KAAAic,SAAAjG,UAIA,OAHAY,EAAApD,OACA6B,EAAAuB,OAAAA,EAAApD,MAAAoD,EAAAvP,SAAAsM,KAAA6C,IAEAnB,CACA,CACA,kBAAAk/B,GACA,MAAAt4B,EAAAjc,KAAAic,SAAAzF,EAAAyF,EAAAjG,UAAAU,EAAAuF,EAAA9F,cACA,OAAAzB,GAAAiD,WAAA3X,KAAAyd,QAAAi5B,YAAAlgC,GAAAxW,KAAAyd,QAAAi5B,YAAAhgC,GACA,CACA,cAAAg+B,GACA,MAAAz4B,EAAAjc,KAAAic,SAAA3F,cAAAtW,KAAA4W,SAAApD,OAAAgD,EAAAyF,EAAAjG,UAAAU,EAAAuF,EAAA9F,cACA,OAAAzB,GAAAiD,WAAAnB,EAAAE,EACA,CACA,OAAAm9B,GACA,MAAA/hB,EAAA9xB,KAAA0K,QAAAonB,SACAA,GAAAA,EAAAte,OACAxT,KAAA4W,OAAAkb,EAAAte,OAEAxT,KAAA21C,gBAAA,IAAAliC,EACA,CACA,MAAA4gB,CAAAtwB,GACA,MAAA2G,EAAA1K,KAAA0K,QAAAsrB,EAAAtrB,EAAAsrB,MACA,IAAAN,EAAAhrB,EAAAgrB,OAAA/L,EAAAjf,EAAAif,KACA5lB,GAAAE,EAAA+xB,EAAAN,UACAA,EAAA7b,GAAA,CAAA,EAAA6b,EAAAM,EAAAN,SAEA3xB,GAAAE,EAAA+xB,EAAArM,QACAA,EAAAqM,EAAArM,MAEA3pB,KAAAu2C,YAAAtiB,OAAA,CACAyB,OAAAA,EACA/L,KAAAA,IAEAjf,EAAA8mC,UAAA9mC,EAAA8mC,SAAAznB,SACA/pB,KAAAyd,QAAAk5B,gBAAA32C,KAAA+D,EAEA,CACA,QAAA2uC,CAAA3uC,GACA,GAAA/D,KAAA0vB,UAAA,CACA,MAAAzT,EAAAjc,KAAAic,SAAAzI,EAAAxT,KAAA4W,SAAApD,MACA,IAAAojC,EACA,GAAA7yC,EAAAoB,UAAApB,EAAAoB,UACA,OAAAurB,GAAAI,MAAA/sB,EAAAkY,EAAAzI,GAAA,GAIA,GADAojC,EAAA7yC,EAAAwN,QAAAqF,OAAApD,EAAAyI,EAAA5U,UACA4U,EAAAhU,SAAA2uC,GACA,OAAA52C,IAGA,CACA,CACA,MAAA+wC,GACA,MAAA,CACAC,QAAAhxC,KAAA0K,QAAAoH,GAEA,CACA,iBAAAohC,GACA,MAAAxoC,EAAA1K,KAAA0K,QACAmsC,EAAA72C,KAAAw2C,eAAA9rC,GACAosC,EAAApsC,EAAAwT,OACA3Q,GAAA7C,EAAA6C,KAAA,IAAA0oC,oBACA,IAAAM,EACAM,EAAA5hC,MAAAvK,EAAAuK,MACA4hC,EAAA7hC,OAAAtK,EAAAsK,OACA5Q,EAAA0yC,GACAP,EAAAO,EAAAnyC,KAAA3E,KAAA0K,GAEAmsC,EAAAl4B,MACA43B,EAAA,IAAAla,GAAAwa,GArtBA,SAAA34B,GACA,MAAAi2B,EAAAj2B,EAAA8V,mBAAAkE,YAAA,MACA,IAAAic,EAAAtkC,OAAA/I,GAAA,IAAAqtC,EAAAtkC,OAAA7I,GACAkX,EAAA/U,UAAAgrC,EAAAtkC,OAAA/I,GAAAqtC,EAAAtkC,OAAA7I,EAEA,CAitBA+vC,CAAAR,IAGAA,EADA,cAAAhpC,EACA,IAAAyvB,GAAA6Z,GAEA,WAAAtpC,EACA,IAAA4rB,GAAA0d,GAEA,SAAAtpC,EACA,IAAAiwB,GAAAqZ,GAEA,UAAAtpC,EACA,IAAAktB,GAAAoc,GAGA,IAAAxa,GAAAwa,GAEA72C,KAAAu2C,YAAAA,EACAv2C,KAAAke,OAAAma,OAAAr4B,KAAAu2C,YACA,EAGA,MAAAS,WAAArI,GACA,WAAAlkC,CAAAwV,EAAAvV,GACAA,EAAAmP,GAAA,CAAAo9B,QAAA,CAAA,GAAAvsC,GACAwH,MAAA+N,EAAAxC,QAAA/S,GACA1K,KAAAigB,WAAAA,EACA,MAAAxC,EAAAzd,KAAAigB,WAAAxC,QACAzd,KAAAk3C,IAAAz5B,EAAA05B,YACA,MAAAC,EAAAp3C,KAAAigB,WAAAo3B,cACAC,EAAAt3C,KAAAigB,WAAAs3B,cACAv3C,KAAAw3C,SAAA,IAAAre,GAAAtf,GAAA7Z,KAAA0K,QAAAusC,QAAA,CAAA5vC,OAAA+vC,KACAp3C,KAAAy3C,SAAA,IAAAte,GAAAtf,GAAA7Z,KAAA0K,QAAAusC,QAAA,CAAA5vC,OAAAiwC,KACAt3C,KAAAke,OAAAma,OAAAr4B,KAAAw3C,UACAx3C,KAAAke,OAAAma,OAAAr4B,KAAAy3C,SACA,CACA,UAAAvF,GACA,OAAA9wC,EAAAK,IACA,CACA,KAAAkF,CAAAgH,GAKA,OAJA3N,KAAA03C,OAAA13C,KAAA0yC,SAAA/kC,GACA3N,KAAA40B,WAAAjnB,EACA3N,KAAA23C,eAAA33C,KAAAigB,WAAAxa,SACAzF,KAAA43C,eAAA53C,KAAAigB,WAAA9R,SACAnO,KAAA03C,QACA,KAAA,EACA13C,KAAAigB,WAAA6P,iBACA9vB,KAAAk3C,IAAAW,wBAAA73C,KAAAigB,WAAAjgB,KAAAigB,WAAA6P,gBAAA/R,OAEA,MACA,KAAA,EACA/d,KAAAigB,WAAA2P,iBACA5vB,KAAAk3C,IAAAW,wBAAA73C,KAAAigB,WAAAjgB,KAAAigB,WAAA2P,gBAAA7R,OAMA,CACA,IAAAtc,CAAAi2C,EAAA/pC,GACA,OAAA+pC,GACA,KAAA,EACA13C,KAAAigB,WAAAxa,OAAAkI,GACA,MACA,KAAA,EACA3N,KAAAigB,WAAA9R,OAAAR,GACA,MACA,QAAA,CACA,MAAAyJ,EAAAzJ,EAAAiG,MAAA5T,KAAA40B,YACA50B,KAAA40B,WAAAjnB,EACA3N,KAAAigB,WAAA2P,iBACA5vB,KAAAigB,WAAAxa,OAAAzF,KAAAigB,WAAAo3B,cAAA1jC,KAAAyD,IAEApX,KAAAigB,WAAA6P,iBACA9vB,KAAAigB,WAAA9R,OAAAnO,KAAAigB,WAAAs3B,cAAA5jC,KAAAyD,IAEA,KACA,EAGA,OADApX,KAAA6uC,WACA,CACA,CACA,IAAAn/B,CAAA/B,GACA,MAAAmqC,EAAA93C,KAAAyd,QAAA05B,YAAA1wC,EAAAqxC,EAAAC,YACA,IAAA5pC,EAkBA,OAhBAA,EADA2pC,EAAAE,kBACAF,EAAAE,kBAAAC,GAEAxxC,GAAAA,aAAAusC,GACAvsC,EAAAyqC,aAAAhvC,IAAAuE,EAAAyqC,aAAAvjC,GAGAA,GAEA,IAAA3N,KAAA03C,OACA13C,KAAAigB,WAAAxa,OAAA0I,GAEA,IAAAnO,KAAA03C,QACA13C,KAAAigB,WAAA9R,OAAAA,GAEAnO,KAAA03C,YAAA/uC,EACA3I,KAAAk3C,IAAAW,0BACA,IAAA/I,GAAA9uC,KAAAigB,WAAAjgB,KAAA23C,eAAA33C,KAAA43C,eACA,CACA,QAAAlF,CAAAr9B,GACA,MAAAgiC,EAAAr3C,KAAAigB,WAAAo3B,cACAE,EAAAv3C,KAAAigB,WAAAs3B,cACAW,EAAAl4C,KAAA0K,QAAAusC,QAAAhiC,MAAA,EAAAhT,EACAk2C,EAAAn4C,KAAA0K,QAAAusC,QAAAjiC,OAAA,EAAA/S,EACAm2C,EAAAf,EAAArH,WAAA36B,GACAgjC,EAAAd,EAAAvH,WAAA36B,GACAijC,EAAA,IAAA5jC,GAAA2iC,EAAAvwC,EAAAuwC,EAAArwC,GAAA2N,QAAAujC,EAAAC,GAAAlwC,SAAAoN,GACAkjC,EAAA,IAAA7jC,GAAA6iC,EAAAzwC,EAAAywC,EAAAvwC,GAAA2N,QAAAujC,EAAAC,GAAAlwC,SAAAoN,GACA,IAAAqiC,EAAA,EAOA,OANAY,KAAAC,GAAAH,EAAAC,GACAX,GAAA,EAEAa,KAAAD,GAAAD,EAAAD,KACAV,EAAA,GAEAA,CACA,CACA,OAAA7I,GACA7uC,KAAAw3C,SAAAvjB,OAAA,CAAA5sB,OAAArH,KAAAyd,QAAA+6B,aAAAx4C,KAAAigB,WAAAo3B,iBACAr3C,KAAAy3C,SAAAxjB,OAAA,CAAA5sB,OAAArH,KAAAyd,QAAA+6B,aAAAx4C,KAAAigB,WAAAs3B,gBACA,EAGA,MAAAkB,GACA,WAAAhuC,CAAAklC,GACA3vC,KAAA0K,QAAAmP,GAAA,CAAA,EAAA81B,EAAAjlC,SACA1K,KAAAi4C,GAAAtI,EACA3vC,KAAAke,OAAA,IAAAib,GAAAn5B,KAAA0K,SACA1K,KAAA6uC,SACA,CACA,MAAAxa,CAAAtwB,GACA,MAAA2G,EAAA1K,KAAA0K,QAAAsrB,EAAAtrB,EAAAsrB,MACA,IAAAN,EAAAhrB,EAAAgrB,OAAA/L,EAAAjf,EAAAif,KACA5lB,GAAAE,EAAA+xB,EAAAN,UACAA,EAAA7b,GAAA,CAAA,EAAA6b,EAAAM,EAAAN,SAEA3xB,GAAAE,EAAA+xB,EAAArM,QACAA,EAAAqM,EAAArM,MAEA3pB,KAAAke,OAAA+V,OAAA,CACAyB,OAAAA,EACA/L,KAAAA,GAEA,CACA,OAAAklB,GACA,MAAAlhC,EAAA3N,KAAAi4C,GAAAl6B,MAAAN,QAAAi5B,YAAA12C,KAAAi4C,GAAA9uC,YAAAuvC,EAAA/qC,EAAAiG,MAAA5T,KAAAi4C,GAAAl6B,MAAA9B,OAAA,eAAAjG,WAAAjS,EAAA,IAAA2Q,GAAA/G,EAAA7G,EAAA6G,EAAA3G,EAAA,EAAA,GACAjD,EAAA4Q,QAAA3U,KAAA0K,QAAAuK,MAAA,EAAAjV,KAAA0K,QAAAsK,OAAA,GACAhV,KAAA24C,cAAA50C,EACA/D,KAAAke,OAAA+V,OAAA,CAAA5sB,OAAA,IAAAoM,GAAAilC,EAAA5xC,EAAA4xC,EAAA1xC,IACA,CACA,QAAA0rC,CAAA/kC,GACA,MAAA2pC,EAAAt3C,KAAAi4C,GAAAl6B,MAAAN,QAAAi5B,YAAA/oC,GACA,OAAA3N,KAAA24C,cAAA1wC,SAAAqvC,EACA,EAGA,MAAAsB,WAAAjK,GACA,WAAAlkC,CAAAgT,EAAA/S,GACAwH,MAAAuL,EAAA/S,GACA1K,KAAA64C,gBAAA7sC,IACAA,EAAAvF,OAAAzG,KAAA+d,OACA/d,KAAA6uC,SACA,CAEA,CACA,IAAA9Y,CAAAhY,GACA/d,KAAA84C,UAAA,EACA94C,KAAA+d,MAAAA,EACA/d,KAAAyd,QAAA3U,KAAAnG,EAAA3C,KAAA64C,iBACA74C,KAAA6vC,WAAA,GACA7vC,KAAA+4C,eACA,MAAA3nC,EAAA2M,EAAA8xB,WAAAvqC,OACA,IAAA,IAAAQ,EAAA,EAAAA,EAAAsL,EAAAtL,IAAA,CACA,MAAAiwC,EAAA,IAAA0C,GAAA16B,EAAA8xB,WAAA/pC,IACA9F,KAAA6vC,WAAAjmC,KAAAmsC,GACA/1C,KAAAke,OAAAma,OAAA0d,EAAA73B,OACA,CACAle,KAAAke,OAAAwR,SAAA,GACA1vB,KAAA6uC,SACA,CACA,YAAAkK,GACA/4C,KAAAyd,QAAAu7B,mBACAh5C,KAAAi5C,yBAGAj5C,KAAAke,OAAA5U,OAEA,CACA,sBAAA2vC,GACA,MAAAC,EAAAl5C,KAAAke,OAAAgB,SACAi6B,EAAAD,EAAA5zC,OACAmd,EAAAta,GAAAnI,KAAAyd,QAAAu7B,mBAAAE,GACA,IAAA,IAAApzC,EAAAqzC,EAAA,EAAArzC,GAAA,EAAAA,IACAA,IAAA2c,GAGAziB,KAAAke,OAAAtW,OAAAsxC,EAAApzC,GAEA,CACA,OAAA+E,GACA7K,KAAAyd,QAAA3S,OAAAnI,EAAA3C,KAAA64C,iBACA74C,KAAA+d,WAAApV,EACA3I,KAAA84C,cAAAnwC,EACA3I,KAAAke,OAAAwR,SAAA,EACA,CACA,QAAAgjB,CAAA/kC,GACA,IAAAooC,EAAAjwC,EACA,IAAAA,EAAA,EAAAA,EAAA9F,KAAA6vC,WAAAvqC,OAAAQ,IAEA,GADAiwC,EAAA/1C,KAAA6vC,WAAA/pC,GACAiwC,EAAArD,SAAA/kC,GAAA,CACAooC,EAAA1hB,QAAA,GACAr0B,KAAAyd,QAAA05B,YAAAa,kBAAAjC,EACA,KACA,CAEA,CACA,OAAAlH,GACA,GAAA7uC,KAAA+d,MAAA,CACA,IAAA9B,EAAAjc,KAAA+d,MAAA9B,SACAA,EAAAjc,KAAAyd,QAAA+6B,aAAAv8B,GACAjc,KAAAke,OAAA/U,SAAA8S,EAAAjG,WACAhW,KAAA6vC,WAAAvoC,SAAA,SAAAyuC,GACAA,EAAAlH,SACA,GACA,CACA,EAGA,SAAAuK,GAAAlwC,GACA,MAAAsoC,EAAAtoC,EAAAwB,QAAA8mC,SACA,OAAAA,IAAA,IAAAA,EAAA6H,IACA,CAOA,MAAAC,GACA,WAAA7uC,CAAA2T,EAAAm7B,EAAAlJ,GACArwC,KAAAoe,OAAAA,EACApe,KAAAu5C,WAAAA,EACAv5C,KAAAqvC,MAAA,iBACArvC,KAAAw5C,WAAA,GACAx5C,KAAAqwC,QAAAA,EACA,IAAA,IAAAvqC,EAAA,EAAAA,EAAA9F,KAAAoe,OAAA9Y,OAAAQ,IAAA,CACA,MAAAiY,EAAA/d,KAAAoe,OAAAtY,GACA9F,KAAAw5C,WAAA5vC,KAAAmU,EAAA9B,SACA,CACA,CACA,IAAAqzB,GACA,IAAA,IAAAxpC,EAAA,EAAAA,EAAA9F,KAAAoe,OAAA9Y,OAAAQ,IAAA,CACA,MAAAiY,EAAA/d,KAAAoe,OAAAtY,GACAiY,EAAA9B,OAAAjc,KAAAu5C,WAAAzzC,IACA,WAAAiY,GACAA,EAAA2N,OAAA3N,EAAA/d,KAAAw5C,WAAA1zC,GAAA9F,KAAAu5C,WAAAzzC,IAEAiY,EAAAyxB,aACA,CACAxvC,KAAAqwC,UACArwC,KAAAqwC,QAAAoJ,gBACAz5C,KAAAqwC,QAAAxB,UAEA,CACA,IAAAY,GACA,IAAA,IAAA3pC,EAAA,EAAAA,EAAA9F,KAAAoe,OAAA9Y,OAAAQ,IAAA,CACA,MAAAiY,EAAA/d,KAAAoe,OAAAtY,GACAiY,EAAA9B,OAAAjc,KAAAw5C,WAAA1zC,IAEA,WAAAiY,GACAA,EAAA2N,OAAA3N,EAAA/d,KAAAu5C,WAAAzzC,GAAA9F,KAAAw5C,WAAA1zC,IAEAiY,EAAAyxB,aACA,CACAxvC,KAAAqwC,UACArwC,KAAAqwC,QAAAoJ,gBACAz5C,KAAAqwC,QAAAxB,UAEA,EA+BA,MAAA6K,GAAA,CACAzC,QAAA,CACAttB,KAAA,CACAW,MAAA,QAEAoL,OAAA,CACApL,MAAA,WAEAtV,OAAA,EACAC,MAAA,EACA+gB,MAAA,CACArM,KAAA,CACAW,MAAA,WAEAoL,OAAA,CACApL,MAAA,aAIAsnB,WAAA,CACAlc,OAAA,CACApL,MAAA,UACArV,MAAA,EACAihB,SAAA,QAEAvM,KAAA,CACAW,MAAA/pB,IAGAsT,OAAA,IAEA,MAAA8lC,WAAAhL,GACA,WAAAlkC,CAAAgT,EAAA/S,GAEAwH,MAAAuL,EADA/S,EAAAmP,GAAA,CAAA,EAAA6/B,GAAAhvC,IAEA1K,KAAA45C,eAAA,EACA55C,KAAA4iB,IAAA,GACA5iB,KAAAoe,OAAA,GACApe,KAAA65C,iBACA75C,KAAA85C,iBACA95C,KAAAi0B,SACAj0B,KAAAyd,QAAA3U,KAAA,UAAA,KACA9I,KAAA2wC,aAAA,IAEA3wC,KAAA64C,gBAAA,KACA74C,KAAA+5C,kBACA/5C,KAAAy5C,gBACAz5C,KAAA6uC,UACA,EAEA7uC,KAAAg6C,gBAAA,KACA,IAAAh6C,KAAAoe,OAAA9Y,SACAtF,KAAAywC,OAAAzwC,KAAAoe,OAAA,GAAAxH,SAAApD,OAEAxT,KAAA64C,iBAAA,EAEA74C,KAAAyd,QAAA3U,KAAAnG,EAAA3C,KAAA64C,iBAAA/vC,KAAApG,EAAA1C,KAAAg6C,iBACAh6C,KAAAy5C,gBACAz5C,KAAA6uC,SACA,CACA,cAAAgL,GACA,MACAjI,EADA5xC,KAAAyd,QACA/S,QAAAknC,WACAlnC,EAAAmP,GAAA,CAAA,EAAA7Z,KAAA0K,QAAAknC,WAAAA,GACA5xC,KAAAqW,KAAA,IAAA2mB,GAAAtyB,GACA1K,KAAAke,OAAAma,OAAAr4B,KAAAqW,KACA,CACA,UAAA4jC,GACA,OAAAj6C,KAAA0K,QAAA8mC,WAAA,IAAAxxC,KAAA0K,QAAA8mC,SAAA0I,MACA,CACA,cAAAC,GACA,OAAAn6C,KAAA0K,QAAA8mC,SAAA0I,QAAA,CAAA,GAAAjD,SAAAj3C,KAAA0K,QAAAusC,OACA,CACA,cAAA6C,GACA,IAAA7C,EAAAxwC,EAAAO,EAAAF,EACA,GAAA9G,KAAAi6C,aAEA,IADAhD,EAAAj3C,KAAAm6C,iBACArzC,GAAA,EAAAA,GAAA,EAAAA,IACA,IAAAE,GAAA,EAAAA,GAAA,EAAAA,IACA,IAAAF,GAAA,IAAAE,IACAP,EAAA,IAAAu2B,GAAAia,GACAxwC,EAAAytB,eAAAG,OAAAr0B,KAAAq0B,OAAAvrB,KAAA9I,MACAA,KAAA4iB,IAAAhZ,KAAA,CAAA9C,EAAAA,EAAAE,EAAAA,EAAAkX,OAAAzX,IACAzG,KAAAke,OAAAma,OAAA5xB,GAKA,CACA,MAAAwV,CAAAlY,GACA,IAAAA,EAKA,OAAA/D,KAAA20C,QAJA30C,KAAA0wC,aAAA3sC,EAAAwN,QACAvR,KAAA20C,QAAA30C,KAAAyd,QAAA+6B,aAAAz0C,GAAA4Q,QAAA3U,KAAA0K,QAAAmJ,OAAA7T,KAAA0K,QAAAmJ,OAKA,CACA,QAAA6+B,CAAA/kC,GACA,MAAAysC,EAAAp6C,KAAA4iB,IAAAtd,OACA,IAAAQ,EAAAu0C,EAAAC,EAAA5C,EAAAJ,EAAAt3C,KAAAyd,QAAA+6B,aAAA7qC,GAIA,GAHA3N,KAAAywC,SACA6G,EAAAA,EAAA/lC,QAAAqF,OAAA5W,KAAAywC,OAAAzwC,KAAA20C,QAAAttC,WAEArH,KAAAi6C,aACA,IAAAn0C,EAAA,EAAAA,EAAAs0C,EAAAt0C,IAKA,GAJA4xC,EAAA13C,KAAA4iB,IAAA9c,GACAu0C,EAAA,IAAA5mC,GAAAikC,EAAA5wC,EAAA4wC,EAAA1wC,GACAszC,EAAAt6C,KAAAu6C,iBAAAF,GACAC,EAAAzmC,OAAA7T,KAAA20C,QAAA7tC,EAAA9G,KAAA20C,QAAA3tC,GACAszC,EAAAryC,SAAAqvC,GACA,OAAA+C,EAIA,GAAAr6C,KAAA20C,QAAA1sC,SAAAqvC,GACA,OAAA,IAAA7jC,GAAA,EAAA,EAEA,CACA,gBAAA8mC,CAAA5sC,GACA,GAAA3N,KAAAi6C,aAAA,CACA,MAAAhD,EAAAj3C,KAAAm6C,iBAAAv5B,EAAAq2B,EAAAhiC,MAAAlG,EAAAkoC,EAAAjiC,OAAAzB,EAAA,IAAAmB,GAAA,EAAA,EAAAkM,EAAA7R,GAmBA,OAlBApB,EAAA7G,EAAA,EACAyM,EAAAzM,GAAA8Z,EAAA,EAEA,IAAAjT,EAAA7G,EACAyM,EAAAzM,EAAA9F,KAAAmF,MAAAnG,KAAA20C,QAAA1/B,MAAA,GAAA2L,EAAA,EAEAjT,EAAA7G,EAAA,IACAyM,EAAAzM,EAAA9G,KAAA20C,QAAA1/B,MAAA,EAAA2L,EAAA,GAEAjT,EAAA3G,EAAA,EACAuM,EAAAvM,GAAA+H,EAAA,EAEA,IAAApB,EAAA3G,EACAuM,EAAAvM,EAAAhG,KAAAmF,MAAAnG,KAAA20C,QAAA3/B,OAAA,GAAAjG,EAAA,EAEApB,EAAA3G,EAAA,IACAuM,EAAAvM,EAAAhH,KAAA20C,QAAA3/B,OAAA,EAAAjG,EAAA,GAEAwE,CACA,CACA,CACA,UAAA2+B,CAAA78B,GACA,IAAAglC,EAAAr6C,KAAA0yC,SAAAr9B,GACA,GAAAglC,GAAAA,EAAAvzC,IAAA,GAAAuzC,EAAAvzC,GAAA,GAAAuzC,EAAArzC,IAAA,GAAAqzC,EAAArzC,GAAA,GAAAhH,KAAAi6C,aAAA,CACA,MAAAzmC,EAAAxT,KAAAywC,OAKA,GAJAj9B,IACA6mC,EAAAzjC,OAAApD,EAAA,IAAAC,GAAA,EAAA,IACA4mC,EAAA,IAAA5mC,GAAAzS,KAAAwP,MAAA6pC,EAAAvzC,GAAA9F,KAAAwP,MAAA6pC,EAAArzC,MAEA,IAAAqzC,EAAAvzC,IAAA,IAAAuzC,EAAArzC,EACA,MAAA,YAEA,GAAA,IAAAqzC,EAAAvzC,GAAA,IAAAuzC,EAAArzC,EACA,MAAA,YAEA,IAAA,IAAAqzC,EAAAvzC,GAAA,IAAAuzC,EAAArzC,EACA,MAAA,YAEA,GAAA,IAAAqzC,EAAAvzC,IAAA,IAAAuzC,EAAArzC,EACA,MAAA,YAEA,GAAA,IAAAqzC,EAAAvzC,IAAA,IAAAuzC,EAAArzC,EACA,MAAA,WAEA,GAAA,IAAAqzC,EAAAvzC,GAAA,IAAAuzC,EAAArzC,EACA,MAAA,WAEA,GAAA,IAAAqzC,EAAAvzC,GAAA,IAAAuzC,EAAArzC,EACA,MAAA,WAEA,IAAA,IAAAqzC,EAAAvzC,GAAA,IAAAuzC,EAAArzC,EACA,MAAA,UAEA,CACA,OAAAhH,KAAA45C,cAAAx4C,EAAAK,KAAAL,EAAAM,MACA,CACA,WAAAivC,GACA,IAAA7qC,EAAAW,EACA,MAAA+zC,EAAAx6C,KAAAyd,QAAA/b,SAEA,IADA1B,KAAAoe,OAAA,GACAtY,EAAA,EAAAA,EAAA00C,EAAAl1C,OAAAQ,IACAW,EAAA+zC,EAAA10C,GACAW,aAAAusC,KACAhzC,KAAAoe,OAAAxU,KAAAnD,GACAA,EAAAkvC,gBAAA,IAAAliC,IAGAzT,KAAAywC,OAAA,IAAAzwC,KAAAoe,OAAA9Y,OAAAtF,KAAAoe,OAAA,GAAAxH,SAAApD,MAAA,EACAxT,KAAAy6C,YAAAz6C,KAAAywC,OACAzwC,KAAA06C,WACA16C,KAAA26C,aACA36C,KAAAy5C,gBACAz5C,KAAA6uC,UACA7uC,KAAAi0B,QACA,CACA,QAAAymB,GACA,IAAA50C,EAAAiY,EAEA,IADA/d,KAAA46C,eAAA,GACA90C,EAAA,EAAAA,EAAA9F,KAAAoe,OAAA9Y,OAAAQ,IACAiY,EAAA/d,KAAAoe,OAAAtY,GACA9F,KAAA46C,eAAAhxC,KAAAmU,EAAAnH,SAAApD,MAEA,CACA,UAAAmnC,GACA,IAAA70C,EAAAiY,EAEA,IADA/d,KAAA66C,cAAA,GACA/0C,EAAA,EAAAA,EAAA9F,KAAAoe,OAAA9Y,OAAAQ,IACAiY,EAAA/d,KAAAoe,OAAAtY,GACA9F,KAAA66C,cAAAjxC,KAAAmU,EAAA9B,SAEA,CACA,MAAAoY,CAAAtwB,EAAAmF,GACA,GAAAlJ,KAAAi6C,aAAA,CACA,MAAAa,EAAA96C,KAAAm6C,iBAAAnkB,EAAA8kB,EAAA9kB,MACA,IAAAN,EAAAolB,EAAAplB,OAAA/L,EAAAmxB,EAAAnxB,KACA5lB,GAAAE,EAAA+xB,EAAAN,UACAA,EAAA7b,GAAA,CAAA,EAAA6b,EAAAM,EAAAN,SAEA3xB,GAAAE,EAAA+xB,EAAArM,QACAA,EAAAqM,EAAArM,MAEAzgB,EAAAwsB,OAAAA,EAAApL,MAAAoL,EAAAzgB,MAAAygB,EAAAE,SACA1sB,EAAAygB,KAAAA,EAAAW,MAAAX,EAAAiM,QACA,CACA,CACA,KAAAjvB,CAAAgH,GACA3N,KAAA+6C,IAAAptC,EACA3N,KAAAg7C,IAAArtC,EACA3N,KAAAi7C,IAAAttC,EACA3N,KAAA45C,eAAA,EACA55C,KAAA+5C,iBAAA,EACA/5C,KAAAk7C,YAAA,GACA,IAAA,IAAAp1C,EAAA,EAAAA,EAAA9F,KAAAoe,OAAA9Y,OAAAQ,IAAA,CACA,MAAAiY,EAAA/d,KAAAoe,OAAAtY,GACA9F,KAAAk7C,YAAAtxC,KAAAmU,EAAA9B,SACA,CACA,CACA,MAAAgY,GACA,IAAAnuB,EAAA4xC,EACA,MAAAyD,EAAAn7C,KAAAi6C,aACA,IAAAn0C,EAAA,EAAAA,EAAA9F,KAAA4iB,IAAAtd,OAAAQ,IACA4xC,EAAA13C,KAAA4iB,IAAA9c,GACA4xC,EAAAx5B,OAAAwR,QAAAyrB,EAEA,CACA,KAAA3nC,CAAAzP,GAIA,OAHAI,EAAAJ,KACA/D,KAAAywC,OAAA1sC,GAEA/D,KAAAywC,MACA,CACA,MAAA75B,GACA,MAAAvP,EAAArH,KAAA0wC,aAAArpC,SACA,IAAA+zC,EAAAp7C,KAAAwT,QACAxT,KAAA+5C,iBAAA,EACA,IAAA,IAAAj0C,EAAA,EAAAA,EAAA9F,KAAAoe,OAAA9Y,OAAAQ,IAAA,CACA,MAAAiY,EAAA/d,KAAAoe,OAAAtY,GACAs1C,GAAAA,EAAAp7C,KAAA46C,eAAA90C,GAAA9F,KAAAy6C,aAAA,IACA18B,EAAAnH,OAAAwkC,EAAA/zC,EACA,CACArH,KAAA6uC,SACA,CACA,IAAAptC,CAAAi2C,EAAA/pC,GACA,IAAAyJ,EAAAikC,EAAAp/B,EAAA5U,EAAA0W,EAAAjY,EAAA0N,EAAA8nC,EAAAC,EAAAxkC,EAAAC,EAAAwkC,EAAA,IAAA/nC,GAAAgoC,EAAA,IAAAhoC,GAAAioC,EAAA,EACA,IAAA,IAAAhE,EAAA1wC,IAAA,IAAA0wC,EAAA5wC,EAAA,CAGA,IAFAO,EAAArH,KAAA0wC,aAAArpC,SACArH,KAAAywC,OAAAzwC,KAAA27C,eAAAv0C,GAAAC,EAAAsG,IACA7H,EAAA,EAAAA,EAAA9F,KAAAoe,OAAA9Y,OAAAQ,IACAiY,EAAA/d,KAAAoe,OAAAtY,GACA0N,GAAAxT,KAAAywC,OAAAzwC,KAAA46C,eAAA90C,GAAA9F,KAAAy6C,aAAA,IACA18B,EAAAnH,OAAApD,EAAAnM,GACA9C,OAAAM,UAAAH,eAAAC,KAAAoZ,EAAA,WACAA,EAAA2N,OAAA3N,GAEA/d,KAAA47C,WAAA,EAEA57C,KAAA6uC,SACA,KACA,CACA,GAAA7uC,KAAA67C,aAAA,CACA,MAAAC,EAAA97C,KAAA+7C,kBAAApuC,EAAAiG,MAAA5T,KAAAi7C,MAEA,GAAA,IAAAa,EAAAh1C,GAAA,IAAAg1C,EAAA90C,EAEA,YADAhH,KAAAg7C,IAAArtC,GAGAyJ,EAAA0kC,EACA97C,KAAAi7C,IAAA,IAAAxnC,GAAAzT,KAAAi7C,IAAAn0C,EAAAg1C,EAAAh1C,EAAA9G,KAAAi7C,IAAAj0C,EAAA80C,EAAA90C,EACA,MAEAoQ,EAAAzJ,EAAAiG,MAAA5T,KAAAg7C,KA4BA,IA1BAh7C,KAAAg8C,aAAAtE,IACA+D,EAAAD,EAAApkC,EACAikC,GAAA,IAGAr7C,KAAAywC,QACAr5B,EAAAR,OAAA5W,KAAAywC,OAAA,IAAAh9B,GAAA,EAAA,KAEA,IAAAikC,EAAA5wC,EACA00C,EAAA10C,EAAAsQ,EAAAtQ,EAEA,IAAA4wC,EAAA5wC,IACA20C,EAAA30C,EAAAsQ,EAAAtQ,IAEA,IAAA4wC,EAAA1wC,EACAw0C,EAAAx0C,EAAAoQ,EAAApQ,EAEA,IAAA0wC,EAAA1wC,IACAy0C,EAAAz0C,EAAAoQ,EAAApQ,IAGAq0C,IACAE,EAxVA,SAAAlB,EAAAp+B,GACA,IAAA5S,EAyBA,OAxBA,IAAAgxC,EAAAvzC,IAAA,IAAAuzC,EAAArzC,EACAqC,EAAA4S,EAAA9F,cAEA,IAAAkkC,EAAAvzC,GAAA,IAAAuzC,EAAArzC,EACAqC,EAAA4S,EAAAjG,WAEA,IAAAqkC,EAAAvzC,GAAA,IAAAuzC,EAAArzC,EACAqC,EAAA4S,EAAAhG,WAEA,IAAAokC,EAAAvzC,IAAA,IAAAuzC,EAAArzC,EACAqC,EAAA4S,EAAA/F,aAEA,IAAAmkC,EAAAvzC,IAAA,IAAAuzC,EAAArzC,EACAqC,EAAA4S,EAAAnG,SAEA,IAAAukC,EAAAvzC,GAAA,IAAAuzC,EAAArzC,EACAqC,EAAA4S,EAAArG,MAEA,IAAAykC,EAAAvzC,GAAA,IAAAuzC,EAAArzC,EACAqC,EAAA4S,EAAAlG,QAEA,IAAAskC,EAAAvzC,GAAA,IAAAuzC,EAAArzC,IACAqC,EAAA4S,EAAApG,SAEAxM,CACA,CA6TA4yC,CAAAvE,EAAA13C,KAAA0wC,cACA35B,GAAA/W,KAAA0wC,aAAAz7B,MAAAmC,EAAAtQ,EAAA4wC,EAAA5wC,GAAA9G,KAAA0wC,aAAAz7B,MACA+B,GAAAhX,KAAA0wC,aAAA17B,OAAAoC,EAAApQ,EAAA0wC,EAAA1wC,GAAAhH,KAAA0wC,aAAA17B,QAEAlP,EAAA,EAAAA,EAAA9F,KAAAoe,OAAA9Y,OAAAQ,IAAA,CAGA,GAFAiY,EAAA/d,KAAAoe,OAAAtY,GACAmW,EAAA8B,EAAA9B,SACAo/B,EAAA,CACA,IAAAjC,GAAAr7B,GACA,SAEAu9B,EAAAt7C,KAAAk8C,gBAAAjgC,EAAAu/B,EAAAC,EAAAJ,EACA,KACA,CACAC,EAAAr/B,EAAA1K,QACA+pC,EAAAxkC,MAAAC,EAAAC,EAAAukC,EAAAv7C,KAAA0wC,aAAArpC,SAAA0W,EAAAnH,SAAApD,OACA,MAAA2oC,EAAAb,EAAAj0C,SACA80C,EAAAvlC,QAAA5W,KAAAywC,OAAAx0B,EAAA5U,UACAi0C,EAAA,IAAA5mC,GAAAynC,EAAAr1C,EAAAw0C,EAAArmC,MAAA,EAAAknC,EAAAn1C,EAAAs0C,EAAAtmC,OAAA,EAAAsmC,EAAArmC,MAAAqmC,EAAAtmC,OACA,CACA,GAAAsmC,EAAArmC,OAAA8I,EAAArT,QAAA4mC,UAAAgK,EAAAtmC,QAAA+I,EAAArT,QAAA6mC,UAAA,CACA,MAAA6K,EAAAngC,EACA8B,EAAA9B,OAAAq/B,GACA/2C,OAAAM,UAAAH,eAAAC,KAAAoZ,EAAA,WACAA,EAAA2N,OAAA3N,EAAAq+B,EAAAd,GAEAc,EAAAnnC,QAAAqmC,EAAArmC,OAAAmnC,EAAApnC,SAAAsmC,EAAAtmC,QACA+I,EAAAnH,OAAAmH,EAAAnH,SAAApD,OAEAkoC,GAAA,CACA,CACA,CACAA,IACAA,IAAA51C,GACAw1C,EAAAt7C,KAAAk8C,gBAAAl8C,KAAA0wC,aAAA8K,EAAAC,EAAAJ,GACAr7C,KAAAic,OAAAq/B,IAGAt7C,KAAAy5C,gBAEAz5C,KAAA6uC,WAEA7uC,KAAA26C,YACA,CACA36C,KAAAg7C,IAAArtC,CACA,CACA,YAAAquC,CAAAtE,GACA,OAAA,IAAAA,EAAA5wC,GAAA,IAAA4wC,EAAA1wC,CACA,CACA,MAAAq1C,GACA,MAAAj+B,EAAApe,KAAAoe,OACAk+B,EAAAt8C,KAAAk7C,YACA,IAAA,IAAA5vC,EAAA,EAAAA,EAAA8S,EAAA9Y,OAAAgG,IACA8S,EAAA9S,GAAA2Q,OAAAqgC,EAAAhxC,IAEAtL,KAAAy5C,gBACAz5C,KAAA6uC,UACA7uC,KAAA45C,mBAAAjxC,EACA3I,KAAA+5C,qBAAApxC,EACA3I,KAAA47C,eAAAjzC,CACA,CACA,yBAAA4zC,CAAAtgC,GACA,OAAAjc,KAAAyd,QAAA++B,MACAx8C,KAAAyd,QAAA++B,MAAAC,yBAAAxgC,GAEAA,CACA,CACA,qBAAAygC,CAAAzgC,GACA,OAAAjc,KAAAyd,QAAA++B,MACAx8C,KAAAyd,QAAA++B,MAAAG,qBAAA1gC,GAEAA,CACA,CACA,cAAA0/B,CAAAnyC,GACA,MAAAozC,EAAA58C,KAAA68C,cACAC,EAAA97C,KAAAoO,IAAAwtC,EAAAppC,OA10SA,GAAA,GA20SA,OAAAopC,EAAA57C,KAAAmF,MAAAqD,EAAA,IAAAszC,GAAAA,EAAAtzC,EAAA,GACA,CACA,iBAAAuyC,CAAAlvC,GACA,GAAAA,aAAA4G,GACA,OAAA,IAAAA,GAAAzT,KAAA+7C,kBAAAlvC,EAAA/F,GAAA9G,KAAA+7C,kBAAAlvC,EAAA7F,IAEA,CACA,MAAA41C,EAAA58C,KAAA68C,eAAA,CAAA,EACAE,EAAA/7C,KAAAoO,IAAAwtC,EAAAh3C,MAn1SA,GAAA,GAo1SA,OAAAg3C,EAAA57C,KAAAmF,MAAA0G,EAAAkwC,GAAAA,EAAAlwC,CACA,CACA,CACA,WAAAgwC,GAGA,QAFA78C,KAAAyd,QAAA/S,QAAA8mC,UACA,CAAA,GAAA6H,MAAA,CAAA,GAAAuD,MAAA,CAAA,CAEA,CACA,UAAAf,GACA,MAAArK,EAAAxxC,KAAAyd,QAAA/S,QAAA8mC,SACA6H,GAAA7H,GAAA,CAAA,GAAA6H,KACAuD,GAAAvD,GAAA,CAAA,GAAAuD,KACA,OAAA,IAAApL,IAAA,IAAA6H,IAAA,IAAAuD,CACA,CACA,eAAAV,CAAAjgC,EAAAu/B,EAAAC,EAAAJ,GACA,MAAA7kC,EAAAyF,EAAAjG,UAAArC,KAAA6nC,GAAA9kC,EAAAuF,EAAA9F,cAAAxC,KAAA8nC,GACA,IAAAU,EAAAb,EAAA5mC,GAAAiD,WAAAnB,EAAAE,GAMA,OALA2kC,IACAc,EAAAb,EAAAj0C,SACA80C,EAAAvlC,QAAA5W,KAAAywC,OAAAx0B,EAAA5U,UACAi0C,EAAA,IAAA5mC,GAAAynC,EAAAr1C,EAAAw0C,EAAArmC,MAAA,EAAAknC,EAAAn1C,EAAAs0C,EAAAtmC,OAAA,EAAAsmC,EAAArmC,MAAAqmC,EAAAtmC,SAEAsmC,CACA,CACA,IAAA5rC,GACA,IAAAmiB,EAAA/rB,EAAAiY,EACA,GAAA/d,KAAAg7C,MAAAh7C,KAAA+6C,IACA,GAAA/6C,KAAA47C,UACA/pB,EAAA,IAAAue,GAAApwC,KAAAA,KAAAoe,OAAApe,KAAA46C,gBACA56C,KAAA47C,WAAA,OAEA,GAAA57C,KAAAg9C,cAAA,CACA,GAAAh9C,KAAAyd,QAAA++B,MACA,IAAA12C,EAAA,EAAAA,EAAA9F,KAAAoe,OAAA9Y,OAAAQ,IAAA,CACAiY,EAAA/d,KAAAoe,OAAAtY,GACA,IAAAmW,EAAA8B,EAAA9B,SACAA,EAAAjc,KAAA08C,sBAAA18C,KAAAu8C,0BAAAtgC,IACA8B,EAAA9B,OAAAA,GACAjc,KAAAy5C,gBACAz5C,KAAA6uC,SACA,CAEA,IAAA/oC,EAAA,EAAAA,EAAA9F,KAAAoe,OAAA9Y,OAAAQ,IACAiY,EAAA/d,KAAAoe,OAAAtY,GACAiY,EAAAyxB,cAEA3d,EAAA,IAAAynB,GAAAt5C,KAAAoe,OAAApe,KAAAk7C,YAAAl7C,MACAA,KAAAyd,QAAAw/B,mBACA,CAKA,OAHAj9C,KAAA45C,mBAAAjxC,EACA3I,KAAA+5C,qBAAApxC,EACA3I,KAAA47C,eAAAjzC,EACAkpB,CACA,CACA,WAAAmrB,GACA,MAAA5+B,EAAApe,KAAAoe,OACAk+B,EAAAt8C,KAAAk7C,YACA,IAAA,IAAA5vC,EAAA,EAAAA,EAAA8S,EAAA9Y,OAAAgG,IACA,IAAA8S,EAAA9S,GAAA2Q,SAAA7F,OAAAkmC,EAAAhxC,IACA,OAAA,EAGA,OAAA,CACA,CACA,aAAAmuC,GACA,MAAAx9B,EAAA,IAAAjc,KAAAoe,OAAA9Y,OACAtF,KAAAoe,OAAA,GAAAnC,SAAA1K,QACAvR,KAAAyd,QAAA6c,YAAAt6B,KAAAoe,QAAA,GACApe,KAAAic,OAAAA,EACA,CACA,OAAA4yB,GACA,IAAAplC,EAAAwS,EACA,GAAAjc,KAAAoe,OAAA9Y,OAAA,EAAA,CACA2W,EAAAjc,KAAAic,SACAjc,KAAAke,OAAAwR,SAAA,GACA1vB,KAAAke,OAAA/U,SAAA8S,EAAAjG,WACAhW,KAAA4iB,IAAAtb,SAAAwC,IACAL,EAAAzJ,KAAAu6C,iBAAA,IAAA9mC,GAAA3J,EAAAhD,EAAAgD,EAAA9C,IACA8C,EAAAoU,OAAA/U,SAAAM,EAAAuM,UAAA,IAEAhW,KAAAke,OAAA/U,SAAA8S,EAAAjG,WACA,MAAA3O,EAAA,IAAAoM,GAAAwI,EAAAhH,MAAA,EAAAgH,EAAAjH,OAAA,GAGA,GAFAhV,KAAAke,OAAAtH,OAAA5W,KAAAywC,OAAAppC,GACArH,KAAAqW,KAAA4d,OAAA,CAAAhf,MAAAgH,EAAAhH,MAAAD,OAAAiH,EAAAjH,SACAhV,KAAAk9C,cAAA,CACA,MAAAC,EAAAn9C,KAAA0K,QAAA8mC,SAAA56B,OAAAumC,MACAn9C,KAAAo9C,qBAAA,IAAA1oC,GAAAuH,EAAA5U,SAAAP,EAAAmV,EAAAjV,EAAAm2C,EAAAn2C,EAAA,EAAA,GAAA2N,QAAAwoC,EAAAloC,OACAjV,KAAAk9C,cAAAjpB,OAAA,CAAAntB,EAAAmV,EAAAhH,MAAA,EAAAkoC,EAAAloC,MAAA,GACA,CACA,MAEAjV,KAAAke,OAAAwR,SAAA,EAEA,EAGA,MAAA2tB,GAAA,CACA3nB,OAAA,CACApL,MAAA,UACArV,MAAA,EACAihB,SAAA,QAEAvM,KAAA,CACAW,MAAA/pB,IAGA,MAAA+8C,GACA,WAAA7yC,CAAAgT,GACA,MAAAm0B,EAAAn0B,EAAA/S,QAAAknC,WACA5xC,KAAA0K,QAAAmP,GAAA,CAAA,EAAAwjC,GAAAzL,GACA5xC,KAAAke,OAAA,IAAA8e,GAAAh9B,KAAA0K,SACA1K,KAAAyd,QAAAA,CACA,CACA,KAAA9W,CAAAgH,GACA3N,KAAA+6C,IAAA/6C,KAAAu9C,IAAA5vC,EACA3N,KAAA6uC,UACA7uC,KAAAyd,QAAA+/B,OAAAx9C,MAAA,EACA,CACA,GAAA4G,GACA5G,KAAA+6C,IAAA/6C,KAAAu9C,SAAA50C,EACA3I,KAAAyd,QAAA+/B,OAAAx9C,MAAA,EACA,CACA,MAAAic,CAAAlY,GAIA,OAHAA,IACA/D,KAAA20C,QAAA5wC,GAEA/D,KAAA20C,OACA,CACA,IAAAlzC,CAAAkM,GACA3N,KAAAu9C,IAAA5vC,EACA3N,KAAA6uC,SACA,CACA,OAAAA,GACA,GAAA7uC,KAAA+6C,IAAA,CACA,MAAA0C,EAAA/oC,GAAAiD,WAAA3X,KAAAyd,QAAA+6B,aAAAx4C,KAAA+6C,KAAA/6C,KAAAyd,QAAA+6B,aAAAx4C,KAAAu9C,MACAv9C,KAAAic,OAAAvH,GAAAiD,WAAA3X,KAAA+6C,IAAA/6C,KAAAu9C,MACAv9C,KAAAke,OAAA/U,SAAAs0C,EAAAznC,WACAhW,KAAAke,OAAA+V,OAAA,CAAAjf,OAAAyoC,EAAAzoC,OAAA,EAAAC,MAAAwoC,EAAAxoC,MAAA,GACA,CACA,EAMA,MAAAyoC,GACA,WAAAjzC,GAAA,EAMA,MAAAkzC,WAAAD,GACA,WAAAjzC,CAAAwV,GACA/N,QACAlS,KAAAigB,WAAAA,CACA,CAIA,OAAA29B,CAAAjwC,GAEA,QADA3N,KAAA69C,YAAAlpC,QAAA1S,GACAgG,SAAA0F,IAGA8E,GAAAS,mBAAAvF,EAAA3N,KAAAigB,WAAA69B,aAAA77C,CACA,CAMA,SAAA47C,GACA,MAAAl0C,EAAA3J,KAAAigB,WAAA69B,YAAArxC,EAAA9C,EAAA,GAAAqC,EAAArC,EAAAA,EAAArE,OAAA,GACA,IAAAuQ,EAAA7U,KAAAoO,IAAA3C,EAAA3F,EAAAkF,EAAAlF,GAAAiP,EAAA/U,KAAAqO,IAAA5C,EAAA3F,EAAAkF,EAAAlF,GAAA8O,EAAA5U,KAAAqO,IAAA5C,EAAAzF,EAAAgF,EAAAhF,GAAA8O,EAAA9U,KAAAoO,IAAA3C,EAAAzF,EAAAgF,EAAAhF,GACA,IAAA,IAAAlB,EAAA,EAAAA,EAAA6D,EAAArE,OAAA,IAAAQ,EACA+P,EAAA7U,KAAAoO,IAAAyG,EAAAlM,EAAA7D,GAAAgB,GACAiP,EAAA/U,KAAAqO,IAAA0G,EAAApM,EAAA7D,GAAAgB,GACA8O,EAAA5U,KAAAqO,IAAAuG,EAAAjM,EAAA7D,GAAAkB,GACA8O,EAAA9U,KAAAoO,IAAA0G,EAAAnM,EAAA7D,GAAAkB,GAEA,OAAA,IAAA0N,GAAAqB,EAAAH,EAAAC,EAAAE,EAAAD,EAAAF,EACA,EAGA,MAAAI,GAAA,UACAG,GAAA,cACA,MAAA4nC,WAAAJ,GACA,WAAAlzC,CAAAwV,GACA/N,MAAA+N,GACAjgB,KAAAg+C,yBAAA,EACAh+C,KAAAi+C,gBAAA,CAAA,CACAv4C,KAAAvD,EACA+7C,KAAA59C,EACA69C,YAAAnoC,GACAooC,cAAA,GACA,CACA14C,KAAArD,EACA67C,KAAA79C,EACA89C,YAAAnoC,GACAooC,cAAA,GACA,CACA14C,KAAApD,EACA47C,KAAA59C,EACA69C,YAAAhoC,GACAioC,eAAA,GACA,CACA14C,KAAAtD,EACA87C,KAAA79C,EACA89C,YAAAhoC,GACAioC,eAAA,IAEAp+C,KAAAigB,WAAAA,CACA,CACA,WAAAo+B,CAAA13C,EAAAC,EAAAgpB,EAAAE,GACA,IAAAzmB,EAOA,OALAA,EADAumB,GAAAE,EACA9vB,KAAAs+C,iBAAA33C,EAAAC,EAAAgpB,EAAAE,GAGA9vB,KAAAu+C,gBAAA53C,EAAAC,EAAAgpB,GAEAvmB,CACA,CACA,KAAAm1C,GACA,MAAA5uB,EAAA5vB,KAAAigB,WAAAw+B,yBACA3uB,EAAA9vB,KAAAigB,WAAAy+B,yBACA/3C,EAAA3G,KAAAigB,WAAAo3B,cACAzwC,EAAA5G,KAAAigB,WAAAs3B,cACA5tC,EAAA3J,KAAAq+C,YAAA13C,EAAAC,EAAAgpB,EAAAE,GACA9vB,KAAAigB,WAAAtW,OAAAA,EACA,CACA,cAAAg1C,CAAAhP,EAAA4H,GACA,MAAApuC,EAAAwmC,EAAAxmC,WACAy1C,EAAAjP,EAAA5xB,MAAA9B,OAAAhZ,GACAgZ,EAAA,CACAjG,QAAA4oC,EAAA5oC,UACAG,YAAAyoC,EAAAzoC,eAEA0oC,EAAA7+C,KAAAi+C,gBACA,IACAa,EACAC,EACAb,EACAhI,EAJA7mC,EAAA1L,OAAAD,UAKA,IAAA,IAAA4H,EAAA,EAAAA,EAAAuzC,EAAAv5C,OAAAgG,IACA4qC,EAAA2I,EAAAvzC,GACA4yC,EAAAhI,EAAAgI,KACAY,EAAA99C,KAAAwP,MAAAxP,KAAAgD,IAAAmF,EAAA+0C,GAAAjiC,EAAAi6B,EAAAiI,aAAAD,KACAY,EAAAzvC,GACAA,EAAAyvC,EACAC,EAAA7I,GAEA4I,IAAAzvC,IACAlG,EAAA+0C,GAAA3G,EAAA2G,IAAAhI,EAAAkI,eAAAj1C,EAAA41C,EAAAb,MAAA3G,EAAAwH,EAAAb,OAAAa,EAAAX,gBACAW,EAAA7I,GAGA,OAAA6I,EAAAr5C,IACA,CACA,iBAAAs5C,CAAArP,GACA,MAAA1zB,EAAA0zB,EAAA5xB,MAAA9B,OAAAhZ,GACA,OAAAjC,KAAAqO,IAAA4M,EAAAhH,MAAAgH,EAAAjH,QAAAhV,KAAAg+C,wBACA,CACA,gBAAAM,CAAA33C,EAAAC,EAAAgpB,EAAAE,GACA,MAAAmvB,EAAAj/C,KAAA2+C,eAAA/uB,EAAAhpB,GACAs4C,EAAAl/C,KAAA2+C,eAAA7uB,EAAAnpB,GACAoW,EAAAnW,EAAAE,EAAAH,EAAAG,EACAkW,EAAApW,EAAAI,EAAAL,EAAAK,EACAm4C,EAAAn/C,KAAAg/C,kBAAApvB,GACA,IACAwvB,EAAAC,EADAh2C,EAAA,GAwCA,OAtCA41C,IAAA98C,GAAA88C,IAAA38C,EACA48C,IAAA/8C,GAAA+8C,IAAA58C,EACA28C,IAAAC,GAEAG,EADAJ,IAAA98C,EACAnB,KAAAqO,IAAA1I,EAAAK,EAAAJ,EAAAI,GAAAm4C,EAGAn+C,KAAAoO,IAAAzI,EAAAK,EAAAJ,EAAAI,GAAAm4C,EAEA91C,EAAA,CAAA,IAAAoK,GAAA9M,EAAAG,EAAAu4C,GAAA,IAAA5rC,GAAA7M,EAAAE,EAAAu4C,KAGAh2C,EAAA,CAAA,IAAAoK,GAAA9M,EAAAG,EAAAH,EAAAK,EAAAgW,EAAA,GAAA,IAAAvJ,GAAA7M,EAAAE,EAAAH,EAAAK,EAAAgW,EAAA,IAIA3T,EAAA,CAAA,IAAAoK,GAAA9M,EAAAG,EAAAF,EAAAI,IAIAk4C,IAAA78C,GAAA68C,IAAA98C,EACA68C,IAAAC,GAEAE,EADAH,IAAA58C,EACArB,KAAAqO,IAAA1I,EAAAG,EAAAF,EAAAE,GAAAq4C,EAGAn+C,KAAAoO,IAAAzI,EAAAG,EAAAF,EAAAE,GAAAq4C,EAEA91C,EAAA,CAAA,IAAAoK,GAAA2rC,EAAAz4C,EAAAK,GAAA,IAAAyM,GAAA2rC,EAAAx4C,EAAAI,KAGAqC,EAAA,CAAA,IAAAoK,GAAA9M,EAAAG,EAAAiW,EAAA,EAAApW,EAAAK,GAAA,IAAAyM,GAAA9M,EAAAG,EAAAiW,EAAA,EAAApW,EAAAK,EAAAgW,IAIA3T,EAAA,CAAA,IAAAoK,GAAA7M,EAAAE,EAAAH,EAAAK,IAGAqC,CACA,CACA,eAAAk1C,CAAA53C,EAAAC,EAAAgpB,GACA,MAAAqvB,EAAArvB,EAAA5vB,KAAA2+C,eAAA/uB,EAAAhpB,GAAA,KACA04C,EAAAt/C,KAAAu/C,iBAAA54C,EAAAC,EAAAq4C,GACAt1C,EAAA,CAAAhD,EAAAA,EAAAC,EAAAA,GACAmW,EAAAnW,EAAAE,EAAAH,EAAAG,EACAkW,EAAApW,EAAAI,EAAAL,EAAAK,EACA1B,EAAAqE,EAAArE,OACA,IACAk6C,EACAC,EAFAn0C,EAAA,EAIA,KAAAA,EAAAhG,EAAA,IAAAgG,EACAg0C,EACAh0C,EAAA,GAAA,GACAk0C,EAAAziC,GAAAzX,EAAA,GACAm6C,EAAA,IAGAD,EAAA,EACAC,EAAAziC,IAAA1X,EAAA,GAAA,IAIAgG,EAAA,GAAA,GACAk0C,EAAA,EACAC,EAAAziC,GAAA1X,EAAA,KAGAk6C,EAAAziC,IAAAzX,EAAA,GAAA,GACAm6C,EAAA,GAGA91C,EAAA2B,GAAA,IAAAmI,GAAA9J,EAAA2B,EAAA,GAAAxE,EAAA04C,EAAA71C,EAAA2B,EAAA,GAAAtE,EAAAy4C,GAUA,OAPAn0C,IAEA3B,EAAArE,EAAA,GADAg6C,GAAAh0C,EAAA,GAAA,IAAAg0C,GAAAh0C,EAAA,GAAA,EACA,IAAAmI,GAAA9J,EAAArE,EAAA,GAAAwB,EAAA6C,EAAArE,EAAA,GAAA0B,GAGA,IAAAyM,GAAA9J,EAAArE,EAAA,GAAAwB,EAAA6C,EAAArE,EAAA,GAAA0B,GAEA,CAAA2C,EAAA,GAAAA,EAAA,GACA,CACA,gBAAA41C,CAAA54C,EAAAC,EAAA84C,GACA,IAAAC,EAOA,OAFAA,EAJA,OAAAD,IAAAA,IAAAt9C,GAAAs9C,IAAAr9C,IAIArB,KAAAgD,IAAA2C,EAAAG,EAAAF,EAAAE,GAAA9F,KAAAgD,IAAA2C,EAAAK,EAAAJ,EAAAI,GAEA24C,CACA,EASA,MAAAC,WAAAjC,GACA,WAAAlzC,CAAAwV,GACA/N,MAAA+N,GACAjgB,KAAAigB,WAAAA,CACA,CACA,KAAAu+B,GAEA,EAGA,MAAAqB,GACA,WAAAp1C,CAAA0sC,GACAn3C,KAAAm3C,YAAAA,EACAn3C,KAAAuN,KAAA,gBACA,CACA,WAAAuyC,CAAAC,EAAAC,GACA,MAAA7I,EAAAn3C,KAAAm3C,YAAAvF,EAAAuF,EAAA15B,QAAA/S,QAAAknC,WAAAnrC,EAAA0wC,EAAAY,YAAAkI,GAAA,IAAArO,GACAnrC,GAAAA,EAAAmwB,QAAAnwB,EAAAurC,YAAAgO,EAAAE,SAIA,OAHAD,IACAjgD,KAAAi4C,GAAAxxC,GAEAw5C,CACA,CACA,KAAAt5C,CAAAgH,EAAAqyC,GACA,MAAA7I,EAAAn3C,KAAAm3C,YACAl3B,EAAAjgB,KAAAi4C,GACAd,EAAAgJ,aAAAlgC,EAAA+/B,GACA,MAAA3P,EAAApwB,EAAAowB,QACA,IAAAqH,EAAAhyC,EACA2qC,IACAqH,EAAArH,EAAAqC,SAAA/kC,GACAjI,EAAAtC,EAAAs0C,IAEA0B,GAAAn5B,IAAAowB,IAAA8G,EAAA15B,QAAA3R,QAAAvJ,EAAA,CAAA6b,OAAA,GAAAC,YAAA,CAAA4B,GAAAmgC,iBAAA16C,KACA1F,KAAA03C,OAAAA,EACA13C,KAAAqgD,WAAA36C,EACA2qC,EAAA1pC,MAAAgH,KAGAwpC,EAAAviB,WAAAjnB,EACAwpC,EAAAvwC,IAAA+G,GAEA,CACA,IAAAlM,CAAAkM,GACA,MAAA0iC,EAAArwC,KAAAi4C,GAAA5H,QACA,GAAA+I,GAAAp5C,KAAAi4C,KAAA5H,EAGA,OAFAA,EAAA5uC,KAAAzB,KAAA03C,OAAA/pC,GACA3N,KAAAm3C,YAAA15B,QAAA3R,QAAAtJ,EAAA,CAAA4b,OAAA,GAAAC,YAAA,CAAAre,KAAAi4C,IAAAmI,iBAAApgD,KAAAqgD,cACA,CAEA,CACA,GAAAz5C,CAAA+G,GACA,MAAAsS,EAAAjgB,KAAAi4C,GACA5H,EAAApwB,EAAAowB,QAEA5yB,EADAzd,KAAAm3C,YACA15B,QACA,GAAA4yB,GACA+I,GAAAn5B,GAAA,CACA,MAAA4R,EAAAwe,EAAA3gC,KAAA/B,GACA8P,EAAA3R,QAAArJ,EAAA,CAAA2b,OAAA,GAAAC,YAAA,CAAA4B,GAAAmgC,iBAAApgD,KAAAqgD,aAMAxuB,EAAAyd,QALA7xB,EAAA63B,gBAAA9zC,IAAAqwB,GAAA,GACA5R,EAAAuvB,cACA/xB,EAAA6iC,yBAKA,CAEA,CACA,SAAAC,GACA,OAAAn/C,EAAAK,IACA,EAGA,MAAA++C,GACA,WAAA/1C,CAAA0sC,GACAn3C,KAAAm3C,YAAAA,EACAn3C,KAAAuN,KAAA,gBACA,CACA,WAAAuyC,GACA,OAAA9/C,KAAAm3C,YAAAa,iBACA,CACA,KAAArxC,CAAAgH,EAAAqyC,GACA,MAAA7I,EAAAn3C,KAAAm3C,YAAA15B,EAAA05B,EAAA15B,QAAAkyB,EAAAwH,EAAAa,kBAAA/3B,EAAAxC,EAAAgjC,kBAAA,CAAA,EAAA9Q,EAAAsI,GAAAtqC,GACAyrC,GAAAn5B,KAAAxC,EAAA3R,QAAAvJ,EAAA,CAAA6b,OAAA,GAAAC,YAAA,CAAA4B,GAAAmgC,iBAAAj9C,KAAAsa,EAAAqM,eAAA7J,IACAk3B,EAAAU,wBAAA53B,EAAA0vB,EAAAsI,GAAAl6B,OAAA,GACAo5B,EAAAuJ,eACAvJ,EAAAgJ,aAAAhJ,EAAAwJ,iBAAAX,GACA,cAAAA,EAAAzyC,OACAkQ,EAAAu7B,mBAAArJ,EAAAzxB,UAIA+B,EAAAxa,OAAA,MACA0xC,EAAAvwC,IAAA+G,GAEA,CACA,IAAAlM,CAAAkM,GACA,MAAAwpC,EAAAn3C,KAAAm3C,YACAl3B,EAAAk3B,EAAAwJ,iBAGA,OAFA1gC,EAAA9R,OAAAR,GACAwpC,EAAA15B,QAAA3R,QAAAtJ,EAAA,CAAA4b,OAAA,GAAAC,YAAA,CAAA4B,GAAAmgC,iBAAAj9C,KACA,CACA,CACA,GAAAyD,CAAA+G,GACA,MAAAwpC,EAAAn3C,KAAAm3C,YAAA15B,EAAA05B,EAAA15B,QAAAwC,EAAAk3B,EAAAwJ,iBAAA5I,EAAAZ,EAAAY,YAAApI,EAAAwH,EAAAa,kBAAA4I,EAAAnjC,EAAAu7B,mBACA,IAAA7qC,EACA8R,IAIA9R,EADAwhC,GAAAA,EAAAsI,KAAAh4B,EAAA2P,gBACA+f,EAAAsI,GAEAF,GAAAA,aAAA/E,GACA+E,EAAA7G,aAAAhvC,IAAA61C,EAAA7G,aAAAvjC,GAGAA,EAEAsS,EAAA9R,OAAAA,GACAsP,EAAA3R,QAAArJ,EAAA,CAAA2b,OAAA,GAAAC,YAAA,CAAA4B,GAAAmgC,iBAAAj9C,KAKAsa,EAAA7V,OAAAqY,GAAA,GACAxC,EAAA63B,gBAAA/4B,QALA0D,EAAAuvB,cACA/xB,EAAA6iC,0BAMAnJ,EAAAU,0BACA+I,IACAnjC,EAAAm4B,mBAAA13B,OAAAtW,OAAAg5C,GACAnjC,EAAAu7B,mBAAA,MAEA,CACA,SAAAuH,GACA,OAAAn/C,EAAAC,KACA,EAGA,MAAAw/C,GACA,WAAAp2C,CAAA0sC,GACAn3C,KAAAm3C,YAAAA,CACA,CACA,KAAAxwC,GACA,CACA,IAAAlF,GACA,CACA,GAAAmF,GACA,CACA,WAAAk5C,GACA,OAAA,CACA,CACA,SAAAS,GACA,OAAAn/C,EAAAC,KACA,EAGA,SAAAy/C,GAAAd,GACA,OAAA,IAAAA,EAAAE,UAAA,IAAAF,EAAAe,SAAA,IAAAf,EAAAgB,QACA,CAOA,MAAAC,GACA,WAAAx2C,CAAA0sC,GACAn3C,KAAAm3C,YAAAA,CACA,CACA,WAAA2I,GACA,OAAA,CACA,CACA,KAAAn5C,CAAAgH,EAAAqyC,GACA,MAAA7I,EAAAn3C,KAAAm3C,YAAA15B,EAAA05B,EAAA15B,QAAAs6B,EAAAZ,EAAAY,YACAA,IACAZ,EAAAgJ,aAAApI,EAAAiI,GACAjI,EAAA1H,UACArwC,KAAAqwC,QAAA0H,EAAA1H,QACArwC,KAAA03C,OAAA13C,KAAAqwC,QAAAqC,SAAA/kC,KAGA3N,KAAA03C,SACA13C,KAAA03C,OAAAj6B,EAAA83B,iBAAA7C,SAAA/kC,GACA3N,KAAA03C,SACA13C,KAAAqwC,QAAA5yB,EAAA83B,mBAGAv1C,KAAAqwC,UACArwC,KAAAqwC,QAAA2L,aAAAh8C,KAAA03C,SAAAj6B,EAAA3R,QAAAvJ,EAAA,CAAA6b,OAAApe,KAAAqwC,QAAAjyB,OAAAC,YAAA,MAIA84B,EAAAviB,WAAAjnB,EACAwpC,EAAAvwC,IAAA+G,IAJA3N,KAAAqwC,QAAA1pC,MAAAgH,GAOA,CACA,IAAAlM,CAAAkM,GACA3N,KAAAqwC,UACArwC,KAAAqwC,QAAA5uC,KAAAzB,KAAA03C,OAAA/pC,GACA3N,KAAAqwC,QAAA2L,aAAAh8C,KAAA03C,SACA13C,KAAAm3C,YAAA15B,QAAA3R,QAAAtJ,EAAA,CAAA4b,OAAApe,KAAAqwC,QAAAjyB,OAAAC,YAAA,KAGA,CACA,GAAAzX,GACA,MAAA6W,EAAAzd,KAAAm3C,YAAA15B,QAAA4yB,EAAArwC,KAAAqwC,QACA,IAAAxe,EACAwe,IACAA,EAAA2L,aAAAh8C,KAAA03C,SAAAj6B,EAAA3R,QAAArJ,EAAA,CAAA2b,OAAAiyB,EAAAjyB,OAAAC,YAAA,KAOAgyB,EAAAgM,UANAxqB,EAAAwe,EAAA3gC,OACAmiB,GACApU,EAAA63B,gBAAA9zC,IAAAqwB,GAAA,KAOA7xB,KAAAqwC,aAAA1nC,EACA3I,KAAA03C,YAAA/uC,CACA,CACA,SAAA43C,CAAA5yC,GACA,OAAA3N,KAAAm3C,YAAAY,YAAA/3C,KAAAm3C,YAAAY,YAAA7F,WAAAvkC,GAAAvM,EAAAC,KACA,EAGA,MAAA6/C,GAAA,CACAje,KAAA,cACAxhC,KAAA,cACAyhC,GAAA,YACAmZ,OAAA,8BAEA,SAAA8E,GAAAn1C,GACA,OAAAk1C,GAAAl1C,IAAAA,CACA,CACA,MAAAo1C,GAAAz2C,GAEAA,EAAA02C,QADA,WACAF,IAIA,SAAAG,KACA,MAAAC,EAKA,SAAAC,GACA,IAAAD,GAAA,EACA,MAAAE,EAAA,CACAC,GAAA,gDACAC,KAAA,+BACAC,QAAA,qEACAC,OAAA,yCACAC,KAAA,iCACAC,SAAA,kDACAC,QAAA,gCACAC,MAAA,2CACAC,SAAA,iDACAC,EAAA,CACAC,IAAA,sBACAR,QAAA,kBACAI,QAAA,UACAN,GAAA,KACAW,KAAA,wBAEA,IAAA,MAAAC,KAAAb,EAAA,CACA,IAAAl9C,OAAAM,UAAAH,eAAAC,KAAA88C,EAAAa,GACA,SAGA,GADAd,EAAAe,MAAAd,EAAAa,IACA,CACA,GAAA,YAAAA,GAAA,YAAAE,UACA,OAAA,EAEAjB,EAAA,CAAA,EACAA,EAAAkB,OAAAH,EACAf,EAAA77C,KAAAg9C,GAAAJ,EAAAH,GACAZ,EAAAA,EAAA77C,OAAA,EACA,KACA,CACA,CACA,OAAA67C,CACA,CAzCAoB,CAAAH,UAAAI,WACAC,EAAA,CAAA,EAEA,OADAA,EAAAC,SAAAvB,EACAsB,CACA,CAsCA,SAAAH,GAAAJ,EAAAS,EAAAC,GACA,IAAA,MAAAC,KAAAF,EACA,GAAAA,EAAAE,GAAAC,KAAAZ,GACA,OAAAW,EAGA,YAAAt6C,IAAAq6C,EAAAA,EAAAV,CACA,CAEA,MAAAa,GAAA5+C,OAAA6+C,OACAlzC,GAAA,KACA,IAAAZ,MAAAC,UAEA8zC,GAAA,CAAAn6C,EAAAo6C,KACAp6C,EAAAq6C,UAAA/hD,IAAA8hD,EAAA,EAEAE,GAAAC,IACA,MAAAC,EAAAC,SAAAjtB,cAAA,OAEA,OADAgtB,EAAAE,UAAAH,EACAC,EAAAlrB,UAAA,EAgBAqrB,GAAA,CAAA36C,EAAA46C,KACAA,EAAAxrB,aAAApvB,EAAA46C,EAAAtrB,WAAA,EAoDAurB,GAAA9jD,EAAA2gB,EACAqS,GAAA,SAAAnsB,EAAAE,EAAA8P,GACA,MAAA,eAAAhQ,EAAA,MAAAE,EAAA,eAAA8P,EAAA,GACA,EACA,MAAAktC,WAAAx5C,GACA,WAAAC,CAAAvB,EAAAwB,GACAwH,QACA,MAAA+xC,EAAA/6C,EAAA,IAAAA,EACAlJ,KAAAkJ,QAAA+6C,EACAjkD,KAAA6d,SAAA,EACA7d,KAAAkkD,cAAAlkD,KAAAmkD,OAAAr7C,KAAA9I,MACAA,KAAAokD,gBAAApkD,KAAAqkD,SAAAv7C,KAAA9I,MACAkhD,GAAAje,KAAAt2B,MAAA,KAAArF,SAAAyD,IACAk5C,EAAAK,iBAAAv5C,EAAA/K,KAAAkkD,eAAA,EAAA,IAEAhD,GAAAhe,GAAAv2B,MAAA,KAAArF,SAAAyD,IACAk5C,EAAAK,iBAAAv5C,EAAA/K,KAAAokD,iBAAA,EAAA,IAEApkD,KAAA8I,KAAA,CACA,QACA,WACA4B,GAAA,CAAA,EACA,CACA,WAAA65C,GACAvkD,KAAA6d,SAAA,CACA,CACA,aAAA2mC,GACAxkD,KAAA6d,SAAA,CACA,CACA,MAAAsmC,CAAAn4C,GACAhM,KAAA8L,QAAA,SACA9L,KAAA6d,SACA7R,EAAAE,gBAEA,CACA,QAAAm4C,CAAAr4C,GACAhM,KAAA8L,QAAA,WACA9L,KAAA6d,UACA7R,EAAAE,iBACAlM,KAAAwkD,gBAEA,CACA,OAAA35C,GACA,MAAAo5C,EAAAjkD,KAAAkJ,QACAg4C,GAAAje,KAAAt2B,MAAA,KAAArF,SAAAyD,IACAk5C,EAAAQ,oBAAA15C,EAAA/K,KAAAkkD,eAAA,EAAA,IAEAhD,GAAAhe,GAAAv2B,MAAA,KAAArF,SAAAyD,IACAk5C,EAAAQ,oBAAA15C,EAAA/K,KAAAokD,iBAAA,EAAA,GAEA,EAEA,MAAAM,WAAAl6C,GACA,WAAAC,CAAAC,GACAwH,QACAlS,KAAA2kD,eAAA,EACAxB,GAAAnjD,KAAA0K,GACA1K,KAAA8W,MAAA,EACA9W,KAAA2/C,YACA3/C,KAAAirC,QAAA,cACAjrC,KAAA4kD,WAAA,cACA5kD,KAAAk+C,KAAA,MAGAl+C,KAAAirC,QAAA,eACAjrC,KAAA4kD,WAAA,eACA5kD,KAAAk+C,KAAA,IAEA,CACA,WAAA2G,GACA1B,GAAAnjD,KAAA,CACA8kD,SAAA,EACAH,eAAA,EACAI,YAAA,EACAC,YAAA,GAEA,CACA,WAAAC,CAAA51C,EAAAD,GACApP,KAAA+kD,cAAA11C,GAAArP,KAAAglD,cAAA51C,IACApP,KAAA+kD,YAAA11C,EACArP,KAAAglD,YAAA51C,EACApP,KAAAiQ,SAEA,CACA,WAAAi1C,CAAArxC,GACA,OAAAA,EAAA7T,KAAAoP,KAAAyE,EAAA7T,KAAAqP,GACA,CACA,YAAA81C,GACAnlD,KAAA2kD,eAAA,CACA,CACA,OAAAS,GACA,OAAAplD,KAAA6X,UAAA7X,KAAAirC,QACA,CACA,QAAAoa,GACA,OAAArlD,KAAAkJ,QAAAlJ,KAAA4kD,WACA,CACA,OAAAU,CAAAxuC,GACA9W,KAAA8W,MAAAA,CACA,CACA,MAAA7G,CAAAs1C,GACA,MAAAhd,EAAAvoC,KAAA8kD,QAAA9kD,KAAAglD,YAAAhlD,KAAAqlD,WAAAG,EAAAjd,EAAAvoC,KAAA8W,MAAAlR,EAAA5F,KAAAolD,WACA,IAAA7c,GAAAvoC,KAAA2kD,iBAGA3kD,KAAAoP,IAAApP,KAAA8kD,SAAA9kD,KAAA+kD,YAAA,EACA/kD,KAAA4F,KAAAA,EACA5F,KAAAuoC,MAAAid,EACAxlD,KAAAqP,IAAArO,KAAAqO,IAAArP,KAAAoP,IAAAxJ,EAAA4/C,GACAxlD,KAAAylD,SAAA7/C,EAAA2iC,EACAvoC,KAAA0lD,cAAAF,EAAA5/C,GAAA,EACA5F,KAAA2lD,QAAA3lD,KAAA2kD,eAAAa,EAAA5/C,EACA2/C,GACAvlD,KAAA8L,QAAA3K,EAAAnB,MAEA,EAEA,MAAA4lD,WAAAp7C,GACA,WAAAC,CAAAC,GACAwH,QACAlS,KAAA8G,EAAA,IAAA49C,GAAAvB,GAAA,CACAxD,YAAA,GACAj1C,IACA1K,KAAAgH,EAAA,IAAA09C,GAAAvB,GAAA,CACAxD,YAAA,GACAj1C,IACA1K,KAAA6X,UAAAnN,EAAAmN,UACA7X,KAAA6lD,eAAAn7C,EAAA+6C,SACAzlD,KAAA8lD,SAAAp7C,EAAAo7C,UAAA,IACA9lD,KAAA8I,KAAA3H,EAAAuJ,EACA,CACA,OAAA46C,CAAAS,GACA/lD,KAAA8G,EAAAw+C,QAAAS,GACA/lD,KAAAgH,EAAAs+C,QAAAS,GACA/lD,KAAA6uC,SACA,CACA,iBAAAmX,GACA,MAAA,CACAl/C,EAAA9F,KAAAqO,IAAA,GAAArP,KAAA8G,EAAA4+C,cACA1+C,EAAAhG,KAAAqO,IAAA,GAAArP,KAAAgH,EAAA0+C,cAEA,CACA,OAAA7W,GACA7uC,KAAA8G,EAAAmJ,SACAjQ,KAAAgH,EAAAiJ,SACAjQ,KAAA2lD,QAAA3lD,KAAA8G,EAAA6+C,SAAA3lD,KAAAgH,EAAA2+C,QACA3lD,KAAAylD,SAAAzlD,KAAA6lD,gBAAA7kD,KAAAqO,IAAArP,KAAA8G,EAAA2+C,SAAAzlD,KAAAgH,EAAAy+C,UACAzlD,KAAAimD,SAAAjlD,KAAAoO,IAAApP,KAAA8G,EAAA2+C,SAAAzlD,KAAAgH,EAAAy+C,UACAzlD,KAAA8L,QAAA3K,EACA,EAEA,MAAA+kD,WAAA17C,GACA,WAAAC,CAAAC,GACAwH,QACAixC,GAAAnjD,KAAA0K,EACA,CACA,WAAAw6C,GACA,OAAAllD,KAAAmmD,UAAAjB,YAAAllD,KAAAomD,QAAApmD,KAAAk+C,MACA,CACA,QAAAmI,CAAAjvC,GACA,MAAA+uC,EAAAnmD,KAAAmmD,UAAAjI,EAAAl+C,KAAAk+C,KAAAkI,EAAApmD,KAAAomD,QAAAj9C,EAAAi9C,EAAAlI,GAAA9mC,EACA,IAAA+uC,EAAAR,QACA,OAEA,IAAAW,EAAAlvC,GACAjO,EAAAg9C,EAAA92C,KAAA+H,EAAA,GAAAjO,EAAAg9C,EAAA/2C,KAAAgI,EAAA,KACAkvC,GAAAtmD,KAAAumD,YAEAH,EAAAI,cAAAtI,EAAAoI,GACAtmD,KAAA8L,QAAA3K,EAAAnB,KACA,EAEA,MAAAymD,GACA,WAAAh8C,CAAAC,GACA,IAAA5D,EAAAE,EACAm8C,GAAAnjD,KAAA,CACA0mD,SAAA,GACAh8C,GACA,MAAA67C,EAAAvmD,KAAA0mD,QAAA,GAAA,EACAN,EAAApmD,KAAAomD,QACApmD,KAAA8G,EAAAA,EAAA,IAAAo/C,GAAA,CACAhI,KAAA,IACAiI,UAAAnmD,KAAA2mD,WAAA7/C,EACAy/C,WAAAA,EACAH,QAAAA,IAEApmD,KAAAgH,EAAAA,EAAA,IAAAk/C,GAAA,CACAhI,KAAA,IACAiI,UAAAnmD,KAAA2mD,WAAA3/C,EACAu/C,WAAAA,EACAH,QAAAA,IAEApmD,KAAA4mD,WAAA99C,KAAA,CACA,QACA,OACA,MACA,eACA,iBACA,CACA,YAAA+9C,CAAA76C,GACAhM,KAAA8mD,QAAA96C,EACAhM,KAAA6T,OAAAkwC,GAAA/jD,KAAA2mD,WAAA9uC,UACA,EACA,KAAAkvC,CAAA/6C,GACA,MAAAg7C,EAAAh7C,EAAAjB,MAAAoD,OAAA84C,QAAA,KACAD,GAAAA,EAAAE,QAAA,kCACAl7C,EAAAC,OAAAowC,QAEA,EACA,aAAA8K,CAAAn7C,GACA,MAAAo7C,EAAApnD,KAAA8mD,QAAAO,EAAAD,EAAA//C,OAAAA,EAAA2E,EAAA3E,OAAAo+C,EAAAzlD,KAAA2mD,WAAAlB,SAAAK,EAAA9lD,KAAA2mD,WAAAb,SACA,IAAAwB,EAAAt7C,EAAAohB,SAAAg6B,EAAAh6B,SACAg5B,EAAAtvC,OAAA2uC,GAAA6B,EAAA,IACAA,GAAA,IAAA,EAAAA,IAEAlB,EAAAtvC,MAAAwwC,GAAAxB,IACAwB,EAAAxB,EAAAM,EAAAtvC,OAEA,MAAA+D,EAAAurC,EAAAt/C,EAAA9G,KAAA6T,OAAAkC,KAAA+E,EAAAsrC,EAAAp/C,EAAAhH,KAAA6T,OAAA+B,IACA2xC,EAAA,CACAzgD,GAAA+T,EAAAwsC,EAAAvgD,GAAAwgD,EAAAjgD,EAAAP,EAAA+T,EACA7T,GAAA8T,EAAAusC,EAAArgD,GAAAsgD,EAAAjgD,EAAAL,EAAA8T,GAEAsrC,EAAAoB,UAAAF,GACAxgD,EAAAu/C,SAAAkB,EAAAzgD,GACAE,EAAAq/C,SAAAkB,EAAAvgD,GACAhH,KAAA2mD,WAAArB,QAAAc,EAAAtvC,OACA9W,KAAA8mD,QAAA96C,EACAA,EAAAE,gBACA,EACA,IAAAzK,CAAAuK,GACAA,EAAAjB,MAAAoD,OAAAs5C,QAAAlF,MAAA,qBAGAz7C,EAAAq/C,UAAAR,SAAA3+C,EAAAm/C,UAAAR,SACA7+C,EAAAu/C,SAAAr6C,EAAAlF,EAAAsQ,OACApQ,EAAAq/C,SAAAr6C,EAAAhF,EAAAoQ,OACApL,EAAAE,kBAGAF,EAAA07C,MAAAC,OAEA,EACA,GAAA/gD,CAAAoF,GACAA,EAAAE,gBACA,GAEA,EAEA,MAAA07C,WAAAp9C,GACA,WAAAC,CAAAvB,GACAgJ,QACAlS,KAAAkJ,QAAAA,EACAlJ,KAAAkJ,QAAA2+C,MAAAC,gBAAA,WACA9nD,KAAA8G,EAAA,EACA9G,KAAAgH,EAAA,EACAhH,KAAA8W,MAAA,EACA,MAAAywC,EAAAt0B,GAAAjzB,KAAA8G,EAAA9G,KAAAgH,EAAAhH,KAAA8W,OACA9W,KAAAkJ,QAAA2+C,MAAA30B,UAAAq0B,EACAvnD,KAAA+nD,iBAAAR,EACA,CACA,aAAAf,CAAAtI,EAAA8J,GACAhoD,KAAAk+C,IAAA8J,EACAhoD,KAAA6uC,SACA,CACA,OAAAoZ,CAAAnxC,GACA9W,KAAA8W,MAAAA,EACA9W,KAAA6uC,SACA,CACA,SAAA2Y,CAAAF,GACAtnD,KAAA8W,OAAAwwC,EACAtnD,KAAA6uC,SACA,CACA,SAAA5b,CAAAs0B,GACAvnD,KAAA8G,GAAAygD,EAAAzgD,EACA9G,KAAAgH,GAAAugD,EAAAvgD,EACAhH,KAAA6uC,SACA,CACA,QAAAqZ,CAAAhK,EAAAn6C,GACA/D,KAAAk+C,GAAAn6C,EACA/D,KAAA6uC,SACA,CACA,MAAAsZ,CAAAZ,GACApE,GAAAnjD,KAAAunD,GACAvnD,KAAA6uC,SACA,CACA,OAAAA,GACA,IAAA/nC,EAAA9G,KAAA8G,EAAAE,EAAAhH,KAAAgH,EACAhH,KAAAwQ,QACA1J,EAAA9F,KAAAwP,MAAA1J,GACAE,EAAAhG,KAAAwP,MAAAxJ,IAEA,MAAAohD,EAAAn1B,GAAAnsB,EAAAE,EAAAhH,KAAA8W,OACAsxC,IAAApoD,KAAAunD,cACAvnD,KAAAkJ,QAAA2+C,MAAA30B,UAAAk1B,EACApoD,KAAA+nD,iBAAAK,GACApoD,KAAA8L,QAAA3K,GAEA,CACA,gBAAA4mD,CAAAR,GACAvnD,KAAAunD,YAAAA,CACA,EAGA,SAAAc,GAAAC,GACA94C,OAAA+4C,sBAAAD,EACA,CACA,MAAAE,GACA,WAAA/9C,GACAzK,KAAAyoD,WAAA,IAAAzoD,KAAA0oD,QACA1oD,KAAA2oD,UAAA,CACA,CACA,IAAAv6C,GAAA,CACA,IAAAw6C,GAAA,OAAA,CAAA,CACA,KAAAC,GAAA,CACA,QAAAC,GAAA,CACA,KAAAniD,GACA3G,KAAA2lD,YAGA3lD,KAAA4oD,OAKA5oD,KAAA6oD,SAJA7oD,KAAA2oD,UAAA,EACAN,GAAAroD,KAAAyoD,aAKA,CACA,OAAA9C,GACA,OAAA,CACA,CACA,MAAAtJ,GACAr8C,KAAA2oD,UAAA,EACA3oD,KAAA8oD,UACA,CACA,KAAAJ,GACA1oD,KAAA2oD,WAGA3oD,KAAAoO,OACApO,KAAA4oD,QAIA5oD,KAAA2oD,UAAA,EACA3oD,KAAA6oD,SAJAR,GAAAroD,KAAAyoD,YAMA,EAEA,MAAAM,WAAAP,GACA,WAAA/9C,CAAAC,GACAwH,QACAixC,GAAAnjD,KAAA0K,EACA,CACA,IAAAk+C,GACA,OAAA5oD,KAAAmQ,cAAAnQ,KAAAsO,QACA,CACA,UAAA6B,GACA,OAAAnP,KAAAqO,IAAArP,KAAAsO,SAAA4B,KAAAlQ,KAAAgpD,UACA,CACA,MAAAb,CAAAz9C,GACA,MAAA07C,EAAApmD,KAAAomD,QACApmD,KAAA0I,QAAA09C,EAAApmD,KAAAk+C,MACAl+C,KAAAoX,MAAA1M,EAAAu+C,SAAAjpD,KAAA0I,QACA1I,KAAAsO,SAAA,iBAAA5D,EAAA4D,SAAA5D,EAAA4D,SAAA,IACAtO,KAAAoO,KAAApO,KAAAkpD,WAAAx+C,EAAAy+C,MACAnpD,KAAAgpD,UAAA94C,KACAlQ,KAAA2G,OACA,CACA,UAAAuiD,CAAAC,GACA,OAAA,WACAnpD,KAAAomD,QAAA8B,SAAAloD,KAAAk+C,KAAAiL,EAAAnpD,KAAAmQ,aAAAnQ,KAAA0I,QAAA1I,KAAAoX,MAAApX,KAAAsO,UACA,CACA,CACA,kBAAA86C,CAAAhlC,EAAA3a,EAAAwD,EAAAJ,GACA,OAAAuX,IAAAvX,EAAApD,EAAAwD,EAAAA,GAAA,EAAAjM,KAAAksB,IAAA,GAAA,GAAA9I,EAAAvX,IAAApD,CACA,EAiBA,MAAA4/C,GAAA,IAAAC,QACAC,GAAAC,OAAA,MACA,SAAAC,GAAAvgD,EAAAyB,EAAAtC,EAAAgD,EAAAq+C,IASA,SAAAxgD,EAAAyB,EAAAtC,EAAAgD,EAAAq+C,GACA,MAAAx+C,EAAA9F,MAAAC,QAAAsF,GAAAA,GAAAA,GAAA,IAAAgC,MAAA,KACAzB,EAAA5D,SAAA,SAAAiE,IAIA,SAAArC,EAAA6B,EAAA1C,EAAAgD,EAAAq+C,GACA,IACAC,EADAC,EAAAv+C,EAEAhD,GAAAjE,EAAAiE,KAAAgD,EACAu+C,EAAAvhD,EAEAA,IAfAtE,EAeAsE,EAdA,iBAAA,IAcAjE,EAAAwlD,KACAD,EAAAthD,GAhBA,IAAAtE,EAkBA,MAAA8lD,EAAA,SAAA79C,GACA,MAAA89C,EAAA99C,EAAAmC,OAAAnC,EAAAmC,OAAA84C,QAAA0C,GAAA,KACA,IAAAA,GACAA,GAAA39C,EAAAmC,QAAA27C,EAAA,CACA,MAAAC,EAAAJ,EAAAG,EAAA99C,EAAA+9C,cAEAxlD,OAAAylD,eAAAh+C,EAAA,gBAAA,CAAAjI,MAAAgmD,IAEAxlD,OAAAylD,eAAAh+C,EAAA,iBAAA,CAAAjI,MAAAmF,IACA0gD,EAAA59C,EACA,CACA,EACA49C,EAAAL,MACAK,EAAAL,IArDA,WACA,IACAzjD,EACAI,EAFA4L,EAAA,GAGA,IAAAhM,EAAA,EAAAA,EAAA,GAAAA,IACAI,EAAAlF,KAAAmF,MAAA,GAAAnF,KAAAkF,UACA,IAAAJ,GAAA,KAAAA,GAAA,KAAAA,GAAA,KAAAA,IACAgM,GAAA,KAEAA,IAAA,KAAAhM,EAAA,EAAA,KAAAA,EAAAI,EAAA,EAAA,EAAAA,GAAApB,SAAA,IAEA,OAAAgN,CACA,CAyCAm4C,IAEA,IAAAC,EAAAb,GAAAz4C,IAAA1H,GACAghD,IACAA,EAAA,IAAAC,IACAd,GAAAv4C,IAAA5H,EAAAghD,IAEAA,EAAAp5C,IAAA/F,EAAA6+C,EAAAL,IAAAM,GACA3gD,EAAAo7C,iBAAAv5C,EAAA8+C,EAAAO,QAAAV,GACA,CAlCApF,CAAAp7C,EAAAqC,EAAAlD,EAAAgD,EAAAq+C,EACA,GACA,CAbAW,CAAAnhD,EAAAyB,EAAAtC,EAAAgD,EAAAq+C,EACA,CACA,SAAAY,GAAAphD,EAAAyB,EAAAU,EAAAq+C,IA4CA,SAAAxgD,EAAAyB,EAAAU,EAAAq+C,GACA,MAAAx+C,EAAA9F,MAAAC,QAAAsF,GAAAA,GAAAA,GAAA,IAAAgC,MAAA,KACAzB,EAAA5D,SAAA,SAAAiE,IAIA,SAAArC,EAAA6B,EAAAM,EAAAq+C,GACA,MAAAQ,EAAAb,GAAAz4C,IAAA1H,GACA,GAAAghD,GAAA7+C,GAAAA,EAAAk+C,IAAA,CACA,MAAAgB,EAAAx/C,EAAAM,EAAAk+C,IACAM,EAAAK,EAAAt5C,IAAA25C,GACAL,EAAAM,OAAAD,GACAV,GACA3gD,EAAAu7C,oBAAA15C,EAAA8+C,EAAAO,QAAAV,GAEA,CACA,CAbAjF,CAAAv7C,EAAAqC,EAAAF,EAAAq+C,EACA,GACA,CAhDAe,CAAAvhD,EAAAyB,EAAAU,EAAAq+C,EACA,CAuEA,MAAAgB,GAAA1+C,IACAA,EAAAE,gBAAA,EAEAsB,GAAA,OACAm9C,GAAA,QAAAC,GAAA,OAAAC,GAAA,SAAAC,GAAA,QAAAC,GAAA,OAAAC,GAAA,MAAAC,GAAA,SAAAC,GAAA,MAAAC,GAAA,YAAAC,GAAA,UAAAC,GAAA,gBAAAC,GAAA,aAAAC,GAAA,aACAC,GAAA,CACAC,IAAA,EACA/D,MAAA,EACAgE,MAAA,EACAC,QAAA,GAEA,IAAAC,GAAA,IAAAC,GAAA,EAWA,SAAAC,GAAA9/C,GACA,MAAA+/C,EAAA,GAAAC,EAAAhgD,EAAAggD,eAAAhgD,EAAA+9C,EAAA/9C,EAAA+9C,cAqBA,OApBA/9C,EAAAy/C,IACAM,EAAAniD,KAAA,CACAkI,GAAA,EACA/G,MAAAiB,EACAmC,OAAAnC,EAAAmC,OACA47C,cAAA/9C,EAAAmC,OACA86C,SAAAj9C,EACAuB,KAAA,QAIAw+C,EAAAniD,KAAA,CACAq/C,SAAA+C,EACAjhD,MAAAiB,EACAmC,OAAAnC,EAAAmC,OACA47C,cAAAA,EACAj4C,GAAAk6C,EAAAC,UACA1+C,KAAA,YAGAw+C,CACA,CACA,MAAAG,GACA,WAAAzhD,CAAAyzC,EAAA+K,GACAjpD,KAAA6iD,QAAAvB,KACAthD,KAAAmsD,kBAAAnsD,KAAA6iD,QAAAC,UAAA9iD,KAAA6iD,QAAAC,SAAAlB,QACA5hD,KAAAk+C,KAAAA,EACAl+C,KAAAosD,oBAAAnD,GACAjpD,KAAAqsD,cAAArsD,KAAAipD,SACAjpD,KAAAssD,SAAAtsD,KAAAoX,MAAA,EACApX,KAAAusD,UAAAr8C,IACA,CACA,IAAAzO,CAAAwnD,GACA,MAAAp1C,EAAAo1C,EAAA,OAAAjpD,KAAAk+C,MAAAqO,EAAAr8C,KAAAs8C,EAAAD,EAAAvsD,KAAAusD,WAAA,GACA14C,GAAA7T,KAAAmsD,oBAGAnsD,KAAAoX,MAAAvD,EAAA7T,KAAAipD,SACAjpD,KAAAosD,oBAAAnD,GACAjpD,KAAAysD,aAAA54C,EAAA7T,KAAAqsD,cACArsD,KAAAssD,SAAAtsD,KAAAoX,MAAAo1C,EACAxsD,KAAAusD,UAAAA,EACA,CACA,mBAAAH,CAAAnD,GACA,MAAA/K,EAAAl+C,KAAAk+C,KACAl+C,KAAAipD,SAAAA,EAAA,OAAA/K,GACAl+C,KAAA0sD,OAAAzD,EAAA,SAAA/K,GACAl+C,KAAA2sD,OAAA1D,EAAA,SAAA/K,EACA,EAEA,MAAA0O,GACA,WAAAniD,CAAAm8C,EAAAz4C,EAAA0+C,GACA1J,GAAAnjD,KAAA,CACA8G,EAAA,IAAAolD,GAAA,IAAAW,EAAA5D,UACAjiD,EAAA,IAAAklD,GAAA,IAAAW,EAAA5D,UACA17C,KAAAs/C,EAAAt/C,KACAu/C,UAAAlG,EAAAkG,WAAAtB,GAAAqB,EAAAt/C,MACAq5C,WAAAA,EACAz4C,OAAAA,EACA47C,cAAA8C,EAAA9C,cACAgD,aAAAF,EAAA1+C,OACA2D,GAAA+6C,EAAA/6C,GACAk7C,WAAAH,EACAI,QAAArG,EAAAqG,QACAC,iBAAAtG,EAAAsG,iBACAC,QAAA,EACAC,WAAA,GAEA,CACA,KAAArG,GACA/mD,KAAAqtD,aAAAC,YAAA,IAAAttD,KAAAutD,SAAAvtD,KAAA4mD,WAAA4G,SACAxtD,KAAAytD,SAAA9C,GAAA3qD,KAAAgtD,WACA,CACA,IAAAU,CAAAb,GACA7sD,KAAA4mD,WAAAqG,UACA,IAAAjtD,KAAA4mD,WAAAqG,UACAjtD,KAAA2tD,cAAAL,YAAA,KACA,IAAAttD,KAAA4mD,WAAAqG,QACAjtD,KAAAytD,SAAAvC,GAAA2B,GAGA7sD,KAAAytD,SAAAtC,GAAA0B,GAEA7sD,KAAA4mD,WAAAqG,QAAA,CAAA,GAvGA,KA0GA,CACA,KAAAM,GACAvtD,KAAAytD,SAAA7C,GAAA5qD,KAAAgtD,WACA,CACA,IAAAvrD,CAAAorD,GACA,MAAAe,EAAA,QAAAf,EAAAt/C,MAAAvN,KAAA4mD,WAAAiH,eACA,IAAA7tD,KAAAotD,YAAAQ,EAAA,CAKA,GAFA5tD,KAAA8G,EAAArF,KAAAorD,EAAA5D,UACAjpD,KAAAgH,EAAAvF,KAAAorD,EAAA5D,WACAjpD,KAAAmtD,OAAA,CACA,GAAAntD,KAAA8tD,yBACA,OAEA,GAAAC,GAAA10C,SAAA00C,GAAA10C,UAAArZ,KAAA4mD,WAIA,OAAA5mD,KAAAguD,UAHAhuD,KAAAiuD,OAAApB,EAKA,CACA7sD,KAAAotD,WACAptD,KAAAytD,SAAA1C,GAAA8B,EAfA,CAiBA,CACA,GAAAjmD,CAAAimD,GACA7sD,KAAAkuD,QAAAh+C,KACAlQ,KAAAotD,YAGAptD,KAAAotD,WAAA,EACAptD,KAAAytD,SAAArC,GAAAyB,GACA7sD,KAAAmtD,OACAntD,KAAAytD,SAAAzC,GAAA6B,GAGA7sD,KAAAktD,iBACAltD,KAAA0tD,KAAAb,GAGA7sD,KAAAytD,SAAAvC,GAAA2B,GAGAsB,aAAAnuD,KAAAqtD,cACArtD,KAAAguD,UACA,CACA,OAAAA,GACA,MAAAI,EAAApuD,KAAA4mD,WAAAmF,SAAA,GACA/rD,KAAAotD,WAAA,EACAptD,KAAAgtD,WAAA,KACAmB,aAAAnuD,KAAAqtD,cAEA,MAAAgB,EAAAD,EAAArmD,QAAA/H,MACAouD,EAAApmD,OAAAqmD,EAAA,EACA,CACA,IAAA1G,GACA3nD,KAAAguD,SACA,CACA,MAAA3R,GACAr8C,KAAAguD,SACA,CACA,OAAAM,GACA,OAAAtuD,KAAAmtD,MACA,CACA,MAAAc,CAAApB,GACAsB,aAAAnuD,KAAAqtD,cACArtD,KAAAuuD,UAAAr+C,KACAlQ,KAAAmtD,QAAA,EACAntD,KAAAytD,SAAA3C,GAAA+B,EACA,CACA,QAAAY,CAAA/nD,EAAAmnD,GACA,MAAA7gD,EAAA6gD,EAAA9hD,MACA4T,EAAA,CACA+oC,MAAA1nD,KACA8G,EAAA9G,KAAA8G,EACAE,EAAAhH,KAAAgH,EACAmH,OAAAnO,KAAAmO,OACApD,MAAAiB,GAEAhM,KAAA4mD,WAAA4H,OAAA9oD,EAAAiZ,IACA3S,EAAAE,gBAEA,CACA,sBAAA4hD,GACA,MAAAW,EAAAzuD,KAAA8G,EAAA2lD,aAAAiC,EAAA1uD,KAAAgH,EAAAylD,aACA,OAAAzrD,KAAAgM,KAAAyhD,EAAAA,EAAAC,EAAAA,IAAA1uD,KAAA8sD,SACA,EAEA,SAAA6B,GAAArG,GACA,MAAAsG,EAAA1N,GAAAhe,GAAAv2B,MAAA,KAAArH,EAAAspD,EAAAtpD,OACA,IAAA,IAAAgG,EAAA,EAAAA,EAAAhG,EAAAgG,IACAg9C,EAAAsG,EAAAtjD,GAEA,CACA,MAAAyiD,WAAAvjD,GACA,WAAAC,CAAAvB,EAAAwB,GACAwH,QACA,MAAA2wC,EAAAvB,KACAthD,KAAA6iD,QAAAA,EACAn4C,EAAAA,GAAA,CAAA,EACA1K,KAAA0K,QAAAA,EACA,MAAArC,EAAArI,KAAAqI,OAAAqC,EAAArC,OAgCA,GA/BArI,KAAA8sD,UAAApiD,EAAAoiD,WAAAjB,GACA7rD,KAAAwtD,QAAA9iD,EAAA8iD,SAAA5B,GACA5rD,KAAA+rD,QAAA,GACA/rD,KAAA6uD,YAAAnkD,EAAAokD,WAAA,EAAA,EACA9uD,KAAA+uD,eAAArkD,EAAAqkD,eACA/uD,KAAAgvD,iBAAAtkD,EAAAskD,iBACAhvD,KAAAitD,QAAA,EACAjtD,KAAAktD,iBAAAxiD,EAAAwiD,iBACA/J,GAAAnjD,KAAA,CACAkJ,QAAAA,EACA8uB,QAAAttB,EAAAstB,SAAA9uB,EACA+lD,gBAAAvkD,EAAAukD,gBACAC,SAAA,IAEAlvD,KAAAmvD,oBAAAnvD,KAAAovD,MAAAtmD,KAAA9I,MACAypD,GAAAzpD,KAAAg4B,QAAAopB,GAAA,QAAAphD,KAAAmvD,qBACAnvD,KAAAqvD,mBAAArvD,KAAAsvD,KAAAxmD,KAAA9I,MACAypD,GAAAzpD,KAAAg4B,QAAAopB,GAAA,aAAAphD,KAAAqvD,oBACArvD,KAAAuvD,qBAAAvvD,KAAAiuD,OAAAnlD,KAAA9I,MACAypD,GAAAvgD,EAAAk4C,GAAA,QAAA/4C,EAAArI,KAAAuvD,sBACArmD,EAAA2+C,MAAA,gBAAAn9C,EAAA8kD,aAAA,OACA9kD,EAAA+kD,mBACAzvD,KAAA0vD,yBAAAhF,GACAjB,GAAAvgD,EAAAk4C,GAAA,aAAAphD,KAAA0vD,2BAMA1vD,KAAA2vD,sBAAA3vD,KAAA4vD,QAAA9mD,KAAA9I,MACAypD,GAAAvgD,EAAAk4C,GAAA,aAAA/4C,EAAArI,KAAA2vD,uBACA3vD,KAAAgvD,iBAAA,CACA,MAAAa,EAAA7vD,KAAAg4B,QACAh4B,KAAA8vD,qBAAA9vD,KAAA+vD,gBAAAjnD,KAAA9I,MACA2uD,IAAApjD,IACAskD,EAAAvL,iBAAA/4C,EAAAvL,KAAA8vD,sBAAA,EAAA,GAEA,CACA9vD,KAAA8I,KAAA,CACA6hD,GACAC,GACAM,GACAC,GACAL,GACAC,GACAC,GACAI,GACAH,GAhQA,eAkQAI,GACAC,GACAC,GACAV,IACAngD,EACA,CACA,eAAAqlD,CAAA/jD,GACAhM,KAAAgwD,YACAhkD,EAAAE,gBAEA,CACA,OAAArB,GACA,MAAAH,EAAA1K,KAAA0K,QACAxB,EAAAlJ,KAAAkJ,QACA,IAAAlJ,KAAAiwD,WAAA,CAIA,GADAjwD,KAAAiwD,YAAA,EACAjwD,KAAAgvD,iBAAA,CACA,MAAAa,EAAA7vD,KAAAg4B,QACA22B,IAAApjD,IACAskD,EAAApL,oBAAAl5C,EAAAvL,KAAA8vD,sBAAA,EAAA,GAEA,CACAxF,GAAAtqD,KAAAg4B,QAAAopB,GAAA,QAAAphD,KAAAmvD,qBACA7E,GAAAtqD,KAAAg4B,QAAAopB,GAAA,aAAAphD,KAAAqvD,oBACA/E,GAAAphD,EAAAk4C,GAAA,QAAAphD,KAAAuvD,sBACA7kD,EAAA+kD,kBACAnF,GAAAphD,EAAAk4C,GAAA,aAAAphD,KAAA0vD,0BAEApF,GAAAphD,EAAAk4C,GAAA,aAAAphD,KAAA2vD,uBACA3vD,KAAAkwD,cACAlwD,KAAA8K,gBACA9K,KAAAg4B,eACAh4B,KAAAkJ,eACAlJ,KAAA+pD,aAnBA,CAoBA,CACA,OAAAlsC,GACAkwC,GAAA10C,QAAArZ,IACA,CACA,MAAAq8C,GACAr8C,KAAAkwD,cACAlwD,KAAA8L,QAAAm/C,GACA,CACA,MAAAuD,CAAAzjD,EAAA4T,GACA,MAAAotC,EAAA/rD,KAAA+rD,QACA,IAAAxgD,EAAAR,EACA,GAAA/K,KAAAmwD,gBAAA,CACA,OAAA5kD,GACA,KAAAw/C,GACAx/C,EAAA8/C,GACA,MACA,KAAAL,GACAz/C,EAAA+/C,GACA,MACA,KAAAJ,GACA3/C,EAAAggD,GAKApI,GAAAxkC,EAAA,CACAotC,QAAAA,GAxTA,SAAAqE,EAAAC,GACA,MAAA76C,EAAA46C,EAAAtpD,EAAAmiD,SAAAxzC,EAAA26C,EAAAppD,EAAAiiD,SAAAvzC,EAAA26C,EAAAvpD,EAAAmiD,SAAAtzC,EAAA06C,EAAArpD,EAAAiiD,SAAA3zC,EAAAE,EAAAE,EAAAH,EAAAE,EAAAE,EACA,MAAA,CACAtO,OAAA,CACAP,GAAA0O,EAAAE,GAAA,EACA1O,GAAAyO,EAAAE,GAAA,GAEAyX,SAAApsB,KAAAgM,KAAAsI,EAAAA,EAAAC,EAAAA,GAEA,CAgTA+6C,CAAAvE,EAAA,GAAAA,EAAA,IACA,CACA,OAAA/rD,KAAA8L,QAAAP,EAAA43C,GAAAxkC,EAAA,CACApR,KAAAhC,IAEA,CACA,KAAAw7C,CAAAjgD,EAAAE,EAAAmH,GACAnO,KAAAuwD,SAAA,SAAAzpD,EAAAE,EAAAmH,EACA,CACA,IAAA1M,CAAAqF,EAAAE,GACAhH,KAAAuwD,SAAA,QAAAzpD,EAAAE,EACA,CACA,GAAAJ,CAAAE,EAAAE,GACAhH,KAAAuwD,SAAA,OAAAzpD,EAAAE,EACA,CACA,aAAAmpD,GACA,OAAAnwD,KAAA+rD,QAAAzmD,OAAA,CACA,CACA,kBAAAkrD,GACA,OAAAxwD,KAAA+rD,QAAAzmD,QAAAtF,KAAA6uD,WACA,CACA,WAAAqB,GACA,MAAAnE,EAAA/rD,KAAA+rD,QACA,KAAAA,EAAAzmD,OAAA,GACAymD,EAAAxvC,MAAAyxC,SAEA,CACA,QAAAgC,GACA,OA5WA,SAAAnqD,EAAAyiD,GACA,MAAAhjD,EAAAO,EAAAP,OACA+D,EAAA,GACA,IAAA,IAAAiC,EAAA,EAAAA,EAAAhG,EAAAgG,IACAg9C,EAAAziD,EAAAyF,KACAjC,EAAAO,KAAA/D,EAAAyF,IAGA,OAAAjC,CACA,CAmWA6D,CAAAlN,KAAA+rD,SAAA,SAAArE,GACA,OAAAA,EAAA4G,SACA,IAAAhpD,MACA,CACA,OAAAsqD,CAAA5jD,GACAhM,KAAA+uD,iBAAA/uD,KAAA8L,QAAA++C,GAAA,CAAA9/C,MAAAiB,KACAA,EAAAE,gBAEA,CACA,MAAA+hD,CAAAjiD,GACA,GAAAA,EAAAykD,OAAAzkD,EAAAykD,MAAA,GAAAzwD,KAAAwwD,qBACA,OAOA,IAAAriD,EALA4/C,GAAA10C,QAAA,KACArZ,KAAA+pD,cAAA/9C,EAAA+9C,cACA/pD,KAAAivD,iBACAjjD,EAAAijD,kBAGA,MAAAyB,EAAA5E,GAAA9/C,GACA,IAAA,IAAAV,EAAA,EAAAA,EAAAolD,EAAAprD,SACAtF,KAAAwwD,qBADAllD,IAAA,CAIA,MAAAqlD,EAAAD,EAAAplD,GAOA,GALA6C,EADAnO,KAAAqI,OACAsoD,EAAA5G,cAGA/pD,KAAAkJ,QAEAiF,GAAA,IAAAA,EAAA7I,OACA,SAEA,MAAAoiD,EAAA,IAAAkF,GAAA5sD,KAAAmO,EAAAwiD,GACA3wD,KAAA+rD,QAAAniD,KAAA89C,GACAA,EAAAX,QACA/mD,KAAAmwD,iBACAnwD,KAAAwuD,OAAA,eAAA,CAAA,EAEA,CACA,CACA,KAAAY,CAAApjD,GACAhM,KAAA4wD,WAAA,OAAA5kD,EACA,CACA,IAAAsjD,CAAAtjD,GACAhM,KAAA4wD,WAAA,MAAA5kD,EACA,CACA,UAAA4kD,CAAAC,EAAA7kD,GACA,MAAA8kD,EAAA,CAAA,EAAA/E,EAAAD,GAAA9/C,GAAAoiD,EAAApuD,KAAA+rD,QACA,IAAAzgD,EAAAo8C,EAAAmF,EAAAkE,EACA,IAAAzlD,EAAA,EAAAA,EAAA8iD,EAAA9oD,OAAAgG,IACAo8C,EAAA0G,EAAA9iD,GACAwlD,EAAApJ,EAAA51C,IAAA41C,EAEA,IAAAp8C,EAAA,EAAAA,EAAAygD,EAAAzmD,OAAAgG,IAGA,GAFAuhD,EAAAd,EAAAzgD,GACAylD,EAAAD,EAAAjE,EAAA/6C,IACAi/C,EAAA,CACA,SAAAF,GAAA,YAAAhE,EAAAt/C,OAAAvN,KAAAg4B,QAAAg5B,kBAAAnE,EAAA/6C,KAEA9R,KAAAg4B,QAAAi5B,kBAAApE,EAAA/6C,IAEAi/C,EAAAF,GAAAhE,EACA,CAEA,CACA,QAAA0D,CAAAhjD,EAAAzG,EAAAE,EAAAmH,GACAnO,KAAAuN,GAAA,CACAk+C,KAAA,EACAyF,MAAApqD,EACAqqD,MAAAnqD,EACAoqD,QAAAtqD,EACAuqD,QAAArqD,EACAmH,OAAAA,GAAAnO,KAAAkJ,QACA+lD,gBAAAzhD,GACAtB,eAAAsB,IAEA,CACA,uBAAA8jD,CAAAvtD,GACA8nD,GAAA9nD,CACA,CACA,cAAAypD,CAAAzpD,GACA6nD,GAAA7nD,CACA,EAGA,MAAAwtD,GAAAhtD,OAAA6+C,OAAAp/C,GAAAhD,KAAAgD,IAGAwtD,GAAA,SAAAC,GAAA,SACA,MAAAC,WAAAlJ,GACA,WAAA/9C,CAAAC,GACAwH,QACAq/C,GAAAvxD,KAAA0K,GACA1K,KAAA4mD,WAAA99C,KAAA,aAAA9I,KAAA2G,MAAAmC,KAAA9I,OACAA,KAAA2xD,WAAA7oD,KAAA,QAAA9I,KAAAq8C,OAAAvzC,KAAA9I,MACA,CACA,OAAA2lD,GACA,OAAA3lD,KAAAomD,QAAAtvC,MAAA9W,KAAA2mD,WAAAlB,QACA,CACA,IAAAmD,GACA,OAAA5oD,KAAA2mD,WAAAlB,SAAAzlD,KAAAomD,QAAAtvC,MAAA,GACA,CACA,IAAA1I,GACA,MAAAg4C,EAAApmD,KAAAomD,QACAA,EAAAoB,UAAA,KACAxnD,KAAA2mD,WAAArB,QAAAc,EAAAtvC,MACA,CACA,KAAA+xC,GACA,MAAAzC,EAAApmD,KAAAomD,QACAA,EAAA6B,QAAAjoD,KAAA2mD,WAAAlB,UACAzlD,KAAA2mD,WAAArB,QAAAc,EAAAtvC,MACA,EAEA,MAAA86C,WAAApJ,GACA,WAAA/9C,CAAAC,GACAwH,QACAq/C,GAAAvxD,KAAA0K,EAAA,CACAmnD,WAAA,IAAA9I,GAAA,CACA7K,KAAAxzC,EAAAwzC,KACAkI,QAAA17C,EAAA07C,QACAyC,MAAA,KACA7oD,KAAAsvD,MAAA,MAIAtvD,KAAA2xD,WAAA7oD,KAAA,SAAA,KACA9I,KAAAq8C,QAAA,IAEAr8C,KAAA4mD,WAAA99C,KAAA,OAAA,IAAA9I,KAAA2G,UACA3G,KAAA4mD,WAAA99C,KAAA,cAAA,IAAA9I,KAAA2G,UACA3G,KAAA4mD,WAAA99C,KAAA,OAAA,IAAA9I,KAAA6oD,SACA,CACA,QAAAC,GACA9oD,KAAA6xD,WAAAxV,QACA,CACA,MAAA/vC,CAAA28C,GACAjpD,KAAAq8C,SACAr8C,KAAA8xD,QAAA7I,EACA,CACA,KAAAJ,GACA7oD,KAAA+xD,SAAA7M,cACAllD,KAAAgyD,YAGAhyD,KAAAsvD,MAEA,CACA,IAAA1G,GACA,OAAA5kD,GAAAhE,KAAAssD,UAAA,CACA,CACA,KAAA3lD,CAAAqF,GACA,IAAAsgD,EACAtsD,KAAAmmD,UAAAR,UAGA3lD,KAAA+xD,SAAA7M,cACAllD,KAAA6xD,WAAAlJ,UACA3oD,KAAA6xD,WAAAxV,SACAr8C,KAAAssD,SAAAtrD,KAAAqO,IAAArD,EAAA07C,MAAA1nD,KAAAk+C,MAAAoO,SAAAtsD,KAAAiyD,mBAzEA,IA0EA//C,MAAAvL,SAGA3G,KAAAgyD,aAIA1F,EAAAtgD,EA9EA,IA8EAA,EAAA07C,MAAA51C,GAAA,EAAA9F,EAAA07C,MAAA1nD,KAAAk+C,MAAAoO,SAAA,EACAtsD,KAAAssD,SAAAtrD,KAAAoO,IAAApO,KAAAqO,IAAAi9C,EAAAtsD,KAAAiyD,mBAlFA,SAmFAjyD,KAAA2xD,WAAApN,cACAryC,MAAAvL,SAEA,CACA,IAAAyH,GACA,MAAA+3C,EAAAnmD,KAAAmmD,UAAA/rC,EAAApa,KAAA+xD,SAAA7M,cAxFA,GAwFAllD,KAAAoa,SAAAhD,EAAApX,KAAAssD,UAAAlyC,EACA,IAAA6uC,EAAAjpD,KAAAomD,QAAApmD,KAAAk+C,MAAA9mC,GACApX,KAAA0mD,SAAAP,EAAAjB,YAAA+D,KACAA,EAAAjoD,KAAAoO,IAAApO,KAAAqO,IAAA45C,EAAA9C,EAAA/2C,KAAA+2C,EAAA92C,KACArP,KAAAssD,SAAA,GAEAtsD,KAAAomD,QAAA8B,SAAAloD,KAAAk+C,KAAA+K,EACA,CACA,IAAAqG,GACAtvD,KAAA2xD,WAAAnN,gBACAxkD,KAAA4G,KACA,CACA,GAAAA,GAAA,CACA,SAAAorD,GACA,MAAA7L,EAAAnmD,KAAAmmD,UAAA+L,EAAAlyD,KAAAomD,QAAApmD,KAAAk+C,MAAAiI,EAAA/2C,IAAA+2C,EAAA/2C,IAAA+2C,EAAA92C,IACArP,KAAA8xD,QAAAI,EACA,CACA,OAAAJ,CAAA7I,GACAjpD,KAAA6xD,WAAA1J,OAAA,CACAc,SAAAA,EACA36C,SA5GA,IA6GA66C,KAAA,IAAA39C,KACAu9C,GAAAK,YAAA39C,MAAA,KAAAD,EAAA,GAGA,EAEA,MAAA2mD,WAAA3J,GACA,WAAA/9C,CAAAC,GACAwH,QACAq/C,GAAAvxD,KAAA0K,EAAA,CACAmF,OAAA,CAAA,EACArK,YAAA,CAAA,EACAqO,OAAA,CAAA,GAEA,CACA,MAAAs0C,CAAAiK,GAAA,CACA,IAAAhkD,GACApO,KAAAqyD,qBACAryD,KAAAmoD,OAAAnoD,KAAA6P,OACA,CACA,IAAA+4C,GACA,OAAA5kD,GAAAhE,KAAA6T,OAAA7M,GAlIA,GAkIAhD,GAAAhE,KAAA6T,OAAA/M,GAlIA,CAmIA,CACA,KAAA+hD,GACA7oD,KAAAmoD,OAAAnoD,KAAAwF,aACAxF,KAAAsoD,UACAtoD,KAAAsoD,SAAA3jD,MAEA,CACA,cAAA2tD,CAAA3mD,EAAAuD,GACAlP,KAAA6T,OAAA,CAAA,EACA7T,KAAA6P,OAAAlE,EACA3L,KAAAwF,YAAA0J,CACA,CACA,WAAAqjD,CAAAjK,GACAA,GAAAlkD,EAAAkkD,GACAtoD,KAAAsoD,SAAAA,EAGAA,OAAA3/C,CAEA,CACA,kBAAA0pD,GACAryD,KAAA6T,OAAA,CACA/M,GAAA9G,KAAAwF,YAAAsB,EAAA9G,KAAA6P,OAAA/I,GAAA,EACAE,GAAAhH,KAAAwF,YAAAwB,EAAAhH,KAAA6P,OAAA7I,GAAA,GAEAhH,KAAA6P,OAAA,CACA7I,EAAAhH,KAAA6P,OAAA7I,EAAAhH,KAAA6T,OAAA7M,EACAF,EAAA9G,KAAA6P,OAAA/I,EAAA9G,KAAA6T,OAAA/M,EAEA,EAEA,MAAA0rD,GACA,WAAA/nD,CAAAC,GACA,MAAAi1C,EAAA,MAAAj1C,EAAAwzC,KAEAh1C,EAAAs6C,GAAA,sCADA7D,EAAA,aAAA,YACA,kBACA4R,GAAAvxD,KAAA0K,EAAA,CACAxB,QAAAA,EACAupD,YAAA,EACArM,QAAA,IAAAwB,GAAA1+C,GACAwpD,cAAAhoD,EAAA07C,QACAuM,cAAAjoD,EAAAioD,cACA/sD,KAAA+5C,EAAA,QAAA,WAEA3/C,KAAA0yD,cAAA5pD,KAAA0oD,GAAAxxD,KAAA6uC,QAAA/lC,KAAA9I,OACAA,KAAA6X,UAAA+6C,YAAA1pD,GACAwB,EAAAioD,eACA3yD,KAAA+1B,MAEA,CACA,OAAA8Y,GACA,MAAAqP,EAAAl+C,KAAAk+C,KAAAiI,EAAAnmD,KAAAmmD,UAAA0M,EAAA1M,EAAAvgD,KAAA8sD,EAAA1yD,KAAA0yD,cAAAI,EAAAD,EAAA1M,EAAA5d,MACA,IAAA3iC,EAAA5E,KAAAwP,MAAAqiD,EAAAC,GAAA3pD,EAAAnI,KAAAwP,OAAAkiD,EAAAxU,GAAA4U,GAEA9yD,KAAAkJ,QAAA2+C,MAAAkL,QADAD,GAAA,EACA,OAGA,GAEA3pD,EAAAvD,EAAAitD,EACAjtD,EAAAitD,EAAA1pD,EAEAA,EAAA,IACAvD,GAAAuD,EACAA,EAAA,GAEAnJ,KAAAyyD,cAAA7sD,IACA5F,KAAAkJ,QAAA2+C,MAAA7nD,KAAA4F,MAAAA,EAAA,KACA5F,KAAAyyD,YAAA7sD,GAEA5F,KAAAomD,QAAA8B,SAAAhK,EAAA/0C,EACA,CACA,IAAA4sB,GACA/1B,KAAAkJ,QAAA2+C,MAAAjyB,QA5MA,GA6MA51B,KAAAkJ,QAAA2+C,MAAAmL,WAAA,SACA,CACA,IAAAC,GACAjzD,KAAA2yD,gBACA3yD,KAAAkJ,QAAA2+C,MAAAjyB,QAAA,EAEA,EAEA,MAAAs9B,GAAA,CACAxtD,KAAA,WACA4R,MAAA,EACA67C,WAAA,IACAC,oBAAA,EACA1M,SAAA,EACA2M,WAAA,EACAC,qBAAA,EACAC,eAAA,KAAA,EACAC,eAAA,EACAC,SAAA,CACAC,aAAA,kBACAC,gBAAA,qBACAC,gBAAA,eAIA,MAAAC,WAAArpD,GACA,WAAAC,CAAAvB,EAAAwB,GACAwH,QACAlS,KAAAkJ,QAAAA,EAAAA,EAAA,IAAAA,EACAlJ,KAAA8zD,aAAAppD,GACA1K,KAAA2K,OAAAf,KAxOA,OAwOA6nD,GAxOA,UAyOA,MAAAsC,EAtpCA,MACA,MAAAjR,SAAAA,GAAAxB,KACA,OAAAwB,EAAAV,KAAAU,EAAAlB,OAAA,EAopCAoS,GACAh0D,KAAAi0D,QAAAj0D,KAAA0K,QAAA2oD,WAAAU,EACA,MAAAG,EAAA1Q,GAAA,mCACA,GAAAxjD,KAAAi0D,QAOA,OANA5Q,GAAAn6C,EAAA,sBACA26C,GAAAqQ,EAAAhrD,QACAqoD,GAAAvxD,KAAA,CACAm0D,cAAAjrD,EACAkrD,eAAAlrD,EAAAgW,SAAA,KAIAhW,EAAA2+C,MAAAwM,SAAA,SACAhR,GAAAn6C,EAAA,qBAzrCA,EAAA8hB,EAAAspC,KAEA,IADAtpC,EAAA4nC,YAAA0B,GACAtpC,EAAAwN,aAAA87B,GACAA,EAAA1B,YAAA5nC,EAAAwN,WACA,EAurCA+7B,CAAArrD,EADAs6C,GAAA,uCAEAK,GAAAqQ,EAAAhrD,GACA,MAAAsrD,EAAAtrD,EAAAgW,SAAA,GAAAyyC,EAAA,IAAA3N,GAAA96C,GAAAk9C,EAAA,IAAAwB,GAAA4M,GAAA7N,EAAA,IAAAf,GAAA,CACA18C,QAAAsrD,EACA38C,UAAA3O,EACAy7C,cAAA3kD,KAAA0K,QAAA4M,OACAi8C,EAAAvzD,KAAA0K,QAAA6oD,eAAA3M,EAAA,IAAAmH,GAAA7kD,EAAA,CACAsmD,YAAA,OACAT,gBAAA,EACAU,kBAAA,EACAT,kBAAA,EACAF,WAAA9uD,KAAA0K,QAAA4M,KACA41C,iBAAAltD,KAAA0K,QAAAwiD,iBACAvmD,MAAAqF,IACA26C,EAAA9X,UACA,MAAA4lB,EAAAzwD,GAAAgI,EAAAlF,EAAAwlD,UAAAoI,EAAA1wD,GAAAgI,EAAAhF,EAAAslD,UAAAqI,EAAA,EAAAF,GAAAC,EAAAE,EAAA,EAAAF,GAAAD,GAAAz0D,KAAAo0D,eAAAnsD,SAAA+D,EAAAjB,MAAAoD,UACAolD,EAAAvnD,IAAAhM,KAAA2lD,UAAAgB,EAAA7/C,EAAA6+C,SAAAgP,GAAAhO,EAAA3/C,EAAA2+C,SAAAiP,GACAhO,EAAA/oC,UAGA+oC,EAAAvK,QACA,IAEAwY,EAAA,IAAApO,GAAA,CACAL,QAAAA,EACAO,WAAAA,EACAC,WAAAA,EACAF,QAAA1mD,KAAA0K,QAAAg8C,UACAoO,EAAA,IAAApD,GAAA,CACAtL,QAAAA,EACAO,WAAAA,EACAC,WAAAA,EACA+K,WAAAA,IACAoD,EAAA,IAAA5C,GAAA,CACAhK,OAAAZ,IACAvnD,KAAAg1D,SAAAzN,EAAAzgD,EAAAygD,EAAAvgD,EAAA,IAGAo/C,EAAAt9C,KAAA0oD,IAAA,KACAxxD,KAAAi1D,WAAA7O,EAAAp/C,EACAhH,KAAAk1D,YAAA9O,EAAAt/C,EACA9G,KAAA8L,QAAA2lD,GAAA,CACAwD,UAAAj1D,KAAAi1D,UACAC,WAAAl1D,KAAAk1D,YACA,IAEAl1D,KAAA0K,QAAA4oD,sBACAtzD,KAAAm1D,oBAAAn1D,KAAAo1D,aAAAtsD,KAAA9I,MACAypD,GAAAvgD,EAAA,QAAAlJ,KAAAm1D,sBAEA5D,GAAAvxD,KAAA,CACAomD,QAAAA,EACAO,WAAAA,EACAmO,aAAAA,EACAC,iBAAAA,EACAnO,WAAAA,EACAiO,KAAAA,EACAlD,WAAAA,EACA0D,QAAA,EACA1P,SAAA,EACAwO,cAAAK,EACAS,UAAA,EACAC,WAAA,EACAd,eAAAlrD,EAAAgW,SAAA,KAEAlf,KAAAs1D,UAAA,KACAt1D,KAAAs1D,UAAA,KACAt1D,KAAAu1D,UAAA,KACAv1D,KAAAw1D,QAAA,EACAx1D,KAAA4mD,WAAAhgD,IAAA,EAAA5G,KAAAy1D,QAAA,EAEA9O,EAAA9X,UACA7uC,KAAA0K,QAAA8oD,eACAxzD,KAAA01D,qBAEA11D,KAAA8I,KAAA9I,KAAA2K,OAAA3K,KAAA0K,QACA,CACA,YAAAopD,CAAAppD,GACA1K,KAAA0K,QAAAmP,GAAA,CAAA,EAAA7Z,KAAA0K,QAAAwoD,GAAAxoD,EACA,CACA,YAAA0qD,CAAAppD,GACA,GAAAA,EAAAk0C,QACA,OAEAlgD,KAAAw1D,SACAx1D,KAAAw1D,QAAA,EACAx1D,KAAAy1D,QAAA,EACAz1D,KAAA4mD,WAAAG,MAAA,EAAA/mD,KAAAy1D,UAEAtH,aAAAnuD,KAAA21D,eACA31D,KAAA21D,cAAArI,YAAA,IAAAttD,KAAAu1D,aAAA,IACA,MAAAn+C,EA5vCA,CAAApL,IACA,MAAAgR,EAAAhR,EAAA4pD,YACA,IAAAx+C,EASA,OARApL,EAAA6pD,iBACAltD,IAAAqU,GAAAA,KACA5F,EAAApL,EAAA6pD,YAGA7pD,EAAA8pD,QAAA9pD,EAAAkyC,OAAAlyC,EAAA+pD,gBACA3+C,EAAA,IAAApL,EAAA8pD,QAEA1+C,CAAA,EAivCAw+C,CAAA5pD,GACAoL,IACApX,KAAAy1D,SAAAr+C,EACApX,KAAA4mD,WAAAnlD,KAAA,EAAAzB,KAAAy1D,UAEAzpD,EAAAE,gBACA,CACA,WAAA24C,GACA7kD,KAAA2mD,WAAA3/C,EAAA69C,aACA,CACA,WAAAI,CAAA51C,EAAAD,GACApP,KAAA2mD,WAAA3/C,EAAAi+C,YAAA51C,EAAAD,EACA,CACA,MAAA4F,GACA,OAAAhV,KAAA2mD,WAAA3/C,EAAApB,IACA,CACA,YAAAowD,GACA,OAAAh2D,KAAAm0D,cAAA6B,YACA,CACA,WAAAC,GACA,OAAAj2D,KAAAm0D,cAAA8B,WACA,CACA,OAAAC,GACAl2D,KAAAi0D,SACAj0D,KAAAm2D,gBAEA,CACA,UAAAC,CAAA1rD,GACA1K,KAAA8zD,aAAAppD,GACAA,EAAA8oD,eACAxzD,KAAA01D,oBAEA,CACA,KAAAW,GACAr2D,KAAAi0D,QACAj0D,KAAAm0D,cAAAc,UAAA,IAGAj1D,KAAAomD,QAAA+B,OAAA,CACArhD,EAAA,EACAE,EAAA,IAEAhH,KAAAs2D,OAAA,GAEA,CACA,cAAAH,GACAn2D,KAAA2mD,WAAA9X,UACA7uC,KAAA60D,KAAA/tD,EAAAo+C,eACAllD,KAAAomD,QAAA8B,SAAA,IAAAloD,KAAA2mD,WAAA7/C,EAAAuI,KAEArP,KAAA60D,KAAA7tD,EAAAk+C,eACAllD,KAAAomD,QAAA8B,SAAA,IAAAloD,KAAA2mD,WAAA3/C,EAAAqI,IAEA,CACA,OAAAknD,GACA,MAAA5P,EAAA3mD,KAAA2mD,WACAA,EAAA9X,UACA7uC,KAAAs2D,OAAA3P,EAAAV,UACAjmD,KAAAomD,QAAA+B,OAAAxB,EAAAX,oBACA,CACA,MAAAlU,GACA9xC,KAAA2lD,SAAA,CACA,CACA,OAAA6Q,GACAx2D,KAAA2lD,SAAA,CACA,CACA,QAAAqP,CAAAluD,EAAAE,GACAhH,KAAAi0D,SACAj0D,KAAAm0D,cAAAe,WAAAlxD,GAAA8C,IACA9G,KAAAm0D,cAAAc,UAAAjxD,GAAAgD,MAGAhH,KAAA2mD,WAAA9X,UACA7uC,KAAAomD,QAAA+B,OAAA,CACArhD,EAAAA,EACAE,EAAAA,IAGA,CACA,gBAAAyvD,CAAA3vD,EAAAE,EAAAshD,GACA,IAAA38C,EAAAuD,EACAlP,KAAAi0D,QACAj0D,KAAAg1D,SAAAluD,EAAAE,IAGA2E,EAAA,CACA7E,EAAA9G,KAAAomD,QAAAt/C,EACAE,EAAAhH,KAAAomD,QAAAp/C,GAEAkI,EAAA,CACApI,EAAAA,EACAE,EAAAA,GAEAhH,KAAA+0D,iBAAAzC,eAAA3mD,EAAAuD,GACAlP,KAAA+0D,iBAAAxC,YAAAjK,GACAtoD,KAAA+0D,iBAAApuD,QAEA,CAEA,WAAA+vD,GAOA,CACA,OAAA7rD,GAEAy/C,GADAtqD,KAAAkJ,QACA,QAAAlJ,KAAAm1D,qBACAn1D,KAAA4mD,YACA5mD,KAAA4mD,WAAA/7C,UAEA7K,KAAA2xD,YACA3xD,KAAA2xD,WAAA9mD,SAEA,CACA,MAAAyrD,CAAAx/C,GACA9W,KAAA2mD,WAAArB,QAAAxuC,GACA9W,KAAAomD,QAAA6B,QAAAnxC,EACA,CACA,kBAAA4+C,GACA,CAEA,QAAAiB,GAWA,CAEA,WAAAC,GAcA,CACA,SAAAtB,CAAApX,GACA,MAAAkI,EAAApmD,KAAAomD,QAAAD,EAAAnmD,KAAA2mD,WAAAzI,GAAAyT,EAAA3xD,KAAA2xD,WAAAI,EAAA/xD,KAAA60D,KAAA3W,GAAA2Y,EAAA,IAAArE,GAAA,CACAtU,KAAAA,EACAkI,QAAAA,EACAD,UAAAA,EACAtuC,UAAA7X,KAAAkJ,QACAypD,cAAA3yD,KAAA0K,QAAA0oD,qBAEAjN,EAAAr9C,KAAA0oD,IAAA,KACAqF,EAAAhoB,SAAA,IAEAkjB,EAAAjpD,KAAA0oD,IAAA,KACAqF,EAAA9gC,MAAA,IAEA/1B,KAAAk+C,EAAA,WAAA,IAAA0T,GAAA,CACA1T,KAAAA,EACA6T,SAAAA,EACA3L,QAAAA,EACAuL,WAAAA,EACA/K,WAAA5mD,KAAA4mD,WACAT,UAAAA,EACAO,QAAA1mD,KAAA0K,QAAAg8C,QACAtsC,SAAApa,KAAA0K,QAAA0P,UApgBA,IAqgBA63C,mBAAAjyD,KAAA0K,QAAAunD,oBArgBA,GAsgBArrD,IAAA,KACAiwD,EAAA5D,OACAjzD,KAAA8L,QAAA,YAAA,CACAoyC,KAAAA,EACA+W,UAAAj1D,KAAAi1D,UACAC,WAAAl1D,KAAAk1D,YACA,GAGA,EAGA,MAAA4B,WAAAjW,GACA,WAAAp2C,CAAA0sC,GACAjlC,MAAAilC,GACA,MAAA15B,EAAAzd,KAAAm3C,YAAA15B,QAAAs5C,EAAAt5C,EAAAs5C,OACA38C,EAAAqD,EAAAu5C,YAt+WA,IAAA,GAu+WAC,EAAAx5C,EAAAw5C,SAAAj3D,KAAAi3D,SAAA,IAAApD,GAAAp2C,EAAAy5C,WAAA,CACA98C,SAAAA,EACA63C,mBAz+WA,EA0+WAqB,qBAAA,EACAh8C,MAAA,EACA6/C,OAAAn3D,KAAAovD,MAAAtmD,KAAA9I,QAEA+2D,EAAA9jC,YACAjzB,KAAAo3D,cAAA,IAAAxP,GAAAmP,EAAA7tD,UAEA,MAAAmuD,EAAA,SAAAlR,EAAA92C,EAAAD,GACA+2C,EAAAtB,cACAsB,EAAAlB,YAAA51C,IAn/WA,IAm/WAD,GAn/WA,IAo/WA,EACAioD,EAAAJ,EAAAtQ,WAAA7/C,GACAuwD,EAAAJ,EAAAtQ,WAAA3/C,GACAiwD,EAAAT,SACA,CACA,WAAA1W,CAAAC,EAAAC,GACA,MAAA7I,EAAAn3C,KAAAm3C,YACAzsC,EAAAysC,EAAA15B,QAAA/S,QAAA4sD,SACA,IAAA3R,EAAA3F,EAAAE,QASA,OARA/7C,EAAAuG,EAAAjG,OAKAkhD,EAJAj7C,EAAAjG,KAAA,SAAAiG,EAAAjG,IAIAu7C,EAAAt1C,EAAAjG,IAAA,OAHAq8C,GAAAd,KAAA77C,EAAAgzC,EAAAY,eAMA,IAAArtC,GAAAi7C,IAAAxhD,EAAAgzC,EAAAogB,kBAAApzD,EAAAgzC,EAAAa,kBACA,CACA,KAAArxC,GACA3G,KAAAi3D,SAAAnlB,QACA,CACA,IAAArwC,GACA,CACA,KAAA2tD,CAAA5jD,GACA,MAAAiS,EAAAzd,KAAAm3C,YAAA15B,QAAAs5C,EAAAt5C,EAAAs5C,OACA,IAAAS,EAAA,IAAA/jD,GAAAjI,EAAA0pD,WAAA1pD,EAAAypD,WACA8B,EAAA9jC,WACAxV,EAAAg6C,UAAAD,EAAA1jD,OAAA,IACA9T,KAAAo3D,cAAAjP,OAAAqP,GACAT,EAAA9jC,UAAAukC,EAAA1wD,EAAA0wD,EAAAxwD,IAGAwwD,EAAAA,EAAA7jD,KAAA8J,EAAAg3B,KAAA3gC,OAAA,IAEA2J,EAAA3R,QAAA9I,EAAA,CAAAwxC,IAAAgjB,GACA,CACA,GAAA5wD,GACA5G,KAAAi3D,SAAAT,SACA,CACA,SAAAjW,GACA,OAAAn/C,EAAAK,IACA,EAGA,MAAAi2D,GACA,WAAAjtD,CAAA0sC,GACAn3C,KAAAm3C,YAAAA,CACA,CACA,WAAA2I,CAAAC,EAAAC,GACA,MAAA7I,EAAAn3C,KAAAm3C,YACAvF,EAAAuF,EAAA15B,QAAA/S,QAAAknC,WACA,IAAA+T,EAAA/T,IAAA,IAAAA,EAAA+lB,SASA,OARAhS,IAEAA,EADA/T,EAAAntC,KAAA,SAAAmtC,EAAAntC,IACAu7C,EAAApO,EAAAntC,IAAA,OAGAq8C,GAAAd,IAGA2F,IAAAxhD,EAAAgzC,EAAAY,eAAA5zC,EAAAgzC,EAAAogB,eACA,CACA,KAAA5wD,CAAAgH,GACA,MAAA8P,EAAAzd,KAAAm3C,YAAA15B,QACAA,EAAAm6C,WACAn6C,EAAAo6C,SAAAlxD,MAAAgH,EACA,CACA,IAAAlM,CAAAkM,GACA3N,KAAAm3C,YAAA15B,QACAo6C,SAAAp2D,KAAAkM,EACA,CACA,GAAA/G,CAAAm5C,EAAAC,GACA,MAAAviC,EAAAzd,KAAAm3C,YAAA15B,QAAAs6B,EAAA/3C,KAAAm3C,YAAAY,YACA1hC,EAAAoH,EAAAo6C,SAAA57C,SACA87B,GAAAA,EAAA/F,YAAAgO,EAAAE,SACAziC,EAAAm6C,WAEAvhD,EAAAlR,WACAsY,EAAAq6C,WAAAzhD,GAEAoH,EAAAo6C,SAAAjxD,KACA,CACA,SAAA25C,GACA,OAAAn/C,EAAAC,KACA,EAGA,SAAA02D,GAAAtzD,EAAA0Q,GACA,OAAAA,EAAAtD,WAAA,KAAApN,GAAA0Q,EAAA6iD,cAAAnmD,WAAA,KAAApN,CACA,CAEA,MAAAwzD,GACA,WAAAxtD,CAAAhE,EAAAyxD,EAAAC,GACAn4D,KAAAyG,KAAAA,EACAzG,KAAAmvC,YAAA+oB,EACAl4D,KAAAovC,YAAA+oB,EACAh0D,EAAA+zD,KACAl4D,KAAAivC,YAAAxoC,EAAAhB,UAEAtB,EAAAg0D,KACAn4D,KAAAkvC,YAAAzoC,EAAA0H,UAEAnO,KAAAqvC,MAAAhsC,CACA,CACA,IAAAisC,QACA3mC,IAAA3I,KAAAivC,aACAjvC,KAAAyG,KAAA8oC,iBAAAvvC,KAAAivC,YAAA/rC,QAEAyF,IAAA3I,KAAAkvC,aACAlvC,KAAAyG,KAAA8oC,iBAAAvvC,KAAAkvC,YAAA/rC,GAEAnD,KAAAyG,KAAA+oC,aACA,CACA,IAAAC,QACA9mC,IAAA3I,KAAAmvC,aACAnvC,KAAAyG,KAAA8oC,iBAAAvvC,KAAAmvC,YAAAjsC,QAEAyF,IAAA3I,KAAAovC,aACApvC,KAAAyG,KAAA8oC,iBAAAvvC,KAAAovC,YAAAjsC,GAEAnD,KAAAyG,KAAA+oC,aACA,EAGA,MAAA4oB,GAAA,CACApiC,MAAA,CACAN,OAAA,CAAA,GAEAyF,SAAA13B,EACA23B,OAAA33B,EACAkG,OAAA,GACAioC,YAAA,EACAymB,cAAAn2D,EACAo2D,YAAAp2D,GAKA,MAAAq2D,WAAAxmB,GACA,WAAAtnC,CAAAkB,EAAAuD,EAAAxE,GAEAwH,MADAxH,EAAAmP,GAAA,CAAA,EAAAu+C,GAAA1tD,IAEA1K,KAAAizC,yBACAjzC,KAAAw4D,cACAx4D,KAAA42B,KAAA,IAAA8F,GAAA18B,KAAA0K,SACA1K,KAAA42B,KAAAjN,KAAAppB,GACAP,KAAAke,OAAAma,OAAAr4B,KAAA42B,MACA52B,KAAAy4D,aAAAz4D,KAAA04D,aAAA,IAAAjlD,GACAzT,KAAA24D,WAAAhtD,GACA3L,KAAA44D,WAAA1pD,GACAlP,KAAA+X,QAAA/X,KAAA0K,QAAAqN,SACA/X,KAAA64D,SAAA,GACA10D,EAAAuG,IAAAA,EAAAf,QACA3J,KAAA2J,OAAAe,EAAAf,OAEA,CACA,oBAAA0pC,CAAAC,GACAtzC,KAAAizC,uBAAAK,GAAAtzC,KAAAmwC,SACA,CACA,sBAAA8C,CAAAK,GACA,GAAAtzC,KAAAyd,SAAAzd,KAAAyd,QAAAg2B,YAAA,CACA,MAAAqlB,EAAA94D,KAAAyd,QAAAs7C,SACAruD,EAvsHA,SAAAylC,GACA,MAAA9mC,EAAA,CAAA,EAgCA,OA9BAlF,GADAgsC,EAAAA,GAAA,CAAA,GACAvS,OAAA,OAAAuS,EAAAvS,OACAv0B,EAAA0O,QAAAo4B,EAAAvS,MAEAz5B,EAAAgsC,EAAA5iC,OAAA,OAAA4iC,EAAA5iC,OACAlE,EAAAkE,KAAA4iC,EAAA5iC,MAEApJ,EAAAgsC,EAAAxkC,OAAA,OAAAwkC,EAAAxkC,OACAtC,EAAAsC,KAAAwkC,EAAAxkC,MAEAxH,EAAAgsC,EAAAkoB,gBAAA,OAAAloB,EAAAkoB,gBACAhvD,EAAAgvD,cAAAloB,EAAAkoB,eAEAl0D,EAAAgsC,EAAA6oB,QAAA,OAAA7oB,EAAA6oB,QACA3vD,EAAA2vD,MAAA7oB,EAAA6oB,OAEA70D,EAAAgsC,EAAA8oB,QAAA,OAAA9oB,EAAA8oB,QACA5vD,EAAA4vD,MAAA9oB,EAAA8oB,OAEA90D,EAAAgsC,EAAAjhC,KAAA,OAAAihC,EAAAjhC,KACA7F,EAAA6F,GAAAihC,EAAAjhC,IAEA/K,EAAAgsC,EAAAmoB,cAAA,OAAAnoB,EAAAmoB,cACAjvD,EAAAivD,YAAAnoB,EAAAmoB,aAEAn0D,EAAAgsC,EAAA+oB,MAAA,OAAA/oB,EAAA+oB,MACA7vD,EAAA6vD,IAAA/oB,EAAA+oB,KAEA/0D,EAAAgsC,EAAAgpB,MAAA,OAAAhpB,EAAAgpB,MACA9vD,EAAA8vD,IAAAhpB,EAAAgpB,KAEA9vD,CACA,CAqqHA+vD,CAAA9lB,GAAAtzC,KAAAmwC,UACA,GAAAmD,EAAA,CACA,GAAAnvC,EAAAuG,EAAAiB,MAAA,CACA,IAAAA,EAAAmtD,EAAApuD,EAAAiB,MACAA,GAAAxH,EAAAuG,EAAA2tD,iBACA1sD,EAAAA,EAAAulC,aAAAxmC,EAAA2tD,gBAEAr4D,KAAAyF,OAAAkG,EACA,MACAxH,EAAAuG,EAAAsuD,QAAA70D,EAAAuG,EAAAuuD,QACAj5D,KAAAyF,OAAA,IAAAgO,GAAA/I,EAAAsuD,MAAAtuD,EAAAuuD,QAEA,GAAA90D,EAAAuG,EAAAwE,IAAA,CACA,IAAAA,EAAA4pD,EAAApuD,EAAAwE,IACAA,GAAA/K,EAAAuG,EAAA4tD,eACAppD,EAAAA,EAAAgiC,aAAAxmC,EAAA4tD,cAEAt4D,KAAAmO,OAAAe,EACA,MACA/K,EAAAuG,EAAAwuD,MAAA/0D,EAAAuG,EAAAyuD,MACAn5D,KAAAmO,OAAA,IAAAsF,GAAA/I,EAAAwuD,IAAAxuD,EAAAyuD,MAEAh1D,EAAAuG,EAAA6C,OAAAvN,KAAAuN,SAAA7C,EAAA6C,OACAvN,KAAA2J,OAAA,IACA3J,KAAAuN,KAAA7C,EAAA6C,OAEAvN,KAAAmwC,SAAAmD,EACAtzC,KAAAiyC,YACAjyC,KAAAi0B,OAAAj0B,KAAA0K,QACA,MAEA1K,KAAA0K,QAAAmP,GAAA,CAAA,EAAAnP,EAAA1K,KAAA0K,QAEA,CACA,CACA,WAAA8kC,CAAAmE,GACA3zC,KAAAyd,SAAAzd,KAAAyd,QAAAg2B,aACAzzC,KAAAyd,QAAA47C,sBAAAr5D,KAAA2zC,EAEA,CAMA,WAAA0D,GACA,OAAAr3C,KAAAy+C,yBAAAz+C,KAAAy+C,yBAAAt1C,WAAAnJ,KAAAy4D,YACA,CACA,UAAAE,CAAAlzD,GACA,MAAA6zD,EAAA7zD,aAAAutC,GACAumB,EAAAv5D,KAAA0K,QAAA2tD,eAAAn2D,EACA,IAAAiuC,EACAmpB,IAAA7zD,EAAAyrC,aAAAqoB,UAGA5wD,IAAAlD,IACAzF,KAAA2L,KAAAlG,GAEAzF,KAAAw5D,6BACA,OAAA/zD,EACAzF,KAAA4vB,kBACA5vB,KAAAy4D,cAAAz4D,KAAAy+C,0BAAAz+C,KAAA4vB,iBAAAzmB,WACAnJ,KAAAy5D,wBACAz5D,KAAA05D,gBAAA,KAAA15D,KAAAy4D,eAGAhzD,aAAAorC,IACAV,EAAA1qC,EAAAsY,MAAAoyB,SACAA,GACAnwC,KAAA05D,gBAAAvpB,EAAAr+B,IAEA9R,KAAA4vB,gBAAAnqB,EACAzF,KAAA4vB,gBAAAvR,YAAAzU,KAAA5J,OAEAyF,aAAAgO,IACAzT,KAAA05D,gBAAA,KAAAj0D,GACAzF,KAAAy4D,aAAAhzD,EACAzF,KAAA4vB,iBACA5vB,KAAAy5D,yBAGAH,IACAnpB,EAAA1qC,EAAA0qC,SACAA,GACAnwC,KAAA05D,gBAAAvpB,EAAAr+B,IAEA9R,KAAA4vB,gBAAAnqB,EAAAyrC,aAAAqoB,GACAv5D,KAAA4vB,gBAAAvR,YAAAzU,KAAA5J,OAEA,CACA,MAAAyF,CAAAA,EAAAmkB,GAQA,OAPA3lB,EAAAwB,KACAmkB,GAAA5pB,KAAAyd,SACAzd,KAAAyd,QAAA63B,gBAAAqkB,iBAAA,IAAA1B,GAAAj4D,KAAAyF,IAEAzF,KAAA24D,WAAAlzD,GACAzF,KAAA6uC,WAEA7uC,KAAA4vB,gBAAA5vB,KAAA4vB,gBAAA5vB,KAAAy4D,YACA,CACA,eAAAiB,CAAA/tD,EAAAiuD,GACA55D,KAAA0K,QAAAiB,KAAAA,EACAiuD,GACA55D,KAAA0K,QAAAsuD,MAAAY,EAAA9yD,EACA9G,KAAA0K,QAAAuuD,MAAAW,EAAA5yD,IAGAhH,KAAA0K,QAAAsuD,MAAA,KACAh5D,KAAA0K,QAAAuuD,MAAA,KAEA,CAQA,aAAAY,CAAA91D,GACA,IAAAA,EAcA,OAHA/D,KAAA85D,iBACA95D,KAAA85D,eAAA,IAAA3nC,GAAAnyB,KAAAq3C,cAAA,KAAA,OAEAr3C,KAAA85D,eAbA,KAAA/1D,aAAAouB,IAMA,MAAA,IAAAvpB,MAAA,gDALA7E,EAAAgS,KAAA,KACA/V,KAAA85D,eAAA/1D,EACA/D,KAAAyF,OAAA1B,EAAAsR,MAYA,CAIA,WAAAkiC,GACA,OAAAv3C,KAAA0+C,yBAAA1+C,KAAA0+C,yBAAAv1C,WAAAnJ,KAAA04D,YACA,CACA,UAAAE,CAAAzqD,GACA,MAAA4rD,EAAA5rD,aAAA6kC,GACAumB,EAAAv5D,KAAA0K,QAAA4tD,aAAAp2D,EACA,IAAAiuC,EACA4pB,IAAA5rD,EAAA+iC,aAAAqoB,UAGA5wD,IAAAwF,IACAnO,KAAAkP,GAAAf,GAEAnO,KAAAg6D,6BACA,OAAA7rD,EACAnO,KAAA8vB,kBACA9vB,KAAA04D,cAAA14D,KAAA0+C,0BAAA1+C,KAAA8vB,iBAAA3mB,WACAnJ,KAAAi6D,wBACAj6D,KAAAk6D,cAAA,KAAAl6D,KAAA04D,eAGAvqD,aAAA0iC,IACAV,EAAAhiC,EAAA4P,MAAAoyB,SACAA,GACAnwC,KAAAk6D,cAAA/pB,EAAAr+B,IAEA9R,KAAA8vB,gBAAA3hB,EACAnO,KAAA8vB,gBAAAzR,YAAAzU,KAAA5J,OAEAmO,aAAAsF,IACAzT,KAAAk6D,cAAA,KAAA/rD,GACAnO,KAAA04D,aAAAvqD,EACAnO,KAAA8vB,iBACA9vB,KAAAi6D,yBAGAF,IACA5pB,EAAAhiC,EAAAgiC,SACAA,GACAnwC,KAAAk6D,cAAA/pB,EAAAr+B,IAEA9R,KAAA8vB,gBAAA3hB,EAAA+iC,aAAAqoB,GACAv5D,KAAA8vB,gBAAAzR,YAAAzU,KAAA5J,OAEA,CACA,MAAAmO,CAAAA,EAAAyb,GAQA,OAPA3lB,EAAAkK,KACAyb,GAAA5pB,KAAAyd,SACAzd,KAAAyd,QAAA63B,gBAAAqkB,iBAAA,IAAA1B,GAAAj4D,UAAA2I,EAAAwF,IAEAnO,KAAA44D,WAAAzqD,GACAnO,KAAA6uC,WAEA7uC,KAAA8vB,gBAAA9vB,KAAA8vB,gBAAA9vB,KAAA04D,YACA,CACA,aAAAwB,CAAAhrD,EAAAirD,GACAn6D,KAAA0K,QAAAwE,GAAAA,EACAirD,GACAn6D,KAAA0K,QAAAwuD,IAAAiB,EAAArzD,EACA9G,KAAA0K,QAAAyuD,IAAAgB,EAAAnzD,IAGAhH,KAAA0K,QAAAwuD,IAAA,KACAl5D,KAAA0K,QAAAyuD,IAAA,KAEA,CAQA,aAAAiB,CAAAr2D,GACA,IAAAA,EAcA,OAHA/D,KAAAq6D,iBACAr6D,KAAAq6D,eAAA,IAAAloC,GAAAnyB,KAAAu3C,cAAA,KAAA,OAEAv3C,KAAAq6D,eAbA,KAAAt2D,aAAAouB,IAMA,MAAA,IAAAvpB,MAAA,gDALA7E,EAAA8R,MAAA,KACA7V,KAAAq6D,eAAAt2D,EACA/D,KAAAmO,OAAApK,EAAAsR,MAYA,CACA,iBAAAohC,GACAz2C,KAAAuvC,iBAAAvvC,KAAAyF,SAAA,UACAzF,KAAAuvC,iBAAAvvC,KAAAmO,SAAA,SACA,CACA,gBAAAohC,CAAA+qB,EAAA50D,GACA,MAAA+X,EAAAzd,KAAAyd,QACA,GAAA68C,aAAAzpB,KAAApzB,EAAA88C,aAAAD,EAAAv8C,MAAAjM,IAAA,CACA,MAAAq+B,EAAAmqB,EAAAv8C,MAAAoyB,SACAqqB,EAAAF,EAAA5vD,QAAAhF,KACA+0D,EAAA,KACA,MAAA18C,EAAAN,EAAAs7C,SAAA5oB,EAAAr+B,IACAwoD,EAAAv8C,EAAAmzB,aAAAspB,GACAx6D,KAAA0F,GAAA40D,GAAA,GACAt6D,KAAAwvC,aAAA,EAEA,GAAA/xB,EAAAs7C,SAAA5oB,EAAAr+B,IACA2oD,QAEA,CACA,MAAAC,EAAAj9C,EAAAk9C,oBAAAC,SAAAzqB,EAAA0qB,KACAH,GACAj9C,EAAAq9C,2BAAAlxD,KAAA8wD,EAAAK,WAAAN,GAEA,CACA,MAEAz6D,KAAA0F,GAAA40D,GAAA,EAEA,CACA,OAAAviD,CAAAA,GACA,MAAA1O,EAAArJ,KAAAqyC,SAAAt6B,GAIA,OAHA5T,EAAA4T,IACA/X,KAAA8zC,gBAEAzqC,CACA,CACA,oBAAAopC,CAAA/nC,GACA,IAAAwT,EAYA,OAXA9Z,EAAAsG,EAAAwT,QACAA,EAAAxT,EAAAwT,OAAAvZ,KAAA3E,KAAA0K,GAEAA,EAAAkzB,OACA1f,EAAA,IAAAsf,GAAA9yB,IAEAwT,IACAle,KAAAuyC,eAAAr0B,EACAA,EAAAsc,gBAAA,EACAx6B,KAAAke,OAAAma,OAAAna,IAEAA,CACA,CACA,oBAAAs0B,CAAA9nC,GACAtG,EAAAsG,EAAAwT,SACAle,KAAAke,OAAAtW,OAAA5H,KAAAuyC,gBACAvyC,KAAAyyC,qBAAA/nC,IAGA1K,KAAAuyC,eAAAte,OAAAvpB,EAEA,CACA,aAAAopC,GACA,GAAA9zC,KAAAuyC,eAAA,CACA,IAAA1+B,EAt7XA,EAu7XA,MAAAlK,EAAA3J,KAAA89C,YACA,IAAAkd,EAAAh6D,KAAAmF,MAAAwD,EAAArE,OAAA,GACA21D,EAAAD,EAAA,EACA,KAAAC,EAAA,GAAAtxD,EAAAsxD,GAAA7kD,OAAAzM,EAAAqxD,KACAC,IACAD,IAEA,IAAA1jC,EAAA3tB,EAAAqxD,GACApmC,EAAAjrB,EAAAsxD,GACA,MAAA3gC,EAAAt6B,KAAAuyC,eAAAhe,WACAtf,EAAAqlB,EAAArlB,MACAD,EAAAslB,EAAAtlB,OACA,IAAAkmD,EAAAvxD,EAAArE,OAAA,GAAA,EACA,MAAA8nB,EAAAwH,EAAAob,WAAA1Y,GAMA,IAAAjiB,EACA,GANA6lD,GAAAvxD,EAAArE,OAAA,GAAA8nB,EAAA,IACAwH,EAAA5tB,IAAAswB,EAAAtwB,GAAAomB,EAAAnY,GAAA2f,EAAA9tB,IAAAwwB,EAAAxwB,GAAAsmB,EAAApY,KACAkmD,GAAA,EACArnD,EAAA,GAGAqnD,EAAA,CACA,MAAA1nD,EAAAvT,EAAAyM,EAAA1L,KAAA8L,MAAAwqB,EAAAtwB,EAAA4tB,EAAA5tB,EAAAswB,EAAAxwB,EAAA8tB,EAAA9tB,IACAuO,EAAA,IAAA5B,IAAA6jB,EAAAxwB,EAAA8tB,EAAA9tB,GAAA,EAAA8tB,EAAA9tB,GAAAwwB,EAAAtwB,EAAA4tB,EAAA5tB,GAAA,EAAA4tB,EAAA5tB,GACA,KAAAhG,KAAAgD,IAAAwP,IACA6B,EAAAvO,GAAA+M,EACAwB,EAAArO,GAAAgO,EAAA,GAEAxB,EAAA,KAAA,GACA6B,EAAAvO,GAAAmO,EAAA,EACAI,EAAArO,GAAAgO,EAAAnB,GAEAL,GAAA,IAAA,EAAAA,GAAAA,EAAA,GACA6B,EAAArO,GAAAgO,GAEAxB,EAAA,GAAAA,EAAA,MACA6B,EAAAvO,GAAAmO,EACAI,EAAArO,GAAAgO,EAEA,KACA,CACA,MAAAmmD,EAAAn6D,KAAAmF,MAAAwD,EAAArE,OAAA,GACA+P,EAAA1L,EAAAwxD,GAAA5pD,QACAqjB,EAAAjrB,EAAAwxD,EAAA,GACA7jC,EAAA3tB,EAAAwxD,EAAA,GACA,MAAAtgD,EAAA+Z,EAAA9tB,GAAAuO,EAAAvO,GAAAwwB,EAAAxwB,GAAAuO,EAAAvO,EAAA+M,GAAAymB,EAAArlB,MAAApB,EACAiH,EAAA8Z,EAAA5tB,GAAAqO,EAAArO,GAAAswB,EAAAtwB,GAAAqO,EAAArO,EAAA6M,GAAAymB,EAAAtlB,OAAAnB,EACAwB,EAAAvO,GAAA+T,EACAxF,EAAArO,GAAA8T,CACA,CACA9a,KAAAuyC,eAAAppC,SAAAkM,EACA,CACA,CAMA,MAAA3T,CAAAqC,GACA,MAAA0Z,EAAAzd,KAAAyd,QACA,IAAAw3B,EAAAC,EACA,GAAAl1C,KAAA+yC,cACA/yC,KAAAgyC,aAAAjuC,EAwBA,OAvBA/D,KAAAgyC,WAAAjuC,EACAkxC,EAAA,GACAC,EAAA,GACAl1C,KAAAgyC,YACAhyC,KAAAqwC,QAAA,IAAA2G,GAAAh3C,KAAAA,KAAA0K,QAAA0wD,WACA39C,EAAA+/B,OAAAx9C,KAAAqwC,SAAA,GACA5yB,EAAA03B,eAAAvrC,KAAA5J,MACAi1C,EAAArrC,KAAA5J,OAGAA,KAAAqwC,UACA5yB,EAAA+/B,OAAAx9C,KAAAqwC,SAAA,GACAzoC,GAAA6V,EAAA03B,eAAAn1C,MACAA,KAAAqwC,aAAA1nC,EACAusC,EAAAtrC,KAAA5J,OAGAA,KAAAqwC,SACArwC,KAAAqwC,QAAAxB,UAEApxB,EAAA23B,oBACA33B,EAAA43B,kBAAAJ,EAAAC,IAEA,CAGA,CAQA,MAAAj5B,CAAAlY,GACA,IAAAA,GAAAa,EAAAb,GAIA,OAAA/D,KAAA20C,QAHA30C,KAAA20C,QAAA5wC,CAKA,CAOA,IAAAwJ,CAAAxJ,GACA,MAAA2G,EAAA1K,KAAA0K,QACA,IAAA3G,EAQA,OAAA2G,EAAA6C,KAPAxJ,IAAA2G,EAAA6C,OACA7C,EAAA6C,KAAAxJ,EACA/D,KAAAw4D,cACAx4D,KAAA6uC,UAMA,CACA,WAAA2pB,GACA,MAAAjrD,GAAAvN,KAAA0K,QAAA6C,MAAA,IAAA2K,cAEAlY,KAAAq7D,QADA9tD,IAAAjK,EACA,IAAAy6C,GAAA/9C,MAGA,IAAA4/C,GAAA5/C,KAEA,CASA,MAAA2J,CAAA5F,GACA,IAAAA,EAeA,CACA,MAAAu3D,EAAA,GACA,GAAAr3D,EAAAjE,KAAA64D,UACA,IAAA,IAAAzmD,EAAA,EAAAA,EAAApS,KAAA64D,SAAAvzD,OAAA8M,IACAkpD,EAAA1xD,KAAA5J,KAAA64D,SAAAzmD,GAAAiD,OAGA,OAAAimD,CACA,CAtBAt7D,KAAA64D,SAAA,GACA,IAAA,IAAA/yD,EAAA,EAAAA,EAAA/B,EAAAuB,OAAAQ,IAAA,CACA,MAAAy1D,EAAAx3D,EAAA+B,GACA,GAAAy1D,aAAA9nD,GACAzT,KAAA64D,SAAAjvD,KAAA,IAAAuoB,GAAAopC,QAEA,KAAAh3D,OAAAM,UAAAH,eAAAC,KAAA42D,EAAA,OAAAh3D,OAAAM,UAAAH,eAAAC,KAAA42D,EAAA,KAIA,MAAA,IAAA3yD,MAAA,gFAHA5I,KAAA64D,SAAAjvD,KAAA,IAAAuoB,GAAA,IAAA1e,GAAA8nD,EAAAz0D,EAAAy0D,EAAAv0D,IAIA,CACA,CAWA,CAMA,SAAA82C,GACA,MAAAwd,EAAA,CAAAt7D,KAAAq3C,eACA,GAAAr3C,KAAA64D,SACA,IAAA,IAAAzmD,EAAA,EAAAA,EAAApS,KAAA64D,SAAAvzD,OAAA8M,IACAkpD,EAAA1xD,KAAA5J,KAAA64D,SAAAzmD,GAAAiD,OAIA,OADAimD,EAAA1xD,KAAA5J,KAAAu3C,eACA+jB,CACA,CACA,OAAAzsB,GACA7uC,KAAAw7D,qBACAx7D,KAAAy7D,eACAz7D,KAAA8zC,gBACA9zC,KAAAqwC,SACArwC,KAAAqwC,QAAAxB,SAEA,CACA,kBAAA2sB,GACA,IAAAnkB,EAAAE,EAAAmkB,EAAAC,EACA,MAAAl2D,EAAAzF,KAAAyF,SAAA0I,EAAAnO,KAAAmO,SACA1I,aAAAgO,GACA4jC,EAAA5xC,EAEAA,aAAAorC,KAEA6qB,EADAhsB,GAAAjqC,GACAA,EAAAsY,MAAA8xB,WAGA,CAAApqC,IAGA0I,aAAAsF,GACA8jC,EAAAppC,EAEAA,aAAA0iC,KAEA8qB,EADAjsB,GAAAvhC,GACAA,EAAA4P,MAAA8xB,WAGA,CAAA1hC,IAGAkpC,EACAskB,IACA37D,KAAA0+C,yBAAA9O,GAAAyH,EAAAskB,IAGAD,IACAnkB,EACAv3C,KAAAy+C,yBAAA7O,GAAA2H,EAAAmkB,GAEAC,GACA37D,KAAA47D,uBAAAF,EAAAC,GAGA,CACA,sBAAAC,CAAAF,EAAAC,GACA,IAEAE,EAAAC,EACAzkB,EAAAE,EACAwkB,EAAAC,EACApsC,EAAAE,EACAmsC,EAAAC,EACA37B,EAPA47B,EAAA54D,EACA28B,EAAA38B,EAOA,IAAA04D,EAAA,EAAAA,EAAAP,EAAAp2D,OAAA22D,IAEA,GADArsC,EAAA8rC,EAAAO,IACAvsB,GAAA9f,GAEA,IADAynB,EAAAznB,EAAAzmB,WACA+yD,EAAA,EAAAA,EAAAP,EAAAr2D,OAAA42D,IACApsC,EAAA6rC,EAAAO,GACAxsB,GAAA5f,KACAynB,EAAAznB,EAAA3mB,WACAo3B,EAAAv/B,KAAAwP,MAAA6mC,EAAArH,WAAAuH,IACAhX,EAAA47B,GAAAn8D,KAAAyd,SAAAzd,KAAAo8D,iBAAA/kB,EAAAE,EAAA3nB,EAAAE,KACAqsC,EAAA57B,EACAs7B,EAAAjsC,EACAksC,EAAAhsC,GAEAyQ,EAAAL,IACA67B,EAAAnsC,EACAosC,EAAAlsC,EACAoQ,EAAAK,IAMAs7B,IACAE,EAAAF,EACAG,EAAAF,GAEA97D,KAAAy+C,yBAAAsd,EACA/7D,KAAA0+C,yBAAAsd,CACA,CACA,gBAAAI,CAAA/kB,EAAAE,EAAA3nB,EAAAE,GACA,MAAAusC,EAAAr8D,KAAAq7D,QACA,IAAAiB,GAAA,EACA,GAAAD,aAAAte,GAAA,CACA,MAAAp0C,EAAA0yD,EAAAhe,YAAAhH,EAAAE,EAAA3nB,EAAAE,GAAAysC,EAAAv8D,KAAAw8D,iBAAAnlB,EAAAE,EAAA3nB,EAAA7R,MAAA+R,EAAA/R,OACA,IAAApX,EAAAC,EAAAyP,EACA1M,EAAAkC,QAAAwrC,GACA1tC,EAAAC,KAAA2tC,GACA,IAAA,IAAAjsC,EAAA,EAAAA,EAAA3B,EAAArE,OAAAgG,IAYA,GAXA3E,EAAAgD,EAAA2B,EAAA,GACA1E,EAAA+C,EAAA2B,GACA+K,EAAA,IAAA3B,GAAA1T,KAAAqO,IAAA1I,EAAAG,EAAAF,EAAAE,GAAA9F,KAAAqO,IAAA1I,EAAAK,EAAAJ,EAAAI,GAAAhG,KAAAgD,IAAA2C,EAAAG,EAAAF,EAAAE,GAAA9F,KAAAgD,IAAA2C,EAAAK,EAAAJ,EAAAI,IACAqP,EAAApB,MAAA,IACAoB,EAAAvP,IACAuP,EAAApB,OAAA,GAEAoB,EAAArB,OAAA,IACAqB,EAAArP,IACAqP,EAAArB,QAAA,IAEAqB,EAAAlR,WAAAnF,KAAAyd,QAAAg/C,gBAAAC,YAAArmD,EAAAkmD,GAAA,CACAD,GAAA,EACA,KACA,CAEA,CACA,OAAAA,CACA,CACA,gBAAAE,CAAAnlB,EAAAE,EAAA/sB,EAAAC,GACA,MAAA8xC,EAAA,GAOA,OANAv8D,KAAA28D,oBAAAtlB,EAAA7sB,IACA+xC,EAAA3yD,KAAA4gB,GAEAxqB,KAAA28D,oBAAAplB,EAAA9sB,IACA8xC,EAAA3yD,KAAA6gB,GAEA8xC,CACA,CACA,mBAAAI,CAAAtnD,EAAA0I,GACA,MAAA9B,EAAA8B,EAAA9B,SAAAzI,EAAAuK,EAAAnH,SAAApD,MAAAopD,EAAA3gD,EAAAnV,EAAA+1D,EAAA5gD,EAAAjV,EACA4vC,EAAAvhC,EAAA9D,QAAAqF,OAAApD,EAAAyI,EAAA5U,UACA+3C,EAAAxI,EAAA9vC,EACAu4C,EAAAzI,EAAA5vC,EACA,OAAAo4C,EAAAwd,GAAAxd,EAAAwd,EAAA3gD,EAAAhH,OAAAoqC,EAAAwd,GAAAxd,EAAAwd,EAAA5gD,EAAAjH,MACA,CACA,MAAAif,CAAAvpB,GACA,GAAAA,EAAA,CACA1K,KAAA0K,QAAAmP,GAAA,CAAA,EAAA7Z,KAAA0K,QAAAA,GACA,MAAAf,EAAA3J,KAAA0K,QAAAf,OACAxF,EAAAwF,IAAAA,EAAArE,OAAA,IACAtF,KAAA2J,OAAAA,GACA3J,KAAAy7D,iBAEA/wD,GAAAA,EAAAqN,SAAArN,EAAAkzB,OACA59B,KAAA+X,QAAArN,EAAAqN,SAEA/X,KAAA42B,KAAA3C,OAAA,CACAtK,KAAAjf,EAAAif,KACA+L,OAAAhrB,EAAAgrB,OACAyF,SAAAzwB,EAAAywB,SACAC,OAAA1wB,EAAA0wB,QAEA,CACA,CAMA,KAAA7pB,GACA,MAAA6gC,EAAApyC,KAAAmyC,YAIA,OAHAnyC,KAAAyd,SAAAzd,KAAAyd,QAAAg2B,aAAAtvC,EAAAnE,KAAAmwC,YACAiC,EAAA1nC,QAAAylC,SAAAnwC,KAAAyd,QAAA/S,QAAAsqC,cAAAh1C,KAAAmwC,WAEA,IAAAooB,GAAAv4D,KAAA2L,KAAA3L,KAAAkP,GAAAkjC,EAAA1nC,QACA,CAMA,SAAAynC,GACA,MAAAxmC,EAAA3L,KAAA2L,KAAAolC,OAAA/wC,KAAA2L,KAAAolC,OAAA/wC,KAAA2L,KAAA7G,WAAAoK,EAAAlP,KAAAkP,GAAA6hC,OAAA/wC,KAAAkP,GAAA6hC,OAAA/wC,KAAAkP,GAAApK,WACAstC,EAAAv4B,GAAA,CAAA,EAAA,CACAnP,QAAA1K,KAAA0K,QACAiB,KAAAA,EACAuD,GAAAA,IAMA,OAJA/K,EAAAnE,KAAAmwC,YACAiC,EAAAjC,SAAAnwC,KAAAmwC,SAAArrC,YAEAstC,EAAA1nC,QAAAf,OAAA3J,KAAA2J,SACAyoC,CACA,CAQA,QAAAM,CAAA3uC,GACA,GAAA/D,KAAA0vB,UAAA,CACA,MAAA/hB,EAAA,IAAA8F,GAAA1P,EAAA+C,EAAA/C,EAAAiD,GAAA2E,EAAA3L,KAAAq3C,cAAAnoC,EAAAlP,KAAAu3C,cACA,GAAAxzC,EAAAoB,UAAApB,EAAAoB,WAAApB,EAAAkE,SAAA0D,IAAA5H,EAAAkE,SAAAiH,GACA,OAAAlP,KAEA,GAAAA,KAAAq7D,QAAAzd,QAAAjwC,GACA,OAAA3N,IAEA,CACA,CACA,MAAAq0B,CAAAtwB,GACA,IAAAumB,GAAAtqB,KAAA0K,QAAAgrB,QAAA,CAAA,GAAApL,MACAvmB,GAAAE,EAAAjE,KAAA0K,QAAAsrB,MAAAN,OAAApL,SACAA,EAAAtqB,KAAA0K,QAAAsrB,MAAAN,OAAApL,OAEAtqB,KAAA42B,KAAA3C,OAAA,CACAyB,OAAA,CACApL,MAAAA,IAGA,CACA,YAAAmxC,GACAt3D,EAAAnE,KAAA42B,QAGA52B,KAAAk9B,YACAl9B,KAAAic,OAAAjc,KAAAq7D,QAAAxd,aACA,CACA,SAAA3gB,GACAl9B,KAAAq7D,SACAr7D,KAAAq7D,QAAA7c,QAEA,MAAA/4C,EAAAzF,KAAAq3C,cACAlpC,EAAAnO,KAAAu3C,cACA5tC,EAAA3J,KAAA2J,SACA3J,KAAA42B,KAAA3C,OAAA,CACAtqB,OAAA,CAAAlE,GAAAmiB,OAAAje,EAAA,CAAAwE,KAEA,CACA,qBAAAsrD,GACAz5D,KAAA4vB,qBAAAjnB,EACA3I,KAAAy+C,8BAAA91C,CACA,CACA,qBAAAsxD,GACAj6D,KAAA8vB,qBAAAnnB,EACA3I,KAAA0+C,8BAAA/1C,CACA,CACA,0BAAA6wD,GACAx5D,KAAA4vB,iBACAhoB,GAAA5H,KAAA4vB,gBAAAvR,YAAAre,KAEA,CACA,0BAAAg6D,GACAh6D,KAAA8vB,iBACAloB,GAAA5H,KAAA8vB,gBAAAzR,YAAAre,KAEA,CACA,MAAA+wC,GACA,IAAAplC,EAAAuD,EAAAmG,EAqBA,OApBArV,KAAA2L,MAAA3L,KAAA2L,KAAAolC,OACAplC,EAAA3L,KAAA2L,KAAAolC,UAGA17B,EAAArV,KAAAy4D,aACA9sD,EAAA,CACA7E,EAAAuO,EAAAvO,EACAE,EAAAqO,EAAArO,IAGAhH,KAAAkP,IAAAlP,KAAAkP,GAAA6hC,OACA7hC,EAAAlP,KAAAkP,GAAA6hC,UAGA17B,EAAArV,KAAA04D,aACAxpD,EAAA,CACApI,EAAAuO,EAAAvO,EACAE,EAAAqO,EAAArO,IAGA,CACA2E,KAAAA,EACAuD,GAAAA,EAEA,EAGA,MAAAsB,GAAAvQ,EAAAsT,EAkBA,MAAAupD,GACA,WAAAryD,CAAAgT,GACAzd,KAAAyd,QAAAA,EACAzd,KAAAyxC,MAAA,CACA,IAAAqlB,GAAA92D,MACA,IAAA6/C,GAAA7/C,MACA,IAAAwgD,GAAAxgD,MACA,IAAA03D,GAAA13D,MACA,IAAAihD,GAAAjhD,OAEAA,KAAA+8D,gBAAAp0D,CACA,CACA,KAAAhC,CAAAgH,EAAAqyC,GAYA,OAXAA,EAAAnmC,GAAA,CAAA,EAAAmmC,GACAhgD,KAAA+8D,YACA/8D,KAAA+8D,WAAAn2D,IAAA+G,EAAAqyC,GAEAhgD,KAAAg9D,mBAAArvD,GACA3N,KAAAi9D,cAAAtvD,EAAAqyC,GACAhgD,KAAA+8D,WAAAp2D,MAAAgH,EAAAqyC,GACAhgD,KAAAk9D,cAAAvvD,GACA3N,KAAAyd,QAAA0/C,QACAn9D,KAAAyd,QAAAs5C,OAAA/+B,QAAAolC,kBACAp9D,KAAA40B,WAAAjnB,GACA,CACA,CACA,IAAAlM,CAAAkM,EAAAqyC,GACAA,EAAAnmC,GAAA,CAAA,EAAAmmC,GACA,IAAAqd,GAAA,EAQA,OAPAr9D,KAAA+8D,aACAM,EAAAr9D,KAAA+8D,WAAAt7D,KAAAkM,EAAAqyC,IAEAqd,GACAr9D,KAAAg9D,mBAAArvD,GAEA3N,KAAAk9D,cAAAvvD,IACA,CACA,CACA,GAAA/G,CAAA+G,EAAAqyC,GAQA,OAPAA,EAAAnmC,GAAA,CAAA,EAAAmmC,GACAhgD,KAAA+8D,YACA/8D,KAAA+8D,WAAAn2D,IAAA+G,EAAAqyC,GAEAhgD,KAAAyd,QAAAs5C,OAAA/+B,QAAAslC,iBACAt9D,KAAA+8D,gBAAAp0D,EACA3I,KAAAk9D,cAAAvvD,IACA,CACA,CACA,OAAA4vD,CAAA94D,EAAAu7C,GACA,MAAAviC,EAAAzd,KAAAyd,QAEA,KADAuiC,EAAAnmC,GAAA,CAAAqmC,SAAA,EAAAsd,SAAA,EAAAzc,QAAA,GAAAf,IACAE,UAAAF,EAAAwd,SAAAxd,EAAAe,OAsCA,IAAA,KAAAt8C,GAAA,IAAAA,EAAA,CACA,MAAAg5D,EAAAz9D,KAAAyd,QAAAigD,eAAAjgD,EAAA/b,UAMA,OALA+7D,EAAAn4D,SACAtF,KAAAyd,QAAA7V,OAAA61D,GAAA,GACAz9D,KAAAyd,QAAAkgD,eACA39D,KAAAyd,QAAAmgD,oBAEA,CACA,CACA,GAAA,KAAAn5D,EAIA,OAHAzE,KAAA69D,wBACApgD,EAAAm6C,WACAn6C,EAAAmgD,mBACA,CACA,KApDA,CACA,GAAA7F,GAAAtzD,EAAA,KAGA,OAFAgZ,EAAAqgD,YACArgD,EAAAmgD,mBACA,EAEA,GAAA7F,GAAAtzD,EAAA,KAGA,OAFAgZ,EAAA6xB,OACA7xB,EAAAmgD,mBACA,EAEA,GAAA7F,GAAAtzD,EAAA,KAGA,OAFAgZ,EAAAgyB,OACAhyB,EAAAmgD,mBACA,EAEA7F,GAAAtzD,EAAA,MACAgZ,EAAA4B,OACA5B,EAAAmgD,mBAEA7F,GAAAtzD,EAAA,MACAgZ,EAAAsgD,MACAtgD,EAAAmgD,mBAEA7F,GAAAtzD,EAAA,MACAgZ,EAAAugD,QACAvgD,EAAAmgD,mBAEA7F,GAAAtzD,EAAA,MACAgZ,EAAAiO,SACAjO,EAAAmgD,mBAEA7F,GAAAtzD,EAAA,OACAgZ,EAAAmgD,kBACAngD,EAAA4B,OACA5B,EAAAugD,QAEA,CAgBA,CACA,KAAAC,CAAAtwD,EAAAqyC,GACA,MAAAviC,EAAAzd,KAAAyd,QACA,IAAAygD,EAAAzgD,EAAAnG,OACA,MAAAF,EAAA4oC,EAAA5oC,MAAA1M,EAAA+S,EAAA/S,QAAAyzD,EAAAzzD,EAAAyzD,SAAAC,EAAA,CAAA/oD,MAAA1H,EAAAqyC,KAAAA,EAAA1oC,KAAA4mD,GACA,IAAAzgD,EAAA3R,QAAAhJ,EAAAs7D,GAaA,OAVAhnD,EAAA,EACA8mD,GAAAC,EAGAD,GAAAC,EAEAD,EAAA1tD,GAAAxP,KAAAoO,IAAA1E,EAAA2zD,QAAAr9D,KAAAqO,IAAA3E,EAAA4zD,QAAAJ,IAAA,GACAE,EAAA9mD,KAAA4mD,EACAzgD,EAAAnG,KAAA4mD,EAAAE,GACA3gD,EAAA3R,QAAA/I,EAAAq7D,IACA,CACA,CACA,OAAAG,CAAAC,EAAA/7C,GACA+7C,EAAArnB,YAAAn3C,KACAA,KAAAyxC,MAAAhvB,GAAA+7C,CACA,CACA,YAAAre,CAAA15C,EAAAu5C,GACA,MAAAviC,EAAAzd,KAAAyd,QACAm0B,EAAAn0B,EAAA/S,QAAAknC,WACA,GAAAA,IAAAnrC,EAAAurC,aAAA,IAAAvrC,EAAAiE,QAAAknC,WAAA,CACA,MAAA6sB,EAAAze,EAAAE,UAAA,IAAAtO,EAAA+lB,SACAl6C,EAAA/b,OAAA+E,EAAA,CAAAg4D,eAAAA,GACA,CACA,CACA,qBAAAZ,GACA79D,KAAA0+D,gBACA1+D,KAAAyd,QAAA7V,OAAA5H,KAAA0+D,eACA1+D,KAAA0+D,mBAAA/1D,EAEA,CACA,aAAAs0D,CAAAtvD,EAAAqyC,GACA,IAAA,IAAAl6C,EAAA,EAAAA,EAAA9F,KAAAyxC,MAAAnsC,OAAAQ,IAAA,CACA,MAAA04D,EAAAx+D,KAAAyxC,MAAA3rC,GACA,GAAA04D,EAAA1e,YAAAnyC,EAAAqyC,GAAA,CACAhgD,KAAA+8D,WAAAyB,EACA,KACA,CACA,CACA,CACA,aAAAtB,CAAAvvD,GACA,MAAAzE,EAAAlJ,KAAAyd,QAAAvU,QACAyoC,EAAA3xC,KAAA+8D,WAAA/8D,KAAA+8D,WAAAxc,UAAA5yC,GAAA3N,KAAAu3D,eAAAv3D,KAAAu3D,eAAArlB,WAAAvkC,GAAA3N,KAAA+3C,YAAA/3C,KAAA+3C,YAAA7F,WAAAvkC,GAAAvM,EAAAC,MACA6H,EAAA2+C,MAAAlW,OAAAA,CACA,CACA,uBAAAkG,CAAA53B,EAAA0+C,EAAAC,GACA5+D,KAAA2gD,iBAAA1gC,EACAjgB,KAAA2+D,cAAAA,EAEA3+D,KAAA0+D,cADAE,EACA5+D,KAAA2gD,sBAGAh4C,CAEA,CACA,kBAAAq0D,CAAArvD,GACA,MAAA0sC,EAAAr6C,KAAA0yC,SAAA/kC,GACA8P,EAAAzd,KAAAyd,QACA48B,IAAAr6C,KAAA+3C,aAAA/3C,KAAA2+D,eAAAtkB,IAAAr6C,KAAA2+D,gBACA3+D,KAAA+3C,cACAt6B,EAAA3R,QAAAjJ,EAAA,CAAA4D,KAAAzG,KAAA+3C,cACA/3C,KAAA+3C,YAAA1jB,QAAA,IAEAgmB,GAAAA,EAAA3vC,QAAAonC,QACAr0B,EAAA3R,QAAAlJ,EAAA,CAAA6D,KAAA4zC,IACAr6C,KAAA+3C,YAAAsC,EACAr6C,KAAA+3C,YAAA1jB,QAAA,IAGAr0B,KAAA+3C,iBAAApvC,EAGA,CACA,YAAA+3C,GACA1gD,KAAA+3C,cACA/3C,KAAA+3C,YAAA1jB,QAAA,GACAr0B,KAAA+3C,iBAAApvC,EAEA,CACA,QAAA+pC,CAAAr9B,GACA,MAAAxI,EAAA7M,KAAAyd,QACA,IAAA48B,EAAA5zC,EAAAX,EAMA,GAJA9F,KAAAg4C,oBACAh4C,KAAAg4C,kBAAA3jB,QAAA,GACAr0B,KAAAg4C,uBAAArvC,GAEAkE,EAAA+oC,mBAAAkD,WACAuB,EAAAxtC,EAAA+oC,mBAAAlD,SAAAr9B,GACAglC,GACA,OAAAA,EAIA,GADAA,EAAAr6C,KAAAyd,QAAA83B,iBAAA7C,SAAAr9B,GACAglC,EAAA,CAEA,GADAr6C,KAAAu3D,eAAA1qD,EAAA0oC,iBACA,IAAA8E,EAAAvzC,GAAA,IAAAuzC,EAAArzC,EACA,OAEAqzC,OAAA1xC,CACA,MAEA3I,KAAAu3D,oBAAA5uD,EAEA,IAAA3I,KAAA+8D,YAAA,mBAAA/8D,KAAA+8D,WAAAxvD,KAAA,CACA,MAAAsxD,EAAA,GAEA,IAAA/4D,EAAA,EAAAA,EAAA+G,EAAAsoC,eAAA7vC,OAAAQ,IACAW,EAAAoG,EAAAsoC,eAAArvC,GACAW,aAAA8xD,IACAsG,EAAAj1D,KAAAnD,GAGA4zC,EAAAr6C,KAAA8+D,cAAAD,EAAAxpD,EACA,CACA,OAAAglC,GAAAr6C,KAAA++D,iBAAA1pD,EACA,CACA,gBAAA0pD,CAAA1pD,GACA,MAAAoI,EAAAzd,KAAAyd,QACAuhD,EAAAh/D,KAAA8+D,cAAArhD,EAAAW,OAAA/I,GACA4pD,EAAAj/D,KAAA8+D,cAAArhD,EAAAY,YAAAhJ,GACA,IAAAglC,EACA,KAAAr6C,KAAA+8D,YAAA,mBAAA/8D,KAAA+8D,WAAAxvD,OAAAyxD,GAAAC,IA1PA,SAAAlhD,EAAA1I,GACA,IAAAs6B,EAAAxmC,EAAAkN,EACA,IAAA,IAAA/K,EAAA,EAAAA,EAAAyS,EAAA8xB,WAAAvqC,OAAAgG,IAKA,GAJAqkC,EAAA5xB,EAAA8xB,WAAAvkC,GACAnC,EAAAwmC,EAAAxmC,WACAkN,EAAA,IAAA3B,GAAAvL,EAAArC,EAAAqC,EAAAnC,GACAqP,EAAA1B,QAAA1S,EAAAA,GACAoU,EAAApO,SAAAoN,GACA,OAAAs6B,CAGA,CA+OAuvB,CAAAF,EAAA3pD,GAAA,CACA,MAAA8pD,EAAA1hD,EAAA0hD,UAGA9kB,EAFAlyC,GAAA62D,EAAA9gD,OAAAihD,EAAAjgD,UACA/W,GAAA82D,EAAA/gD,OAAAihD,EAAAjgD,UACA8/C,EAAAC,CACA,CACA,OAAA5kB,GAAA2kB,GAAAC,CACA,CACA,aAAAH,CAAAj5D,EAAAwP,GACA,IAAAvP,EAAAW,EAAA4zC,EACA,IAAAv0C,EAAAD,EAAAP,OAAA,EAAAQ,GAAA,EAAAA,IAGA,GAFAW,EAAAZ,EAAAC,GACAu0C,EAAA5zC,EAAAisC,SAAAr9B,GACAglC,EACA,OAAAA,CAGA,EAGA,MAAA+kB,GACA,WAAA30D,CAAAwV,EAAAxC,GACAzd,KAAAigB,WAAAA,EACAjgB,KAAAyd,QAAAA,EACAzd,KAAAqvC,MAAA,gBACA,CACA,IAAAC,GACAtvC,KAAAyd,QAAA7V,OAAA5H,KAAAigB,YAAA,EACA,CACA,IAAAwvB,GACAzvC,KAAAyd,QAAAqM,eAAA9pB,KAAAigB,YAAA,EACA,EAGA,MAAAo/C,GACA,WAAA50D,CAAAsT,EAAAN,GACAzd,KAAA+d,MAAAA,EACA/d,KAAAyd,QAAAA,EACAzd,KAAAqvC,MAAA,WACA,CACA,IAAAC,GACAtvC,KAAAyd,QAAAm6C,WACA53D,KAAAyd,QAAA7V,OAAA5H,KAAA+d,OAAA,EACA,CACA,IAAA0xB,GACAzvC,KAAAyd,QAAA8L,UAAAvpB,KAAA+d,OAAA,EACA,EAGA,MAAAuhD,GACA,WAAA70D,CAAAonB,GACA7xB,KAAAu/D,MAAA,GACAv/D,KAAAqvC,MAAA,sBACA1mC,IAAAkpB,GACA7xB,KAAAu/D,MAAA31D,KAAAioB,EAEA,CACA,GAAArwB,CAAAg+D,GACAx/D,KAAAu/D,MAAA31D,KAAA41D,EACA,CACA,IAAAlwB,GACA,IAAA,IAAAxpC,EAAA,EAAAA,EAAA9F,KAAAu/D,MAAAj6D,OAAAQ,IACA9F,KAAAu/D,MAAAz5D,GAAAwpC,MAEA,CACA,IAAAG,GACA,IAAA,IAAA3pC,EAAA,EAAAA,EAAA9F,KAAAu/D,MAAAj6D,OAAAQ,IACA9F,KAAAu/D,MAAAz5D,GAAA2pC,MAEA,EAGA,MAAAgwB,GACA,WAAAh1D,CAAAwV,GACAjgB,KAAAigB,WAAAA,EACAjgB,KAAAyd,QAAAwC,EAAAxC,QACAzd,KAAA8vB,gBAAA7P,EAAA6P,gBACA9vB,KAAAqvC,MAAA,mBACA,CACA,IAAAC,GACAtvC,KAAAyd,QAAAqM,eAAA9pB,KAAAigB,YAAA,EACA,CACA,IAAAwvB,GACAzvC,KAAAyd,QAAA7V,OAAA5H,KAAAigB,YAAA,EACA,EAGA,MAAAy/C,GACA,WAAAj1D,CAAAsT,GACA/d,KAAA+d,MAAAA,EACA/d,KAAAyd,QAAAM,EAAAN,QACAzd,KAAAqvC,MAAA,UACA,CACA,IAAAC,GACAtvC,KAAAyd,QAAA8L,UAAAvpB,KAAA+d,OAAA,GACA/d,KAAA+d,MAAArc,QAAA,EACA,CACA,IAAA+tC,GACAzvC,KAAA+d,MAAArc,QAAA,GACA1B,KAAAyd,QAAA7V,OAAA5H,KAAA+d,OAAA,EACA,EAGA,MAAA4hD,GACA,WAAAl1D,CAAAm1D,GACA5/D,KAAA4/D,YAAAA,EACA5/D,KAAAyd,QAAAmiD,EAAAniD,OACA,CACA,SAAA3N,GACA9P,KAAA6/D,MAAA,GACA7/D,KAAA8/D,IAAA,GACA9/D,KAAA+/D,SAAA,GASA//D,KAAA4/D,YAAAjiD,QAAArW,SARA,CAAAwK,EAAAmK,KACA,MAAA8B,EAAA/d,KAAAyd,QAAA88C,aAAAzoD,GACAiM,IACA/d,KAAA+/D,SAAAn2D,KAAAmU,GACA/d,KAAA6/D,MAAAj2D,KAAAmU,EAAA9B,SAAAjG,WACAhW,KAAA8/D,IAAAl2D,KAAAqS,EAAAjG,WACA,GAEAhW,KACA,CACA,MAAAiQ,CAAA7B,GACA,KAAApO,KAAA+/D,SAAAz6D,QAAA,GAGA,IAAA,IAAAQ,EAAA,EAAAA,EAAA9F,KAAA+/D,SAAAz6D,OAAAQ,IAEA9F,KAAA+/D,SAAAj6D,GAAAqD,SAAA,IAAAsK,GAAAzT,KAAA6/D,MAAA/5D,GAAAgB,GAAA9G,KAAA8/D,IAAAh6D,GAAAgB,EAAA9G,KAAA6/D,MAAA/5D,GAAAgB,GAAAsH,EAAApO,KAAA6/D,MAAA/5D,GAAAkB,GAAAhH,KAAA8/D,IAAAh6D,GAAAkB,EAAAhH,KAAA6/D,MAAA/5D,GAAAkB,GAAAoH,GAEA,EAGA,MAAA4xD,GACA,WAAAv1D,CAAAw1D,EAAAC,EAAAhmD,GACA7V,EAAA6V,GACAla,KAAAka,SAAA,EAGAla,KAAAka,QAAAkwC,QAAAlwC,GAEAla,KAAAmgE,cAAAF,EACAjgE,KAAAogE,YAAAF,EACAlgE,KAAAqvC,MAAA,gBACA,CACA,IAAAC,GACAtvC,KAAAqgE,SAAArgE,KAAAmgE,cACA,CACA,IAAA1wB,GACAzvC,KAAAqgE,SAAArgE,KAAAogE,YACA,CACA,QAAAC,CAAAC,GACA,MAAA7iD,EAAA6iD,EAAA7iD,QACA,GAAAzd,KAAAka,QAAA,CACAomD,EAAA1iD,QAAAtW,SAAA,SAAAwK,EAAAnI,GACA,MAAAqU,EAAAP,EAAA88C,aAAAzoD,GACAkM,EAAA0R,SAAA,GACA1R,GACAA,EAAArU,OAAAA,EAEA,IACA,MAAA42D,EAAA,IAAAtyD,GACAsyD,EAAA3xD,WAAA,IAAA+wD,GAAAW,IACAC,EAAA1xD,YAAA,WACAyxD,EAAA1iD,QAAAtW,SAAA,SAAAwK,GACA2L,EAAA88C,aAAAzoD,GACA4d,SAAA,EACA,GACA,IACA6wC,EAAA3wD,MACA,MAEA0wD,EAAA3iD,QAAArW,SAAA,SAAAwK,EAAAmK,GACA,MAAA8B,EAAAN,EAAA88C,aAAAzoD,GACAiM,GACAA,EAAA5U,SAAA8S,EAAAjG,UAEA,IACAsqD,EAAA1iD,QAAAtW,SAAA,SAAAwK,EAAAnI,GACA,MAAAqU,EAAAP,EAAA88C,aAAAzoD,GACAkM,GACAA,EAAArU,OAAAA,EAEA,GAEA,EAkBA,MAAA62D,GACA,WAAA/1D,CAAAgT,EAAA+8B,EAAAimB,GACAzgE,KAAAyd,QAAAA,EACAzd,KAAAgmB,QAAAy6C,EACAzgE,KAAAw6C,MAAAA,EACAx6C,KAAAqvC,MAAA,aACA,CACA,IAAAC,GACAtvC,KAAAyd,QAAAijD,SAAA1gE,KAAAw6C,MAAAx6C,KAAAgmB,QACA,CACA,IAAAypB,GACAzvC,KAAAyd,QAAAuc,OAAAh6B,KAAAw6C,OAAA,EACA,EAGA,MAAAmmB,GACA,WAAAl2D,CAAAgT,EAAA+8B,EAAAimB,GACAzgE,KAAAyd,QAAAA,EACAzd,KAAAgmB,QAAAy6C,EACAzgE,KAAAw6C,MAAAA,EACAx6C,KAAAqvC,MAAA,aACA,CACA,IAAAC,GACAtvC,KAAAyd,QAAAijD,SAAA1gE,KAAAw6C,MAAAx6C,KAAAgmB,QACA,CACA,IAAAypB,GACAzvC,KAAAyd,QAAAqc,QAAA95B,KAAAw6C,OAAA,EACA,EAMA,MAAAomB,WAAAp2D,GACA,WAAAC,CAAAC,EAAA,CAAA,GACAwH,QACAlS,KAAA2K,OAAA,CAAA,SAAA,UACA3K,KAAA8I,KAAA9I,KAAA2K,OAAAD,GACA1K,KAAAmmB,MAAA,GACAnmB,KAAAyiB,MAAA,EACAziB,KAAA6gE,SAAA,GACA,CAKA,KAAAC,GACA9gE,KAAA+gE,UAAA,IAAAzB,EACA,CAIA,MAAAjjB,GACAr8C,KAAA+gE,eAAAp4D,CACA,CAIA,MAAAq4D,CAAAC,GACAjhE,KAAA+gE,UAAAxB,MAAAj6D,OAAA,GACAtF,KAAAkhE,SAAAlhE,KAAA+gE,UAAAE,GAEAjhE,KAAA+gE,eAAAp4D,CACA,CAMA,gBAAAgxD,CAAA6F,GACAx/D,KAAA+gE,UACA/gE,KAAA+gE,UAAAv/D,IAAAg+D,GAGAx/D,KAAAwB,IAAAg+D,EAEA,CAOA,GAAAh+D,CAAAg+D,EAAAyB,GACAjhE,KAAAkhE,SAAA1B,EAAAyB,EACA,CAMA,GAAA1kD,GACAvc,KAAAyiB,MAAA,IACAziB,KAAAmmB,MAAA5J,MACAvc,KAAAyiB,QAEA,CACA,KAAAgqB,GACA,OAAAzsC,KAAAmmB,MAAA7gB,MACA,CAIA,IAAAgqC,GACAtvC,KAAAyiB,MAAA,IACAziB,KAAAyiB,QACAziB,KAAAmmB,MAAAnmB,KAAAyiB,OAAA6sB,OACAtvC,KAAA8L,QAAA,UAEA,CAIA,IAAA2jC,GACAzvC,KAAAmmB,MAAA7gB,OAAA,GAAAtF,KAAAyiB,MAAAziB,KAAAmmB,MAAA7gB,SACAtF,KAAAmmB,MAAAnmB,KAAAyiB,OAAAgtB,OACAzvC,KAAAyiB,QACAziB,KAAA8L,QAAA,UAEA,CACA,QAAAo1D,CAAAH,EAAAE,GAEAjhE,KAAAmmB,MAAAne,OAAAhI,KAAAyiB,MAAAziB,KAAAmmB,MAAA7gB,OAAAtF,KAAAyiB,OACAziB,KAAAmmB,MAAAvc,KAAAm3D,IACA,IAAAE,EACAjhE,KAAAyvC,OAGAzvC,KAAAyiB,QAGAziB,KAAAmmB,MAAA7gB,OAAAtF,KAAA6gE,WACA7gE,KAAAmmB,MAAAne,OAAA,EAAAhI,KAAAmmB,MAAA7gB,OAAAtF,KAAA6gE,UACA7gE,KAAAyiB,MAAAziB,KAAA6gE,SAEA,CAIA,KAAAv3D,GACAtJ,KAAAmmB,MAAA,GACAnmB,KAAAyiB,MAAA,CACA,EAGA,MAAA0+C,GACA,WAAA12D,CAAA0lC,GACAnwC,KAAAmwC,SAAAA,EACAnwC,KAAAohE,UAAA,EACA,CACA,UAAArG,CAAAzS,GACA,OAAA,IAAA+Y,SAAAC,IACAthE,KAAAohE,UAAAx3D,KAAA,CACA0+C,WACAgZ,WACA,GAEA,CACA,QAAAC,GACA,MAAAH,EAAAphE,KAAAohE,UACA,IAAA36D,EACA,IAAA,IAAA6E,EAAA,EAAAA,EAAA81D,EAAA97D,OAAAgG,IACA7E,EAAAzG,KAAAohE,UAAA91D,GACA7E,EAAA6hD,SAAAtoD,KAAAmwC,UACA1pC,EAAA66D,UAEAthE,KAAAohE,UAAA,EACA,EAEA,MAAAI,GACA,WAAA/2D,GACAzK,KAAAw6C,MAAA,CAAA,CACA,CACA,GAAAh5C,CAAAg5C,GACA,IAAA,IAAAlvC,EAAA,EAAAA,EAAAkvC,EAAAl1C,OAAAgG,IACAtL,KAAAw6C,MAAAA,EAAAlvC,GAAAuvD,KAAA,IAAAsG,GAAA3mB,EAAAlvC,GAEA,CACA,OAAAhE,CAAAghD,GACA,IAAA,MAAAuS,KAAA76D,KAAAw6C,MACAj2C,OAAAM,UAAAH,eAAAC,KAAA3E,KAAAw6C,MAAAqgB,IACAvS,EAAAtoD,KAAAw6C,MAAAqgB,GAGA,CACA,QAAAD,CAAAC,GACA,OAAA76D,KAAAw6C,MAAAqgB,EACA,CACA,MAAAjzD,CAAAnB,UACAzG,KAAAw6C,MAAA/zC,EAAAo0D,IACA,CACA,OAAAhwD,GACA7K,KAAAw6C,MAAA,CAAA,CACA,EAGA,MAAAinB,GACA,WAAAh3D,GACAzK,KAAAoe,OAAA,EACA,CACA,IAAAsjD,CAAA3jD,EAAA9B,GACAjc,KAAAoe,OAAAxU,KAAA,CACAqS,OAAAA,EACA8B,MAAAA,IAEAA,EAAA4jD,UAAA3hE,IACA,CACA,MAAAiJ,CAAA8U,EAAA9B,GACAjc,KAAA0hE,KAAA3jD,EAAA9B,EACA,CACA,MAAArU,CAAAmW,GACA,MAAAK,EAAApe,KAAAoe,OACA9Y,EAAA8Y,EAAA9Y,OACA,IAAA,IAAAgG,EAAA,EAAAA,EAAAhG,EAAAgG,IACA,GAAA8S,EAAA9S,GAAAyS,QAAAA,EAAA,CACAK,EAAApW,OAAAsD,EAAA,GACA,KACA,CAEA,CACA,WAAAoxD,CAAArmD,EAAAkmD,GACA,MAAAn+C,EAAApe,KAAAoe,OACA9Y,EAAA8Y,EAAA9Y,OACA,IAAA,IAAAQ,EAAA,EAAAA,EAAAR,EAAAQ,IACA,GAAA9F,KAAA4hE,UAAAxjD,EAAAtY,GAAAiY,MAAA1H,KAAApO,GAAAs0D,EAAAn+C,EAAAtY,GAAAiY,OACA,OAAA,CAGA,CACA,SAAA6jD,CAAA7jD,EAAA1H,GACA,MAAA7C,EAAAuK,EAAAnH,SAAApD,MACAyI,EAAA8B,EAAA9B,SACA,IAAAo+B,EAOA,OAFAA,EAJA7mC,EAIAkd,GAAAI,MAAAza,EAAA4F,GAAAzI,GAHAyI,EAAA1E,SAAAlB,GAKAgkC,CACA,EAGA,MAAAwnB,WAAAJ,GACA,WAAAh3D,CAAA4L,GACAnE,QACAlS,KAAAkf,SAAA,GACAlf,KAAAqW,KAAAA,CACA,CACA,QAAAyrD,CAAAzrD,GACA,MAAA0rD,EAAA/hE,KAAAqW,KACA2rD,EAAAD,EAAA5rD,cACAA,EAAAE,EAAAF,cAGA,OAFA4rD,EAAAj7D,GAAAuP,EAAAvP,GAAAi7D,EAAA/6D,GAAAqP,EAAArP,GAAAmP,EAAArP,GAAAk7D,EAAAl7D,GACAqP,EAAAnP,GAAAg7D,EAAAh7D,CAEA,CACA,cAAAi7D,CAAA5rD,GACA,OAAArW,KAAAqW,KAAAkB,SAAAlB,EACA,CACA,MAAApN,CAAA8U,EAAA9B,GACA,IAAAimD,GAAA,EACA,MAAAhjD,EAAAlf,KAAAkf,SACA5Z,EAAA4Z,EAAA5Z,OACA,GAAAtF,KAAA8hE,SAAA7lD,GAAA,CACA,IAAA3W,GAAAtF,KAAAoe,OAAA9Y,OAAA,EACAtF,KAAA0hE,KAAA3jD,EAAA9B,OAEA,CACA3W,GACAtF,KAAAmiE,gBAEA,IAAA,IAAA72D,EAAA,EAAAA,EAAA4T,EAAA5Z,OAAAgG,IACA,GAAA4T,EAAA5T,GAAArC,OAAA8U,EAAA9B,GAAA,CACAimD,GAAA,EACA,KACA,CAEAA,GACAliE,KAAA0hE,KAAA3jD,EAAA9B,EAEA,CACAimD,GAAA,CACA,CACA,OAAAA,CACA,CACA,aAAAC,GACA,MAAA9rD,EAAArW,KAAAqW,KAAA6I,EAAAlf,KAAAkf,SAAAd,EAAApe,KAAAoe,OAAA/W,EAAAgP,EAAAhP,SAAA+6D,EAAA/rD,EAAApB,MAAA,EAAAotD,EAAAhsD,EAAArB,OAAA,EACA,IAAAstD,EAAAC,EAEA,IADArjD,EAAAtV,KAAA,IAAAi4D,GAAA,IAAAntD,GAAA2B,EAAAvP,EAAAuP,EAAArP,EAAAo7D,EAAAC,IAAA,IAAAR,GAAA,IAAAntD,GAAArN,EAAAP,EAAAuP,EAAArP,EAAAo7D,EAAAC,IAAA,IAAAR,GAAA,IAAAntD,GAAA2B,EAAAvP,EAAAO,EAAAL,EAAAo7D,EAAAC,IAAA,IAAAR,GAAA,IAAAntD,GAAArN,EAAAP,EAAAO,EAAAL,EAAAo7D,EAAAC,KACAE,EAAAnkD,EAAA9Y,OAAA,EAAAi9D,GAAA,EAAAA,IACA,IAAAD,EAAA,EAAAA,EAAApjD,EAAA5Z,OAAAg9D,IACA,GAAApjD,EAAAojD,GAAAr5D,OAAAmV,EAAAmkD,GAAAxkD,MAAAK,EAAAmkD,GAAAtmD,QAAA,CACAmC,EAAApW,OAAAu6D,EAAA,GACA,KACA,CAGA,CACA,WAAA7F,CAAArmD,EAAAkmD,GACA,IAAAjxD,EACA,MAAA4T,EAAAlf,KAAAkf,SACA5Z,EAAA4Z,EAAA5Z,OACA,IAAA+0C,GAAA,EACA,GAAAr6C,KAAAiiE,eAAA5rD,GACA,GAAAnE,MAAAwqD,YAAArmD,EAAAkmD,GACAliB,GAAA,OAGA,IAAA/uC,EAAA,EAAAA,EAAAhG,EAAAgG,IACA,GAAA4T,EAAA5T,GAAAoxD,YAAArmD,EAAAkmD,GAAA,CACAliB,GAAA,EACA,KACA,CAIA,OAAAA,CACA,EAGA,MAAAmoB,GACA,WAAA/3D,CAAAgT,GACAzd,KAAAyiE,UAAA,IACA,MAAAC,EAAA1iE,KAAA2iE,cAAA75D,KAAA9I,MACAyd,EAAA3U,KAAAnG,EAAA+/D,GACAjlD,EAAA3U,KAAApG,EAAAggE,GACA1iE,KAAA4iE,WACA,CACA,SAAAA,GACA5iE,KAAA6iE,QAAA,CAAA,EACA7iE,KAAA+hB,KAAA,IAAA0/C,EACA,CACA,KAAAn4D,GACAtJ,KAAA4iE,WACA,CACA,aAAAD,CAAA32D,GACAA,EAAAvF,KAAAk7D,WACA31D,EAAAvF,KAAAk7D,UAAA/5D,OAAAoE,EAAAvF,MAEAzG,KAAAiJ,OAAA+C,EAAAvF,KACA,CACA,MAAAwC,CAAA8U,GACA,MAAA9B,EAAA8B,EAAA9B,OAAAhZ,GACA6/D,EAAA9iE,KAAAyiE,UACAM,EAAA/iE,KAAAgjE,WAAA/mD,GACAnV,EAAAi8D,EAAA,GAAA,GACA/7D,EAAA+7D,EAAA,GAAA,GACA/iE,KAAAijE,OAAAF,GACA/iE,KAAA+hB,KAAA9Y,OAAA8U,EAAA9B,IAGAjc,KAAA6iE,QAAA/7D,KACA9G,KAAA6iE,QAAA/7D,GAAA,CAAA,GAEA9G,KAAA6iE,QAAA/7D,GAAAE,KACAhH,KAAA6iE,QAAA/7D,GAAAE,GAAA,IAAA66D,GAAA,IAAAntD,GAAA5N,EAAAg8D,EAAA97D,EAAA87D,EAAAA,EAAAA,KAEA9iE,KAAA6iE,QAAA/7D,GAAAE,GAAAiC,OAAA8U,EAAA9B,GAEA,CACA,MAAArU,CAAAmW,GACAA,EAAA4jD,WACA5jD,EAAA4jD,UAAA/5D,OAAAmW,EAEA,CACA,MAAAklD,CAAAF,GACA,OAAAA,EAAA,GAAAz9D,OAAA,GAAAy9D,EAAA,GAAAz9D,OAAA,CACA,CACA,UAAA09D,CAAA3sD,GACA,MAAAysD,EAAA9iE,KAAAyiE,UACAtsD,EAAAE,EAAAF,cACA+sD,EAAAliE,KAAAmF,MAAAgQ,EAAArP,EAAAg8D,GACAK,EAAAniE,KAAAmF,MAAAgQ,EAAAnP,EAAA87D,GACAC,EAAA,CAAA,GAAA,IACA,IAAA,IAAAj8D,EAAA9F,KAAAmF,MAAAkQ,EAAAvP,EAAAg8D,GAAAh8D,GAAAo8D,EAAAp8D,IACAi8D,EAAA,GAAAn5D,KAAA9C,GAEA,IAAA,IAAAE,EAAAhG,KAAAmF,MAAAkQ,EAAArP,EAAA87D,GAAA97D,GAAAm8D,EAAAn8D,IACA+7D,EAAA,GAAAn5D,KAAA5C,GAEA,OAAA+7D,CACA,CACA,WAAArG,CAAArmD,EAAAkmD,GACA,MAAAwG,EAAA/iE,KAAAgjE,WAAA3sD,GACA,IAAA+sD,EAAAC,EAAAv8D,EAAAE,EACA+a,EACA,GAAA/hB,KAAA+hB,KAAA26C,YAAArmD,EAAAkmD,GACA,OAAA,EAEA,IAAA6G,EAAA,EAAAA,EAAAL,EAAA,GAAAz9D,OAAA89D,IAEA,IADAt8D,EAAAi8D,EAAA,GAAAK,GACAC,EAAA,EAAAA,EAAAN,EAAA,GAAAz9D,OAAA+9D,IAGA,GAFAr8D,EAAA+7D,EAAA,GAAAM,GACAthD,GAAA/hB,KAAA6iE,QAAA/7D,IAAA,CAAA,GAAAE,GACA+a,GAAAA,EAAA26C,YAAArmD,EAAAkmD,GACA,OAAA,EAIA,OAAA,CACA,EAGA,SAAA+G,GAAAC,EAAA5vC,EAAAD,GACA,IAAAE,EACA,IAAA,IAAAtoB,EAAA,EAAAA,EAAAooB,EAAApuB,OAAAgG,IACAsoB,EAAAF,EAAApoB,GACAqoB,IAAAxvB,EAAAwvB,EAAAC,MACAD,EAAAC,GAAA2vC,EAAA3vC,GAGA,CACA,MAAA/X,GAAA,CACAnW,KAAA,UACA89D,MAAA,OACA93C,OAAA,GACAyyC,SAAA,GACA7mD,KAAA,EACA+mD,QAAA,EACAC,QAAA,EACAmF,WAAA,CAAA,EACAC,WAAA,EACA/wB,SAAA,GACAgxB,UAAA,EACAnyB,SAAA,CACA56B,OAAA,CAAA,EACAsjC,OAAA,CAAA,EACAtc,MAAA,EACA6T,MAAA,GACA4H,KAAA,CACAuD,KAAA,CACAh3C,KAAA,GACA4N,MAAA,KAGA5L,QAAA,GAEA0vD,SAAA,CAAA,EACA1lB,WAAA,CACAntC,IAAA,QAEAm/D,QAAA,CAAAje,SAAA,EAAAke,OAAA,OACAxkD,KAAA,CACAsmC,SAAA,EACA9qC,QAAA,GACAC,QAAA,IAEA2O,cAAAA,GAAA,CAAAG,UAAA,IACAk6C,mBAAA,CACAtyB,SAAA,CACAC,MAAA,IAEAlkC,KAAAjK,GAEA8a,OAAA,GACAC,YAAA,IAEA1T,GAAA,CACA5H,EACAD,EACAE,EAAAQ,EACAd,EACAC,EACAxB,EApxaA,QAsxaAyB,EACAC,EACA,eACA,OACA,SACA,OACA,SACA,MACA,YACAN,EACAC,EACAC,GAEA,SAAAshE,GAAAtnC,GACA,MAAApe,EAAA,GACAD,EAAA,GACA,IAAAlV,EAAAoC,EACA,IAAAA,EAAA,EAAAA,EAAAmxB,EAAAn3B,OAAAgG,IACApC,EAAAuzB,EAAAnxB,GACApC,aAAA8pC,GACA50B,EAAAxU,KAAAV,GAGAmV,EAAAzU,KAAAV,GAGA,MAAA,CACAkV,OAAAA,EACAC,YAAAA,EAEA,CAwBA,SAAA2lD,GAAA96D,EAAA+6D,GAAA,GACA,IAAAC,EAAAh7D,EAAAi7D,aACA,GAAAF,EAAA,CACA,MAAApc,EAAAuc,iBAAAl7D,GAGAg7D,GAFAj/D,WAAA4iD,EAAAwc,WACAp/D,WAAA4iD,EAAAyc,aAEA,CACA,OAAAJ,CACA,CAipDA9kE,EAAAmlE,EAAAtM,GACA74D,EAAAolE,EAAAztC,GACA33B,EAAAqlE,EAAAr0B,GACAhxC,EAAAg2B,EAAAwC,GACAx4B,EAAA8hC,EAAAlvB,GACA5S,EAAAslE,EAAA5wC,GACA10B,EAAAulE,EAAA9kB,GACAzgD,EAAA64B,EAAA/W,GACA9hB,EAAAwlE,EAAAn0D,GACArR,EAAAy7B,EAAAnK,GACAtxB,EAAAylE,EAAA5jB,GACA7hD,EAAA0lE,EAAAhO,GACA13D,EAAAk3B,EAAAtW,GACA5gB,EAAAg1B,EAAAjD,GACA/xB,EAAAynB,EAAAvI,GACAlf,EAAA2lE,EAAArN,GACAt4D,EAAAsU,EAAAye,GACA/yB,EAAA4lE,EAAAjsD,GACA3Z,EAAAu1B,EA1kdA,SAAAhuB,EAAA+I,EAAAwc,GACA,QAAA,IAAAvlB,QAAA,IAAA+I,EACA,MAAA,GAEA,GAAAwc,GAAAhlB,GAAAwI,EAAA/I,KAAAO,GAAAglB,GACA,MAAA,IAAAtjB,MAAA,mEAKA,GAFAjC,EAAAA,GAAA,IACA+I,EAAAA,GAAA/I,GACAA,IAHAulB,EAAAA,GAAA,IAGA+4C,IACA,MAAA,IAAAr8D,MAAA,2BAEA,MAAAqB,EAAA,GACA,IAAA6S,EAAAhX,GAAA,EAQA,MAAAsM,EAPA,SAAAtL,GACA,IAAAo+D,EAAA,EACA,KAAAp+D,EAAAo+D,EAAA,GACAA,GAAA,GAEA,OAAAA,CACA,CACAC,CAAAnkE,KAAAgD,IAAAkoB,IAOA,GAJAA,GAAA9Z,GAFAzL,GAAAyL,IACA1C,GAAA0C,IAEA8Z,EAAA,IACAA,GAAAA,GAEAA,EAAA,EACA,MAAApP,EAAAnW,EAAAulB,IAAApmB,IAAA4J,GACAzF,EAAAL,KAAAkT,EAAA1K,QAIA,MAAA0K,EAAAnW,EAAAulB,IAAApmB,IAAA4J,GACAzF,EAAAL,KAAAkT,EAAA1K,GAGA,OAAAnI,CACA,EAmidA7K,EAAAm2B,EA1yVA,cAAA/qB,GACA,WAAAC,CAAA26D,GACAlzD,QACAlS,KAAAmS,WAAA,IAAA1B,GACAzQ,KAAAsF,OAAA,EACArB,EAAAmhE,KACAA,aAAA30D,GACA20D,EAAA99D,SAAA,SAAAuF,GACA7M,KAAAwB,IAAAqL,EACA,IAEAu4D,aAAApzD,IACAozD,EAAA99D,SAAA,SAAA8K,EAAA1F,GACA1M,KAAAwB,IAAA,CAAAiD,IAAA2N,EAAArO,MAAA2I,GACA,GAAA1M,MAGA,CACA,QAAAiI,CAAAxB,GACA,OAAAzG,KAAAmS,WAAApB,YAAAtK,EACA,CACA,GAAAjF,CAAAiF,GACAzG,KAAAmS,WAAAvB,IAAAnK,KAEAzG,KAAAmS,WAAA3Q,IAAAiF,EAAAA,GACAzG,KAAAsF,SACAtF,KAAA8L,QAAA,WAEA,CACA,GAAA8E,CAAAnK,GACA,OAAAzG,KAAAiI,SAAAxB,GACAzG,KAAAmS,WAAAvB,IAAAnK,GAAA1C,MAGA,IAEA,CAOA,IAAAsN,CAAA5K,GACA,OAAAzG,KAAAmS,WAAAlB,MAAAxK,EACA,CAMA,MAAAmB,CAAAnB,GACAzG,KAAAiI,SAAAxB,KACAzG,KAAAmS,WAAAvK,OAAAnB,GACAzG,KAAAsF,SACAtF,KAAA8L,QAAA,WAEA,CAMA,OAAAxE,CAAAf,EAAAkC,GACA,MAAA9D,EAAA8D,EAAAlC,EAAAuC,KAAAL,GAAAlC,EACAvG,KAAAmS,WAAA7K,SAAA,SAAA+9D,GACA1gE,EAAA0gE,EAAAthE,MACA,GACA,CACA,OAAAuhE,GACA,MAAA/xD,EAAA,GAIA,OAHAvT,KAAAsH,SAAA,SAAAuF,GACA0G,EAAA3J,KAAAiD,EACA,IACA0G,CACA,GAguVAnU,EAAAu+B,EAAA1vB,GACA7O,EAAAmmE,EAAAl5D,GACAjN,EAAAomE,EAAA7vC,GACAv2B,EAAAqmE,EAAA1nB,GACA3+C,EAAAiB,EAAAu/C,GACAxgD,EAAAkB,EAAAo9C,GACAt+C,EAAAsmE,EAAAlF,GACAphE,EAAAumE,EAAAhF,GACAvhE,EAAAwmE,SAjjeA,CACA9zD,GAAA,2BACApM,KAAA,wBACAmgE,SAAA,MACAC,YAAA,oCACAC,QAAA,CAAA,oBAAA,oBACAC,QAAA,EACAC,OAAA,GA2ieA7mE,EAAAoK,EAAA8nB,GACAlyB,EAAA8mE,GAAAlG,GACA5gE,EAAA+mE,GAAAvtB,GACAx5C,EAAAgnE,GAAAtJ,GACA19D,EAAAinE,GAAA/oB,GACAl+C,EAAAknE,GAAA3sB,GACAv6C,EAAAmnE,GAAA3F,GACAxhE,EAAAonE,GAAA/tB,GACAr5C,EAAAqnE,GAAAjmB,GACAphD,EAAAsnE,GAAA1vB,GACA53C,EAAAunE,GAAAlH,GACArgE,EAAAwnE,GAAAlH,GACAtgE,EAAAynE,GAAAzH,GACAhgE,EAAA0nE,GAAAzH,GACAjgE,EAAA2nE,GA5tEA,MACA,WAAAt8D,CAAAu8D,EAAAC,EAAAxpD,GACAzd,KAAA0I,QAAAs+D,EACAhnE,KAAAknE,SAAAD,EACAjnE,KAAAyd,QAAAA,EACAzd,KAAAqvC,MAAA,UACA,CACA,IAAAC,GACAtvC,KAAAyd,QAAA+2B,IAAAx0C,KAAA0I,QACA,CACA,IAAA+mC,GACAzvC,KAAAyd,QAAA+2B,IAAAx0C,KAAAknE,SACA,GAitEA9nE,EAAA+nE,GAAA7tB,GACAl6C,EAAAgoE,GAAA9H,GACAlgE,EAAAioE,GAAA7pD,GACApe,EAAAkoE,GAAA1rD,GACAxc,EAAAmoE,GAAAppC,GACA/+B,EAAAooE,GAAA77C,GACAvsB,EAAAqoE,GAAAn5B,GACAlvC,EAAAmwB,GAAA7E,GACAtrB,EAAAsoE,GAAAv2B,GACA/xC,EAAAuoE,GAAAl+C,GACArqB,EAAAwoE,GAAAzjE,EACA/E,EAAAyoE,GAAA70B,GACA5zC,EAAA0oE,GAAAn9D,GACAvL,EAAA2oE,GAAAxP,GACAn5D,EAAA4oE,GAAAj/D,GACA3J,EAAA6oE,GAAApsD,GACAzc,EAAA8oE,GA7rDA,cAAA19D,GACA,WAAAC,CAAAvB,EAAAi/D,EAAAC,GACAl2D,QACAlS,KAAAqoE,WAAA,GACAroE,KAAAsoE,oBAAA,CAAA,EACAtoE,KAAA+4D,SAAA,CAAA,EACA/4D,KAAA26D,oBAAA,IAAA6G,GACAxhE,KAAAm1C,eAAA,GACAn1C,KAAAoe,OAAA,GACApe,KAAAqe,YAAA,GACAre,KAAA86D,2BAAA,GACA96D,KAAAkJ,QAAAA,EACAlJ,KAAA0K,QAAAmP,GAAA,CAAA0uD,cAAAr+D,GAAAs+D,eAAAt+D,IAAA2R,GAAAssD,GACAnoE,KAAA2K,OAAAA,GACA3K,KAAAyoE,WAAAL,GACApoE,KAAA0oE,gBACA1oE,KAAA2oE,qBAAA3oE,KAAA0K,SACA1K,KAAA4oE,cAAAT,GACAnoE,KAAA6oE,uBACA7oE,KAAA8oE,cACA9oE,KAAAm/D,UAAA,IAAAzlC,GAAA,CACA5nB,GAAA,eAEA9R,KAAA+2D,OAAA1+B,OAAAr4B,KAAAm/D,WACAn/D,KAAAy8D,gBAAA,IAAA+F,GAAAxiE,MACAA,KAAAy0C,KAAA,IAAAhhC,GACAzT,KAAA4uC,UAAA,GACA5uC,KAAA+oE,aAAA,IAAArvC,GAAA,CACA5nB,GAAA,kBAEA9R,KAAA+2D,OAAA1+B,OAAAr4B,KAAA+oE,cACA/oE,KAAAgpE,kBACAhpE,KAAA2wC,cACA3wC,KAAAu1C,iBAAA,IAAAoE,GAAA35C,KAAA,CAAAwxC,SAAAxxC,KAAA0K,QAAA8mC,WACAxxC,KAAA41C,mBAAA,IAAAgD,GAAA54C,MACAA,KAAAw9C,OAAAx9C,KAAAu1C,kBAAA,GACAv1C,KAAAw9C,OAAAx9C,KAAA41C,oBAAA,GACA51C,KAAA63D,SAAA,IAAAva,GAAAt9C,MAEAA,KAAAqoE,WAAA/iE,OAAA,EACAtF,KAAAipE,oBAAA,CACA,CACA,YAAAC,CAAA/4B,EAAAzlC,IACAA,EAAAmP,GAAA,CAAA,EAAA7Z,KAAA0K,QAAA+e,cAAA/e,IACAylC,SAAAA,EAEA,OADA,IAAA6C,GAAAtoC,EAAA1K,KAEA,CACA,iBAAAygD,CAAAtQ,EAAA1qC,EAAA0I,GACA,MAAAzD,EAAAmP,GAAA,CAAA,EAAA7Z,KAAA0K,QAAAo5D,oBACAp5D,EAAAylC,SAAAA,EAEA,OADA,IAAAooB,GAAA9yD,GAAA,IAAAgO,GAAAtF,GAAA,IAAAsF,GAAA/I,EAEA,CACA,aAAAg+D,GACA1oE,KAAAkJ,QAAA06C,UAAA,GACA5jD,KAAAkJ,QAAA2+C,MAAA1+C,SAAA,WACAnJ,KAAAkJ,QAAAigE,aAAA,WAAA,KACAnpE,KAAAkJ,QAAAq6C,UAAA/hD,IAAA,WAAA,aACAxB,KAAAk3D,WAAAvT,SAAAjtB,cAAA,OACA12B,KAAAkJ,QAAA0pD,YAAA5yD,KAAAk3D,YACAl3D,KAAAs0D,QAAAt0D,KAAAkJ,OACA,CACA,aAAA0/D,CAAAT,GACA,MAAAz9D,EAAA1K,KAAA0K,QACA8mC,EAAA9mC,EAAA8mC,SACA/nB,EAAA/e,EAAA+e,cACAq6C,EAAAp5D,EAAAo5D,mBACAsF,GAAAjB,GAAA,CAAA,GAAA1+C,eACA,IAAA+nB,GACA/nB,EAAA+nB,UAAA,EACAsyB,EAAAtyB,UAAA,IAGA8xB,GAAA9xB,EAAA/nB,EAAA+nB,SAAA,CAAA,OAAA,SAAA,YACA8xB,GAAA9xB,EAAAsyB,EAAAtyB,SAAA,CAAA,OAAA,YAEA43B,GAAAA,EAAAv5B,aACAnlC,EAAA+e,cAAAomB,WAAAu5B,EAAAv5B,WAEA,CACA,oBAAAg5B,GACA,MAAAn+D,EAAA1K,KAAA0K,QACAknC,EAAAlnC,EAAAknC,WACA0lB,EAAA5sD,EAAA4sD,SACA+R,EAAArpE,KAAAg3D,YACAplB,IAAAztC,EAAAytC,EAAA+lB,YACAjtD,EAAAknC,WAAA/3B,GAAA,CACA89C,UAAA0R,GACA3+D,EAAAknC,aAEA0lB,IAAAnzD,EAAAmzD,EAAA7yD,OACAiG,EAAA4sD,SAAAz9C,GAAA,CACApV,IAAA4kE,EAAA,OAAA,QACA3+D,EAAA4sD,UAEA,CACA,WAAAwR,GACA,MAAAQ,EAAA3lB,SAAAjtB,cAAA,OACA4yC,EAAA/lB,UAAA/hD,IAAA,WACAxB,KAAAk3D,WAAAtE,YAAA0W,GACA,MAAAC,EAAAvpE,KAAAwpE,WACAxpE,KAAA+2D,OAAA,IAAA/2D,KAAA0K,QAAA++D,QAAA7xC,IAAA0xC,EAAA,CACAr0D,MAAAs0D,EAAAt0D,OA58aA,IA68aAD,OAAAu0D,EAAAv0D,QA78aA,KA+8aA,CACA,eAAAg0D,GACA,MAAA9/D,EAAAlJ,KAAAkJ,QACAlJ,KAAA0pE,cAAA1pE,KAAA0pE,eAAA1pE,KAAAw1D,OAAA1sD,KAAA9I,MACAA,KAAA2pE,gBAAA3pE,KAAA2pE,iBAAA3pE,KAAA4pE,SAAA9gE,KAAA9I,MACAA,KAAAg3D,aAAAh3D,KAAAg3D,YAAA6S,QAAAC,aACA5gE,EAAAo7C,iBAAA,aAAAtkD,KAAA0pE,eAGAxgE,EAAAo7C,iBAAA,QAAAtkD,KAAA0pE,eAEAxgE,EAAAo7C,iBAAA,UAAAtkD,KAAA2pE,iBACA3pE,KAAA+pE,YAAA,IAAAhc,GAAA/tD,KAAAk3D,WAAA,CACApI,YAAA,EACAkb,SAAA,EACAC,IAAAjqE,KAAA0tD,KAAA5kD,KAAA9I,MACA2G,MAAA3G,KAAAkqE,WAAAphE,KAAA9I,MACAyB,KAAAzB,KAAAmqE,MAAArhE,KAAA9I,MACA4G,IAAA5G,KAAA22D,SAAA7tD,KAAA9I,MACA6mD,aAAA7mD,KAAAoqE,cAAAthE,KAAA9I,MACAmnD,cAAAnnD,KAAAqqE,eAAAvhE,KAAA9I,MACAsqE,WAAAtqE,KAAAuqE,YAAAzhE,KAAA9I,MACAwqE,UAAAxqE,KAAAyqE,WAAA3hE,KAAA9I,MACAktD,kBAAA,IAEAltD,KAAAm3C,YAAA,IAAA2lB,GAAA98D,MACAA,KAAA0qE,kBAAA1qE,KAAA0qE,mBAAA1qE,KAAA2qE,WAAA7hE,KAAA9I,MACAA,KAAA4qE,iBAAA5qE,KAAA4qE,kBAAA5qE,KAAA6qE,UAAA/hE,KAAA9I,MACAA,KAAA8qE,kBAAA9qE,KAAA8qE,mBAAA9qE,KAAA+qE,WAAAjiE,KAAA9I,MACAA,KAAAgrE,kBAAAhrE,KAAAgrE,mBAAAhrE,KAAAirE,WAAAniE,KAAA9I,MACAA,KAAAkrE,gBAAAlrE,KAAAkrE,iBAAAlrE,KAAAmrE,SAAAriE,KAAA9I,MACAA,KAAAk3D,WAAA5S,iBAAA,YAAAtkD,KAAA0qE,mBACA1qE,KAAAk3D,WAAA5S,iBAAA,WAAAtkD,KAAA4qE,kBACA5qE,KAAAk3D,WAAA5S,iBAAA,YAAAtkD,KAAA8qE,mBACA9qE,KAAAk3D,WAAA5S,iBAAA,YAAAtkD,KAAAgrE,mBACAhrE,KAAAk3D,WAAA5S,iBAAA,UAAAtkD,KAAAkrE,iBACAlrE,KAAAorE,sBACAprE,KAAA8I,KAAAhG,EAAA9C,KAAA49D,gBAAA90D,KAAA9I,OACAA,KAAA8I,KAAA9F,EAAAhD,KAAA49D,gBAAA90D,KAAA9I,MACA,CACA,mBAAAorE,GACA,MAAAC,EAAA,IAAAC,gBAAAC,IACAA,EAAAjkE,SAAA+K,IACA,MAAA4C,MAAAA,EAAAD,OAAAA,GAAA3C,EAAA+hC,YACA/hC,EAAAlE,SAAAnO,KAAAkJ,SACAlJ,KAAA4F,MAAA5F,KAAA4F,KAAAqP,QAAAA,GAAAjV,KAAA4F,KAAAoP,SAAAA,IAGAhV,KAAA4F,KAAA,CAAAqP,QAAAD,UACAhV,KAAAk2D,UACAl2D,KAAA8L,QAAA,SAAA9L,KAAA4F,MAAA,GACA,IAEA5F,KAAAwrE,gBAAAH,EACAA,EAAAI,QAAAzrE,KAAAkJ,QACA,CACA,sBAAAwiE,GACA1rE,KAAAwrE,kBACAxrE,KAAAwrE,gBAAAG,aACA3rE,KAAAwrE,gBAAA,KAEA,CACA,UAAAtB,CAAAl+D,GACAhM,KAAA4rE,qBAAA,EACA,MAAAv2D,EAAArV,KAAA6rE,gBAAA7/D,GAAA,GACAhM,KAAAm3C,YAAAxwC,MAAA0O,EAAArV,KAAA8rE,MAAA9/D,MACAhM,KAAA49D,kBACA5xD,EAAAE,iBAEA,CACA,KAAAi+D,CAAAn+D,GACA,MAAA2B,EAAA3N,KAAA6rE,gBAAA7/D,GACAhM,KAAAm3C,YAAA11C,KAAAkM,EAAA3N,KAAA8rE,MAAA9/D,KACAA,EAAAE,gBAEA,CACA,QAAAyqD,CAAA3qD,GACAhM,KAAA4rE,qBAAA,EACA,MAAAj+D,EAAA3N,KAAA6rE,gBAAA7/D,GACAhM,KAAAm3C,YAAAvwC,IAAA+G,EAAA3N,KAAA8rE,MAAA9/D,MACAhM,KAAA0K,QAAA69D,gBACAv8D,EAAAE,iBAEA,CACA,UAAA6+D,CAAA/+D,GACA,IAAAhM,KAAA4rE,oBAAA,CACA,MAAAj+D,EAAA3N,KAAA6rE,gBAAA7/D,GACAhM,KAAAm3C,YAAA6lB,mBAAArvD,GACA3N,KAAAm3C,YAAA+lB,cAAAvvD,EACA,CACA,CACA,UAAAs9D,GACAjrE,KAAA4rE,qBAAA,CACA,CACA,QAAAT,GACAnrE,KAAA4rE,qBAAA,CACA,CACA,IAAAle,CAAA1hD,GACA,MAAAmrC,EAAAn3C,KAAAm3C,YACAvF,EAAA5xC,KAAA0K,QAAAknC,WACAv8B,EAAArV,KAAA6rE,gBAAA7/D,GACA+/D,EAAA/rE,KAAAm9D,QAEA,GADAhmB,EAAA6lB,mBAAA3nD,GACA8hC,EAAAY,YAAA,CACA,MAAAtxC,EAAA0wC,EAAAY,YAMA,GALA/3C,KAAA8L,QAAA,QAAA,CACArF,KAAAA,EACA4O,MAAAA,EACA2qC,KAAAhgD,KAAA8rE,MAAA9/D,KAEA4lC,IAAA,IAAAnrC,EAAAiE,QAAAknC,WAAA,CACA,MAAA+lB,GAAA,IAAA/lB,EAAA+lB,SACAqU,EAAA9rE,EAAA4J,GAAA9J,KAAA8rE,MAAA9/D,GAAAk0C,QACAz5C,EAAAurC,WACAg6B,GACAhsE,KAAA49D,kBACAn3D,EAAA/E,QAAA,IAGA1B,KAAA0K,QAAA69D,cAAAwD,IAIA/rE,KAAA49D,kBACA59D,KAAA0B,OAAA+E,EAAA,CACAg4D,eAAA9G,GAAAqU,IAEAhsE,KAAA0K,QAAA69D,cAAAwD,GAEA,CACA,MACAn6B,IACA5xC,KAAA49D,kBACA59D,KAAA43D,WAEA,CACA,QAAAgS,CAAA59D,GACAhM,KAAAm3C,YAAAomB,QAAAvxD,EAAAigE,QAAAjsE,KAAA8rE,MAAA9/D,KACAA,EAAAE,gBAEA,CACA,MAAAspD,CAAAxpD,GACA,MAAAoL,EA3tLA,SAAApL,GACA,IAAAoL,EAAA,EAQA,OAPApL,EAAA6pD,YACAz+C,GAAApL,EAAA6pD,WAAA,GACAz+C,EAAAA,EAAA,EAAApW,KAAAusB,KAAAnW,GAAApW,KAAAmF,MAAAiR,IAEApL,EAAA8pD,SACA1+C,EAAApL,EAAA8pD,QAEA1+C,CACA,CAitLA80D,CAAAlgE,GAAA2B,EAAA3N,KAAA6rE,gBAAA7/D,GAAAg0C,EAAAnmC,GAAA7Z,KAAA8rE,MAAA9/D,GAAA,CAAAoL,MAAAA,IACApX,KAAAm3C,YAAA8mB,MAAAtwD,EAAAqyC,IACAh0C,EAAAE,gBAEA,CACA,KAAA4/D,CAAA9/D,GAEA,MAAA,CAAAk0C,SADAl0C,EAAAA,EAAAjB,OAAAiB,GACAk0C,QAAAsd,QAAAxxD,EAAAwxD,QAAAzc,OAAA/0C,EAAA+0C,OAAAC,SAAAh1C,EAAAg1C,SAAAzzC,KAAAvB,EAAAuB,KACA,CACA,eAAAs+D,CAAA7/D,EAAArF,GACA,IAAA0O,EACA,GAAArJ,EAAA07C,MAAA,CACA,MAAA9zB,EAAAjtB,EAAA,gBAAA,WACA0O,EAAA,IAAA5B,GAAAzH,EAAAlF,EAAA8sB,GAAA5nB,EAAAhF,EAAA4sB,GACA,MAEAve,EAAA,IAAA5B,GAAAzH,EAAAklD,MAAAllD,EAAAmlD,OAEA,OAAAnxD,KAAAmsE,gBAAA92D,EACA,CACA,aAAA+0D,CAAAp+D,GACAhM,KAAA49D,kBACA59D,KAAAi3D,SAAAT,UACA,MAAA4V,EAAApsE,KAAAmsE,gBAAA,IAAA14D,GAAAzH,EAAA3E,OAAAP,EAAAkF,EAAA3E,OAAAL,IACA+E,EAAA,CACAsJ,MAAA+2D,EACA90D,KAAAtX,KAAAsX,QAEAtX,KAAA8L,QAAAhJ,EAAAiJ,KAGA/L,KAAAqsE,SAAArgE,EACAhM,KAAAssE,eAAAF,EACA,CACA,cAAA/B,CAAAr+D,GACA,MAAAo7C,EAAApnD,KAAAqsE,SACAD,EAAApsE,KAAAssE,eACAjlE,EAAArH,KAAAusE,eAAA,IAAA94D,GAAAzH,EAAA3E,OAAAP,EAAAkF,EAAA3E,OAAAL,IACAsgD,EAAAt7C,EAAAohB,SAAAg6B,EAAAh6B,SACA,IAAA9V,EAAAtX,KAAAwsE,MACAC,GAAA,EACAzrE,KAAAgD,IAAAsjD,EAAA,IAtobA,MAuobAtnD,KAAAwsE,MAAAl1D,EAAAtX,KAAA0sE,cAAAp1D,EAAAgwC,GACAtnD,KAAA0K,QAAA4M,KAAAA,EACAtX,KAAAqsE,SAAArgE,EACAygE,GAAA,GAEA,MAAAE,EAAAP,EAAAt4D,MAAAwD,GACAk9B,EAAAntC,EAAAuM,MAAA+4D,IACAF,GAAAzsE,KAAAy0C,KAAAzE,WAAAwE,IA9obA,KA+obAx0C,KAAA4sE,cAAAp4B,GACAx0C,KAAA6sE,mBAEA7gE,EAAAE,gBACA,CACA,UAAAu+D,CAAAz+D,GACA,MAAA8gE,EAAA9sE,KAAA6rE,gBAAA7/D,GACAtB,EAAA1K,KAAA0K,QACAyzD,EAAAzzD,EAAAyzD,SACA,IAAA7mD,EAAAtX,KAAAsX,OAAA6mD,EACA,MACAC,EAAA,CAAA/oD,MAAAy3D,EAAA9sB,KADAhgD,KAAA8rE,MAAA9/D,GACAsL,KAAAA,GACAtX,KAAA8L,QAAAhJ,EAAAs7D,KAGA9mD,EAAArX,EAAAsT,EAAAvS,KAAAoO,IAAA1E,EAAA2zD,QAAAr9D,KAAAqO,IAAA3E,EAAA4zD,QAAAhnD,IAAA,GACA8mD,EAAA9mD,KAAAA,EACAtX,KAAAsX,KAAAA,EAAA8mD,GACAp+D,KAAA8L,QAAA/I,EAAAq7D,GACA,CACA,WAAAmM,IACA,IAAAvqE,KAAA0K,QAAA4sD,UACAt3D,KAAAi3D,SAAAnlB,SAEA9xC,KAAA8L,QAAA/I,EAAA,CACAsS,MAAArV,KAAAssE,eACAh1D,KAAAtX,KAAAsX,QAEA,CACA,OAAA4+C,GACA,MAAAsT,EAAAxpE,KAAAwpE,WACAxpE,KAAA+2D,QACA/2D,KAAA+2D,OAAAnxD,KAAA4jE,GAEAxpE,KAAAk3D,YAAAl3D,KAAA+sE,UACA/sE,KAAAk3D,WAAArP,MAAA7yC,OAAAw0D,EAAAx0D,OAAA,KAEA,CACA,UAAA21D,CAAA3+D,GACA,MAAAiR,EAAAjR,EAAAmC,OAAA6+D,WACA/vD,GAAAA,EAAAgwD,WAAA54C,QACApX,EAAAgwD,WAAA54C,QAAA,EAAApX,EAAAgwD,WAEA,CACA,SAAApC,CAAA7+D,GACA,MAAAiR,EAAAjR,EAAAmC,OAAA6+D,WACA/vD,GAAAA,EAAAgwD,WAAA54C,QACApX,EAAAgwD,WAAA54C,QAAA,EAAApX,EAAAgwD,WAEA,CACA,UAAAxE,CAAAL,GACApoE,KAAA0K,QAAAmP,GAAA,CAAA,EAAAuuD,EAAApoE,KAAA0K,UACA,IAAA1K,KAAA0K,QAAA8mC,WACAxxC,KAAA0K,QAAA8mC,UAAA42B,GAAA,CAAA,GAAA52B,SAEA,CACA,qBAAA07B,GACA,MAAAxiE,EAAA1K,KAAA0K,QACAyiE,EAAAziE,EAAA0T,OAAA9Y,OACA6nE,GACAntE,KAAAotE,gBAEA1iE,EAAA2T,YAAA/Y,QACAtF,KAAAqtE,qBAEAF,GAAAziE,EAAAghB,QACA1rB,KAAA0rB,OAAAhhB,EAAAghB,OAEA,CACA,aAAA0hD,GACA,MAAAhvD,EAAApe,KAAA0K,QAAA0T,OACA,IAAAL,EAAAjY,EACA,IAAAA,EAAA,EAAAA,EAAAsY,EAAA9Y,OAAAQ,IACAiY,EAAAK,EAAAtY,GACA9F,KAAA6pB,SAAA9L,EAEA,CACA,kBAAAsvD,GACA,MAAA3iE,EAAA1K,KAAA0K,QAAA2mC,EAAA3mC,EAAAo5D,mBAAAzlD,EAAA3T,EAAA2T,YACA,IAAAL,EAAAvY,EAAA0I,EAAArI,EACA,IAAAA,EAAA,EAAAA,EAAAuY,EAAA/Y,OAAAQ,IACAkY,EAAAK,EAAAvY,GACAL,EAAAzF,KAAAstE,sBAAAtvD,EAAArS,MACAwC,EAAAnO,KAAAstE,sBAAAtvD,EAAA9O,IACAlP,KAAA0K,QAAAqf,QACA/pB,KAAA0K,QAAAqf,QAAAtkB,EAAA0I,EAAA0L,GAAA,CAAA,EAAAw3B,EAAArzB,IAGAhe,KAAA+pB,QAAAtkB,EAAA0I,EAAA0L,GAAA,CAAA,EAAAw3B,EAAArzB,GAGA,CACA,qBAAAsvD,CAAA5iE,GAEA,MAAAsmC,EAAApsC,EADA8F,EAAAA,GAAA,CAAA,GACAA,EAAAA,EAAAsmC,SAAAtmC,EAAAoH,GACA,IAAA3D,EAUA,OATA6iC,GACA7iC,EAAAnO,KAAAu6D,aAAAvpB,GACAtmC,EAAAilC,YACAxhC,EAAAA,EAAA+iC,aAAAxmC,EAAAilC,aAIAxhC,EAAA,IAAAsF,GAAA/I,EAAA5D,GAAA,EAAA4D,EAAA1D,GAAA,GAEAmH,CACA,CACA,OAAAtD,GACAqH,MAAArH,UACA7K,KAAA0rE,yBACA1rE,KAAA+pE,aACA/pE,KAAA+pE,YAAAl/D,UAEA7K,KAAAsJ,QACAtJ,KAAAkJ,QAAAu7C,oBAAA,aAAAzkD,KAAA0pE,eACA1pE,KAAAkJ,QAAAu7C,oBAAA,QAAAzkD,KAAA0pE,eACA1pE,KAAAkJ,QAAAu7C,oBAAA,UAAAzkD,KAAA2pE,iBACA3pE,KAAAk3D,WAAAzS,oBAAA,YAAAzkD,KAAA0qE,mBACA1qE,KAAAk3D,WAAAzS,oBAAA,WAAAzkD,KAAA4qE,kBACA5qE,KAAAk3D,WAAAzS,oBAAA,YAAAzkD,KAAA8qE,mBACA9qE,KAAAk3D,WAAAzS,oBAAA,YAAAzkD,KAAAgrE,mBACAhrE,KAAAk3D,WAAAzS,oBAAA,UAAAzkD,KAAAkrE,iBACAlrE,KAAA+2D,OAAAlsD,SAAA,GACA7K,KAAA+2D,YAAApuD,EACA3I,KAAAutE,kBACAvtE,KAAAwtE,wBACAxtE,KAAA49D,kBACA59D,KAAA26D,oBAAA9vD,SACA,CACA,eAAA0iE,GACA,MAAAtW,EAAAj3D,KAAAi3D,SACAA,IAGAA,EAAApsD,UACAosD,EAAA/tD,QAAAtB,SACA5H,KAAAi3D,SAAA,KACA,CACA,IAAAjyC,GACA,MAAAotB,EAAA,CACAh0B,OAAA,GACAC,YAAA,IAEA,IAAAvY,EAAAma,EAAAlC,EACA,IAAAjY,EAAA,EAAAA,EAAA9F,KAAAoe,OAAA9Y,OAAAQ,IACAiY,EAAA/d,KAAAoe,OAAAtY,GACAiY,EAAArT,QAAAmnC,cACAO,EAAAh0B,OAAAxU,KAAAmU,EAAArT,SAGA,IAAA5E,EAAA,EAAAA,EAAA9F,KAAAqe,YAAA/Y,OAAAQ,IACAma,EAAAjgB,KAAAqe,YAAAvY,GACAssC,EAAA/zB,YAAAzU,KAAAiQ,GAAA,CAAA,EAAAoG,EAAAvV,QAAAuV,EAAA8wB,WAEA,OAAAqB,CACA,CACA,KAAA+qB,GACA,GAAAn9D,KAAAkJ,UAAAlJ,KAAAkJ,QAAAukE,cAAAC,cAAA,CACA,MAAAxkE,EAAAlJ,KAAAkJ,QAAA+lB,EAAA,GAAA0+C,EAAA,GAAAC,EAAA1kE,EAAAukE,cAAAG,gBACA,IAAA9nE,EAAA+nE,EAAA3kE,EACA,GACA2kE,EAAAA,EAAAC,WACAD,EAAA7X,aAAA6X,EAAAzjD,eACA6E,EAAArlB,KAAAikE,GACAF,EAAA/jE,KAAAikE,EAAA5Y,kBAEA4Y,IAAAD,GAEA,IADA1kE,EAAAi0D,MAAA,CAAA4Q,eAAA,IACAjoE,EAAA,EAAAA,EAAAmpB,EAAA3pB,OAAAQ,IACAmpB,EAAAnpB,GAAAmvD,UAAA0Y,EAAA7nE,GAEA,OAAA,CACA,CACA,CACA,IAAAkoE,CAAAtjE,GACA1K,KAAAsJ,QACAtJ,KAAAo2D,WAAA1rD,GACA1K,KAAAotE,gBACAptE,KAAAqtE,oBACA,CACA,UAAAjX,CAAA1rD,GACAmP,GAAA7Z,KAAA0K,QAAAA,EACA,CACA,KAAApB,GACAtJ,KAAA0B,QAAA,GACA1B,KAAAm/D,UAAA71D,QACAtJ,KAAAy8D,gBAAAnzD,QACAtJ,KAAA2wC,aACA,CAQA,SAAAzqB,CAAAzgB,EAAA0I,GACA,IAAA,IAAArI,EAAA,EAAAA,EAAA9F,KAAAqe,YAAA/Y,OAAAQ,IAAA,CACA,MAAAmH,EAAAjN,KAAAqe,YAAAvY,GACA,GAAAmH,EAAAtB,OAAAlG,GAAAwH,EAAAiC,KAAAf,EACA,OAAA,CAEA,CACA,OAAA,CACA,CAQA,aAAA8/D,CAAAhuD,EAAA2J,GAaA,OAZA,IAAAA,GACA5pB,KAAAs1C,gBAAA9zC,IAAA,IAAA49D,GAAAn/C,EAAAjgB,OAAA,GAEAigB,EAAAxC,QAAAzd,KACAigB,EAAAozB,uBACApzB,EAAA4uB,UACA7uC,KAAAm/D,UAAA9mC,OAAApY,EAAA/B,QACAle,KAAAqe,YAAAzU,KAAAqW,GACAjgB,KAAA8L,QAAA3K,EAAA,CACA+sE,MAAA,CAAAjuD,GACAkuD,QAAA,KAEAluD,CACA,CAQA,QAAA4J,CAAApjB,EAAAmjB,GACA,IAAA7L,EAAA0L,EAAAzpB,KAAA0K,QAAA+e,cACA,GAAAhjB,aAAAusC,GACAj1B,EAAAtX,EACAzG,KAAAouE,aAAArwD,EAAA9B,cAEA,IAAAxV,EAAA,UAMA,OALAgjB,EAAA5P,GAAA,CAAA,EAAA4P,EAAAhjB,GAAA,CAAA,GACAsX,EAAA,IAAAi1B,GAAAvpB,EAAAzpB,MACAA,KAAAouE,aAAArwD,EAAA9B,SAIA,CAcA,OAbA,IAAA2N,GACA5pB,KAAAs1C,gBAAA9zC,IAAA,IAAA69D,GAAAthD,EAAA/d,OAAA,GAEAA,KAAAoe,OAAAxU,KAAAmU,GACAA,EAAAN,UAAAzd,OACAA,KAAAy8D,gBAAAxzD,OAAA8U,GACAA,EAAAN,QAAAzd,MAEAA,KAAAm/D,UAAA9mC,OAAAta,EAAAG,QACAle,KAAA8L,QAAA3K,EAAA,CACA+sE,MAAA,CAAAnwD,GACAowD,QAAA,KAEApwD,CACA,CAOA,MAAAnW,CAAA4yC,EAAA5wB,GAEA,MAAA6S,EAAAsnC,GADAvpB,EAAAp1C,MAAAC,QAAAm1C,GAAAA,EAAAruC,MAAA,GAAA,CAAAquC,IAEAp8B,EAAAqe,EAAAre,OACAC,EAAAoe,EAAApe,YACA,IAAAvY,EAQA,IAPA3B,EAAAylB,KACAA,GAAA,GAEAA,GACA5pB,KAAAs1C,gBAAAwrB,QAEA9gE,KAAAquE,uBACAvoE,EAAAsY,EAAA9Y,OAAA,EAAAQ,GAAA,EAAAA,IACA9F,KAAAsuE,YAAAlwD,EAAAtY,GAAA8jB,EAAAvL,GAEA,IAAAvY,EAAAuY,EAAA/Y,OAAA,EAAAQ,GAAA,EAAAA,IACA9F,KAAAsuE,YAAAjwD,EAAAvY,GAAA8jB,GAEA5pB,KAAAuuE,sBACA3kD,GACA5pB,KAAAs1C,gBAAA0rB,QAAA,GAEAhhE,KAAA8L,QAAA3K,EAAA,CACA+sE,MAAA,GACAC,QAAA3zB,GAEA,CACA,cAAA1wB,CAAA7J,EAAA2J,GACA,OAAA5pB,KAAA0K,QAAAof,eACA9pB,KAAA0K,QAAAof,eAAA7J,EAAA2J,GAEA5pB,KAAA8L,QAAA,MAAA,CAAAmU,WAAAA,SAAA,GACAjgB,KAAAiuE,cAAAhuD,EAAA2J,GACA3J,EAAAw2B,oBACAx2B,EAEA,CACA,SAAAsJ,CAAAxL,EAAA6L,GACA,OAAA5pB,KAAA0K,QAAA6e,UACAvpB,KAAA0K,QAAA6e,UAAAxL,EAAA6L,GAEA5pB,KAAA8L,QAAA,MAAA,CAAAiS,MAAAA,SAAA,EACA/d,KAAA6pB,SAAA9L,EAAA6L,EAEA,CACA,YAAAwkD,CAAAnyD,GACAA,EAAAnV,EAAA,iBAAAmV,EAAA,EAAAhX,WAAAgX,EAAAnV,GAAAmV,EAAAnV,EACAmV,EAAAjV,EAAA,iBAAAiV,EAAA,EAAAhX,WAAAgX,EAAAjV,GAAAiV,EAAAjV,CACA,CACA,cAAAwnE,GACA,OAAAxuE,KAAAyuE,UACA,CACA,oBAAAJ,GACAruE,KAAAyuE,YAAAzuE,KAAAyuE,YAAA,GAAA,CACA,CACA,mBAAAF,GACAvuE,KAAAyuE,WAAAztE,KAAAoO,KAAApP,KAAAyuE,YAAA,GAAA,EAAA,EACA,CACA,cAAA/Q,CAAAljB,GACA,MAAAijB,EAAA,GACA,IAAAh3D,EAAA+E,EAAAgmC,EACA,IAAA,IAAAlmC,EAAA,EAAAA,EAAAkvC,EAAAl1C,OAAAgG,IACA7E,EAAA+zC,EAAAlvC,GACAkmC,EAAA/qC,EAAAiE,QAAA8mC,SAEAhmC,EADA/E,aAAAusC,GACA,CAAAj1B,MAAAtX,GAGA,CAAAwZ,WAAAxZ,GAEA+qC,IAAA,IAAAA,EAAA5pC,SAAA5H,KAAA8L,QAAA,SAAAN,IACAiyD,EAAA7zD,KAAAnD,GAGA,OAAAg3D,CACA,CACA,eAAAiR,CAAArwD,EAAAuL,GACA,MAAAtkB,EAAA+Y,EAAA/Y,OACA,IAAA,IAAAQ,EAAA,EAAAA,EAAAR,EAAAQ,IAAA,CACA,MAAAqqC,EAAA9xB,EAAAvY,GACA9F,KAAA2uE,uBAAAx+B,EAAAvmB,EACA,CACA,CACA,sBAAA+kD,CAAAx+B,EAAAvmB,GACA,IAAA5pB,KAAAsoE,oBAAAn4B,EAAA0qB,KAAA,CACA,IAAAlvD,EAAA3L,KAAA4uE,mBAAAz+B,EAAAxkC,MACAxH,EAAAwH,IAAA,OAAAA,IACAA,EAAA,IAAA8H,GAAA08B,EAAA6oB,MAAA7oB,EAAA8oB,QAEA,IAAA/pD,EAAAlP,KAAA4uE,mBAAAz+B,EAAAjhC,IAIA,GAHA/K,EAAA+K,IAAA,OAAAA,IACAA,EAAA,IAAAuE,GAAA08B,EAAA+oB,IAAA/oB,EAAAgpB,MAEAh1D,EAAAwH,IAAAxH,EAAA+K,GAAA,CACA,MAAAxE,EAAAmP,GAAA,CAAA,EAAA7Z,KAAA0K,QAAAo5D,oBACAp5D,EAAAylC,SAAAA,EACA,MAAAlwB,EAAA,IAAAs4C,GAAA5sD,EAAAuD,EAAAxE,GACA1K,KAAAsoE,oBAAAn4B,EAAA0qB,KAAA56C,EACAjgB,KAAAiuE,cAAAhuD,EAAA2J,EACA,CACA,CACA,CACA,kBAAAglD,CAAA7qE,GACA,IAAA4rC,EAIA,OAHAxrC,EAAAJ,IAAA,OAAAA,IACA4rC,EAAA3vC,KAAA+4D,SAAAh1D,IAEA4rC,CACA,CACA,aAAAk/B,CAAAr0B,EAAAxvB,GACA,IAAAvkB,EAAA6E,EAAAyS,EAAA+wD,EACA,IAAAxjE,EAAA,EAAAA,EAAAkvC,EAAAl1C,OAAAgG,IACA7E,EAAA+zC,EAAAlvC,GACAyS,EAAA/d,KAAA+uE,kBAAAtoE,GACAqoE,EAAA9uE,KAAA+uE,kBAAA/jD,GACA8jD,IAAA9uE,KAAAkmB,UAAA4oD,EAAA/wD,IACA/d,KAAA+pB,QAAA+kD,EAAA/wD,EAGA,CACA,OAAAgM,CAAAtkB,EAAA0I,EAAAzD,GACA,MAAAskE,EAAAn1D,GAAA,CAAA,EAAA7Z,KAAA0K,QAAAo5D,mBAAAp5D,GACAuV,EAAA,IAAAs4C,GAAA9yD,EAAA0I,EAAA6gE,GACA,OAAAhvE,KAAAiuE,cAAAhuD,EACA,CAIA,IAAAqvB,GACAtvC,KAAAs1C,gBAAAhG,MACA,CAIA,IAAAG,GACAzvC,KAAAs1C,gBAAA7F,MACA,CAQA,MAAA/tC,CAAA+E,EAAAiE,GACA,IAAAzG,EAAAwC,GAwBA,OAAAzG,KAAAm1C,eAxBA,CAEA,MAAAF,EAAA,GACA,IAAAnvC,EAAAoD,EAAAsxC,EAAA,GAWA,KAbA9vC,EAAAmP,GAAA,CAAA4kD,gBAAA,GAAA/zD,IACA+zD,gBAGAz+D,KAAA43D,WAEA53D,KAAAo1C,oBAAA,EACA3uC,aAAArB,MACAo1C,EAAA/zC,EAEAA,aAAAsrC,KACAyI,EAAA,CAAA/zC,IAEAX,EAAA,EAAAA,EAAA00C,EAAAl1C,OAAAQ,IACAoD,EAAAsxC,EAAA10C,GACAoD,EAAAxH,QAAA,IACAuzC,EAAArrC,KAAAV,GAGAlJ,KAAAq1C,kBAAAJ,EAAA,IACAj1C,KAAAo1C,oBAAA,CACA,CAIA,CACA,SAAA0oB,GACA99D,KAAA0B,OAAA1B,KAAAoe,OAAAwJ,OAAA5nB,KAAAqe,aACA,CACA,UAAAy5C,CAAAzhD,GACA,IAAAvQ,EAAA00C,EAAA/zC,EACAzG,KAAAo1C,oBAAA,EACA,MAAAH,EAAA,GACA,GAAA5+B,aAAA3B,GAEA,IADA8lC,EAAAx6C,KAAAoe,OAAAwJ,OAAA5nB,KAAAqe,aACAvY,EAAA,EAAAA,EAAA00C,EAAAl1C,OAAAQ,IACAW,EAAA+zC,EAAA10C,GACAuQ,IAAA5P,EAAAisC,SAAAr8B,KAAA5P,EAAAiE,QAAAonC,QACArrC,EAAA/E,QAAA,IACAuzC,EAAArrC,KAAAnD,GAKAzG,KAAAq1C,kBAAAJ,EAAA,IACAj1C,KAAAo1C,oBAAA,CACA,CACA,QAAAwiB,CAAAnxD,GACAzG,KAAAo1C,oBAAA,EACA,MAAAF,EAAA,GACA,IAAAhsC,EAAApD,EAAA00C,EAAA,GAUA,IATA/zC,aAAArB,MACAo1C,EAAA/zC,EAEAA,aAAAsrC,GACAyI,EAAA5wC,KAAAnD,GAEAxC,EAAAwC,KACA+zC,EAAAx6C,KAAAm1C,eAAAhpC,MAAA,IAEArG,EAAA,EAAAA,EAAA00C,EAAAl1C,OAAAQ,IACAoD,EAAAsxC,EAAA10C,GACAoD,EAAAxH,QAAA,IACAwzC,EAAAtrC,KAAAV,GAGAlJ,KAAAq1C,kBAAA,GAAAH,GACAl1C,KAAAo1C,oBAAA,CACA,CAOA,OAAAtb,CAAA0gB,EAAA5wB,GACA4wB,IACAA,EAAAx6C,KAAAm1C,eAAAhpC,SAEA,MAAA9C,EAAArJ,KAAAivE,iBAAAz0B,GACA,IAAAx0B,EACA,IAAA7hB,EAAAylB,IAAAA,EAAA,CACA5D,EAAAiqB,GAAAjwC,KAAAm/D,UAAA91D,EAAA0wB,SACA,MAAAlI,EAAA,IAAA8uC,GAAA3gE,KAAAw6C,EAAAx0B,GACAhmB,KAAAs1C,gBAAA9zC,IAAAqwB,EACA,MAEA7xB,KAAAm/D,UAAArlC,QAAAzwB,EAAA0wB,SACA/5B,KAAAkvE,aAAA7lE,GAAA,EAEA,CAOA,MAAA2wB,CAAAwgB,EAAA5wB,GACA4wB,IACAA,EAAAx6C,KAAAm1C,eAAAhpC,SAEA,MAAA9C,EAAArJ,KAAAivE,iBAAAz0B,GACA,IAAAx0B,EACA,IAAA7hB,EAAAylB,IAAAA,EAAA,CACA5D,EAAAiqB,GAAAjwC,KAAAm/D,UAAA91D,EAAA0wB,SACA,MAAAlI,EAAA,IAAA2uC,GAAAxgE,KAAAw6C,EAAAx0B,GACAhmB,KAAAs1C,gBAAA9zC,IAAAqwB,EACA,MAEA7xB,KAAAm/D,UAAAnlC,OAAA3wB,EAAA0wB,SACA/5B,KAAAkvE,aAAA7lE,GAAA,EAEA,CAQA,aAAA8lE,CAAA1oE,EAAAiE,GACA,MAAA8+D,EAAAxpE,KAAAwpE,WACAv1B,EAAA,IAAAr8B,GAAA4xD,GACA,IAAAnzD,EACA,GAAA,IAAAmzD,EAAAv0D,OAAA,IAAAu0D,EAAAx0D,OACA,OAGA,UADAtK,EAAAmP,GAAA,CAAAK,SAAA,EAAApC,MAAA,iBAAApN,IACAoN,QACApN,EAAAoN,MAAA,iBAEArR,aAAAsrC,GACA17B,EAAA5P,EAAAwV,OAAApY,GAEAuB,MAAAC,QAAAoB,GACA4P,EAAArW,KAAAs6B,YAAA7zB,GAEAA,aAAAiO,KACA2B,EAAA5P,EAAA8K,SAEA,MAAAnG,EAAAiL,EAAA9E,QACA8E,EAAAiB,KAAAtX,KAAAwsE,QACAn2D,EAAApB,MAAAu0D,EAAAv0D,OAAAoB,EAAArB,OAAAw0D,EAAAx0D,UACAhV,KAAAwsE,MAAAxsE,KAAA0sE,cAAA1rE,KAAAqO,IAAAm6D,EAAAv0D,MAAA7J,EAAA6J,MAAAu0D,EAAAx0D,OAAA5J,EAAA4J,SACAqB,EAAAjL,EAAAmG,QAAA+F,KAAAtX,KAAAwsE,QAEAxsE,KAAAovE,iBACA,MAAA/1D,EAAAhD,EAAA9E,QACA0iC,EAAAn8B,MAAAzB,EAAA3L,EAAAoN,OACA,MAAAu3D,EAAAh5D,EAAAL,UAAApC,MAAAyF,EAAArD,WACAhW,KAAAw0C,IAAA66B,EAAAv7D,OAAA,GAAApJ,EAAAwP,QACA,CACA,WAAAo1D,CAAAliC,GAIA,IAAAmiC,EAAA9oE,EAAAX,EAHAzB,EAAA+oC,KACAA,EAAA,QAGA,MAAAoN,EAAAx6C,KAAA0B,SACA,GAAA,IAAA84C,EAAAl1C,OACA,OAEA,OAAA8nC,EAAAl1B,eACA,IAAA,OACA,IAAA,MACAq3D,EAAA7rE,EACA,MACA,IAAA,QACA,IAAA,SACA6rE,EAAA3rE,EAKA,IAAAkC,EAAA,EAAAA,EAAA00C,EAAAl1C,OAAAQ,IAEA,GADAW,EAAA+zC,EAAA10C,GACAW,aAAAusC,GACA,OAAA5F,EAAAl1B,eACA,IAAA,OACAq3D,EAAAvuE,KAAAqO,IAAAkgE,EAAA9oE,EAAAiE,QAAA5D,GACA,MACA,IAAA,MACAyoE,EAAAvuE,KAAAqO,IAAAkgE,EAAA9oE,EAAAiE,QAAA1D,GACA,MACA,IAAA,QACAuoE,EAAAvuE,KAAAoO,IAAAmgE,EAAA9oE,EAAAiE,QAAA5D,GACA,MACA,IAAA,SACAyoE,EAAAvuE,KAAAoO,IAAAmgE,EAAA9oE,EAAAiE,QAAA1D,GAOA,MAAAuyC,EAAA,GACAn7B,EAAA,GACA,IAAAtY,EAAA,EAAAA,EAAA00C,EAAAl1C,OAAAQ,IAEA,GADAW,EAAA+zC,EAAA10C,GACAW,aAAAusC,GAGA,OAFA50B,EAAAxU,KAAAnD,GACA8yC,EAAA3vC,KAAAnD,EAAAwV,UACAmxB,EAAAl1B,eACA,IAAA,OACA,IAAA,QACAzR,EAAA0C,SAAA,IAAAsK,GAAA87D,EAAA9oE,EAAAiE,QAAA1D,IACA,MACA,IAAA,MACA,IAAA,SACAP,EAAA0C,SAAA,IAAAsK,GAAAhN,EAAAiE,QAAA5D,EAAAyoE,IAOA,MAAA19C,EAAA,IAAAynB,GAAAl7B,EAAAm7B,GACAv5C,KAAAs1C,gBAAA9zC,IAAAqwB,GAAA,EACA,CACA,IAAAva,CAAAA,EAAA5M,GACA,GAAA4M,EAAA,CACA,IAAAikC,EAAA7wC,EAAAA,EAAA2K,MAAA,IAAA5B,GAAA,EAAA,GAGA,GADA6D,EAAAtX,KAAAwsE,MAAAxsE,KAAA0sE,cAAAp1D,IACAjT,EAAAk3C,GAAA,CACAA,EAAA,IAAA9nC,GAAAzS,KAAAwP,MAAA+qC,EAAAz0C,GAAA9F,KAAAwP,MAAA+qC,EAAAv0C,IACA,MAAA2lE,EAAApxB,EAAAznC,MAAAwD,GAEAk4D,EADAxvE,KAAA02C,YAAA6E,GACA3nC,MAAA+4D,GACA3sE,KAAAy3D,UAAA,IAAAhkD,GAAAzS,KAAAwP,MAAAg/D,EAAA1oE,GAAA9F,KAAAwP,MAAAg/D,EAAAxoE,IACA,CACA0D,IACAA,EAAA4M,KAAAA,GAEAtX,KAAA4sE,gBACA5sE,KAAA+2D,OAAA/+B,QAAAy3C,aACAzvE,KAAA+2D,OAAA/+B,QAAAy3C,cAEAzvE,KAAA6sE,iBACA,CACA,OAAA7sE,KAAAwsE,KACA,CACA,OAAAkD,CAAAl7B,GAKA,OAJAx0C,KAAA+2D,OACA9jC,YACAuhB,EAAAA,EAAA7gC,KAAA3T,KAAAy0C,OAEAD,CACA,CACA,GAAAA,CAAAA,EAAAt6B,GACA,KAAAs6B,aAAA/gC,IAeA,OAAAzT,KAAAy0C,KAAA3gC,OAAA,GAfA,CACA,MAAAmjD,EAAAj3D,KAAAi3D,SAEAziB,GADAA,EAAAx0C,KAAA0vE,QAAAl7B,IACA1gC,OAAA,GACAoG,EACA+8C,EAAAR,iBAAAjiB,EAAA1tC,EAAA0tC,EAAAxtC,GAAA,KACAhH,KAAA6sE,iBAAA,KAIA5V,EAAAjC,SAAAxgB,EAAA1tC,EAAA0tC,EAAAxtC,GACAhH,KAAA6sE,kBAEA,CAIA,CACA,QAAArD,GACA,MAAAtgE,EAAAlJ,KAAAkJ,QACA+L,EAt+BA,SAAA/L,GACA,MAAA2+C,EAAAuc,iBAAAl7D,GAIA,OAHAA,EAAAihB,YACAllB,WAAA4iD,EAAA8nB,aACA1qE,WAAA4iD,EAAA+nB,aAEA,CAg+BAC,CAAA3mE,GACA,IAAA8L,EAh+BA,SAAA9L,GACA,MAAA2+C,EAAAuc,iBAAAl7D,GAIA,OAHAA,EAAAkhB,aACAnlB,WAAA4iD,EAAAioB,YACA7qE,WAAA4iD,EAAAkoB,cAEA,CA09BAC,CAAA9mE,GAIA,OAHAlJ,KAAA+sE,UACA/3D,GAAAgvD,GAAAhkE,KAAA+sE,QAAA7jE,UAEA,IAAAwL,GAAA,EAAA,EAAAO,EAAAD,EACA,CACA,IAAAqK,GACA,GAAArf,KAAA0K,QAAA2U,KAAAsmC,QAAA,CACA3lD,KAAAqoE,WAAA/iE,OAAA,EACAtF,KAAAiwE,YAAA,EACA,IAAA,IAAAnqE,EAAA,EAAAA,EAAA9F,KAAAm1C,eAAA7vC,OAAAQ,IAAA,CACA,MAAAW,EAAAzG,KAAAm1C,eAAArvC,GACA9F,KAAAqoE,WAAAz+D,KAAAnD,EACA,CACA,CACA,CACA,GAAAs3D,GACA,GAAA/9D,KAAA0K,QAAA2U,KAAAsmC,QAAA,CACA3lD,KAAAqoE,WAAA/iE,OAAA,EACAtF,KAAAiwE,YAAA,EACA,IAAA,IAAAnqE,EAAA,EAAAA,EAAA9F,KAAAm1C,eAAA7vC,OAAAQ,IAAA,CACA,MAAAW,EAAAzG,KAAAm1C,eAAArvC,GACA9F,KAAAqoE,WAAAz+D,KAAAnD,EACA,CACAzG,KAAA4H,OAAA5H,KAAAqoE,YAAA,EACA,CACA,CACA,KAAArK,GACA,GAAAh+D,KAAAqoE,WAAA/iE,OAAA,EAAA,CACA,IAAAmB,EAAAypE,EAAApqE,EACA,MAAAqqE,EAAA,CAAA,EACA1zC,EAAAsnC,GAAA/jE,KAAAqoE,YACAhqD,EAAAoe,EAAApe,YACAD,EAAAqe,EAAAre,OACAvK,EAAA,CACA/M,EAAA9G,KAAAiwE,YAAAjwE,KAAA0K,QAAA2U,KAAAxE,QACA7T,EAAAhH,KAAAiwE,YAAAjwE,KAAA0K,QAAA2U,KAAAvE,SAIA,IAFA9a,KAAA43D,WAEA9xD,EAAA,EAAAA,EAAAsY,EAAA9Y,OAAAQ,IACAW,EAAA2X,EAAAtY,GACAoqE,EAAAzpE,EAAA8K,QACA4+D,EAAA1pE,EAAAqL,IAAAo+D,EACAA,EAAA/mE,SAAA,IAAAsK,GAAAhN,EAAAiE,QAAA5D,EAAA+M,EAAA/M,EAAAL,EAAAiE,QAAA1D,EAAA6M,EAAA7M,IACAkpE,EAAAzyD,QAAAzd,KACAkwE,EAAAlwE,KAAAupB,UAAA2mD,GACAA,GACAA,EAAAxuE,SAIA,IAAAoE,EAAA,EAAAA,EAAAuY,EAAA/Y,OAAAQ,IACAW,EAAA4X,EAAAvY,GACAoqE,EAAAlwE,KAAA8pB,eAAArjB,EAAA8K,SACA2+D,IACAlwE,KAAAowE,wBAAAF,EAAAzpE,EAAA,SAAA0pE,EAAAt8D,GACA7T,KAAAowE,wBAAAF,EAAAzpE,EAAA,SAAA0pE,EAAAt8D,GACAq8D,EAAAxuE,QAAA,GACAwuE,EAAA1gC,eAGAxvC,KAAA29D,eACA39D,KAAAiwE,aAAA,CACA,CACA,CACA,YAAAtS,GACA39D,KAAA0K,QAAAizD,cACA39D,KAAA0K,QAAAizD,cAEA,CACA,sBAAArd,GACAtgD,KAAA0K,QAAA41C,wBACAtgD,KAAA0K,QAAA41C,wBAEA,CACA,iBAAArD,GACAj9C,KAAA0K,QAAAuyC,mBACAj9C,KAAA0K,QAAAuyC,mBAEA,CACA,uBAAAmzB,CAAAnwD,EAAAowD,EAAA7V,EAAA2V,EAAAt8D,GACA,IAAAknD,EAAAL,EAAAjwC,EACA,MAAAtc,EAAAkiE,EAAA7V,KACArsD,aAAA0iC,IAAAs/B,EAAAhiE,EAAA4P,MAAAjM,KACA2Y,EAAA0lD,EAAAhiE,EAAA4P,MAAAjM,IACA9R,KAAAu6D,aAAA9vC,EAAA3Y,IACAmO,EAAAu6C,GAAA/vC,EAAAymB,aAAA/iC,EAAAzD,QAAAhF,QAGAg1D,EAAA16D,KAAA26D,oBAAAC,SAAAnwC,EAAA0lB,SAAA0qB,KACAH,IACAK,EAAAt0D,IACAgkB,EAAAzqB,KAAA+4D,SAAAtyD,EAAAqL,IACAmO,EAAAu6C,GAAA/vC,EAAAymB,aAAA/iC,EAAAzD,QAAAhF,OACAua,EAAAuvB,aAAA,EAEAxvC,KAAA86D,2BAAAlxD,KAAA8wD,EAAAK,WAAAA,OAKA96C,EAAAu6C,GAAA,IAAA/mD,GAAA48D,EAAA7V,EAAA,WAAA1zD,EAAA+M,EAAA/M,EAAAupE,EAAA7V,EAAA,WAAAxzD,EAAA6M,EAAA7M,GAEA,CAQA,WAAAszB,CAAAkgB,EAAA3qC,GACA,IAAA2E,EAAA6B,EAAA3B,GAAAgD,QACA,MAAA44D,EAAArsE,EAAAu2C,GAAAx6C,KAAAivE,iBAAAz0B,GAAA,CAAAp8B,OAAApe,KAAAoe,QACA,GAAAkyD,EAAAlyD,OAAA9Y,OAAA,EAAA,CACA,IAAAmB,EAAA6pE,EAAAlyD,OAAA,GACA/H,EAAA5P,EAAAwV,OAAAhZ,GACA,IAAA,IAAA6C,EAAA,EAAAA,EAAAwqE,EAAAlyD,OAAA9Y,OAAAQ,IACAW,EAAA6pE,EAAAlyD,OAAAtY,GACA0O,EAAA/N,EAAAwV,OAAAhZ,IACA,IAAA4M,IACA2E,EAAA1N,GAAAL,EAAAkvC,gBAAA7uC,EACA0N,EAAAxN,GAAAP,EAAAkvC,gBAAA3uC,GAEAqP,EAAAA,EAAAtB,MAAAP,EAEA,CACA,OAAA6B,CACA,CACA,gBAAAk6D,GACA,MAAAC,EAxoCA,SAAAtnE,GACA,MAAAmN,EAAAnN,EAAAunE,wBACAC,EAAAxnE,EAAAukE,cACAvY,EAAAwb,EAAAC,YAAAC,SAAAF,EAAA9C,gBAAA1Y,YAAA,EACAD,EAAAyb,EAAAC,YAAAE,SAAAH,EAAA9C,gBAAA3Y,WAAA,EACA,MAAA,CACAr/C,IAAAS,EAAAT,IAAAq/C,EACAl/C,KAAAM,EAAAN,KAAAm/C,EAEA,CA+nCA4b,CAAA9wE,KAAAkJ,SAIA,OAHAlJ,KAAA+sE,UACAyD,EAAA56D,KAAAouD,GAAAhkE,KAAA+sE,QAAA7jE,UAEAsnE,CACA,CACA,cAAAjE,CAAAl3D,GACA,MAAAm7D,EAAAxwE,KAAAuwE,mBACA,OAAA,IAAA98D,GAAA4B,EAAAvO,EAAA0pE,EAAAz6D,KAAAV,EAAArO,EAAAwpE,EAAA56D,IACA,CACA,cAAAm7D,CAAA17D,GACA,MAAAm7D,EAAAxwE,KAAAuwE,mBACA,OAAA,IAAA98D,GAAA4B,EAAAvO,EAAA0pE,EAAAz6D,KAAAV,EAAArO,EAAAwpE,EAAA56D,IACA,CACA,WAAAo7D,CAAA37D,GACA,OAAArV,KAAAixE,qBAAA57D,EAAArV,KAAAkxE,cACA,CACA,WAAAx6B,CAAArhC,GACA,OAAArV,KAAAixE,qBAAA57D,EAAArV,KAAAmxE,QACA,CACA,YAAA34B,CAAAnjC,GACA,OAAArV,KAAAixE,qBAAA57D,EAAArV,KAAAoxE,aACA,CACA,YAAAC,CAAAh8D,GACA,OAAArV,KAAAixE,qBAAA57D,EAAArV,KAAAsxE,mBACA,CACA,eAAAnF,CAAA92D,GACA,MAAAk8D,EAAAvxE,KAAAusE,eAAAl3D,GAKA,OAJArV,KAAA+2D,OAAA9jC,YACAs+C,EAAAzqE,EAAAyqE,EAAAzqE,EAAA9G,KAAAi3D,SAAA/B,WACAqc,EAAAvqE,EAAAuqE,EAAAvqE,EAAAhH,KAAAi3D,SAAAhC,WAEAj1D,KAAAgxE,YAAAO,EACA,CACA,eAAAC,CAAAn8D,GACA,OAAArV,KAAA+wE,eAAA/wE,KAAA02C,YAAArhC,GACA,CACA,oBAAA47D,CAAA57D,EAAA8e,GACA,IAAA9qB,EAAAgM,EACA,GAAAA,aAAA5B,GACA0gB,IACA9qB,EAAA8qB,EAAA1oB,MAAA4J,QAGA,CACA,MAAAmB,EAAAxW,KAAAixE,qBAAA57D,EAAAW,UAAAme,GAAAzd,EAAA1W,KAAAixE,qBAAA57D,EAAAc,cAAAge,GACA9qB,EAAAqL,GAAAiD,WAAAnB,EAAAE,EACA,CACA,OAAArN,CACA,CAOA,MAAAqiB,CAAAhhB,GAGA,IAAA6C,EAUA6gB,EACA,OAbApuB,KAAA80C,YAAA,EAGAzwC,EAAAqG,KACAA,EAAA1K,KAAA0K,QAAAghB,QAGAne,EADAlJ,EAAAqG,IAAArG,EAAAqG,EAAA6C,MACA,OAGA7C,EAAA6C,KAGAA,EAAA2K,eACA,IAAA,OACAkW,EAAA,IAAAkgB,GAAAtuC,MACA,MACA,IAAA,UACAouB,EAAA,IAAA+P,GAAAn+B,MACA,MACA,IAAA,gBACA,IAAA,QACA,IAAA,SACA,IAAA,iBACAouB,EAAA,IAAA1D,GAAA1qB,MACA,MACA,QACA,MAAA,IAAA4I,MAAA,qBAAA2E,EAAA,uBAEA,MAAA0yD,EAAA,IAAAziD,GAAAxd,MACAkgE,EAAA9xC,EAAA1C,OAAAhhB,GACA,GAAAw1D,EAAA,CACA,MAAAruC,EAAA,IAAAmuC,GAAAC,EAAAC,EAAAx1D,EAAAA,EAAAwP,QAAA,MACAla,KAAAs1C,gBAAA9zC,IAAAqwB,EACA,CACA7xB,KAAA80C,YAAA,EACA90C,KAAAyxE,oBACA,CAOA,YAAAlX,CAAAzoD,GACA,IAAAkQ,EAIA,OAHAA,EAAAjZ,GAAA/I,KAAAoe,QAAA,SAAA3R,GACA,OAAAA,EAAAyR,OAAApM,KAAAA,CACA,IACAkQ,IAGAA,EAAAjZ,GAAA/I,KAAAqe,aAAA,SAAApR,GACA,OAAAA,EAAAiR,OAAApM,KAAAA,CACA,IACAkQ,EACA,CACA,iBAAA0vD,CAAA5/D,GACA,IAAA6/D,EASA,OAPAA,EADA3xE,KAAAyzC,YACAzzC,KAAA+4D,SAAAjnD,GAGA/I,GAAA/I,KAAAoe,QAAA,SAAAL,GACA,OAAAA,EAAAoyB,UAAA,CAAA,GAAAr+B,KAAAA,CACA,IAEA6/D,CACA,CACA,kBAAAC,CAAA/W,GACA,IAAA8W,EASA,OAPAA,EADA3xE,KAAAyzC,YACA1qC,GAAA/I,KAAAoe,QAAA,SAAAL,GACA,OAAAA,EAAAoyB,UAAA,CAAA,GAAA0qB,MAAAA,CACA,IAGA76D,KAAA+4D,SAAA8B,GAEA8W,CACA,CACA,oBAAAhJ,CAAAj+D,GACAA,EAAAghB,SACAhhB,EAAAghB,OAAA7R,GAAA,CAAA,EAAAE,GAAArP,EAAAghB,QAEA,CACA,iBAAA2pB,CAAAJ,EAAAC,IACAD,EAAA3vC,QAAA4vC,EAAA5vC,SACAtF,KAAA8L,QAAAtI,EAAA,CAAAyxC,SAAAA,EAAAC,WAAAA,GAEA,CACA,aAAAw3B,CAAAp1D,GACA,OAAAtW,KAAAqO,IAAArO,KAAAoO,IAAAkI,EAAAtX,KAAA0K,QAAA2zD,SAAAr+D,KAAA0K,QAAA4zD,QACA,CACA,aAAAsO,CAAA7+D,GACA,MAAAymC,EAAAzmC,GAAA/N,KAAAy0C,KACAz0C,KAAA+2D,OAAA9jC,WACAjzB,KAAAi3D,SAAAjC,SAAAxgB,EAAA1tC,EAAA0tC,EAAAxtC,GACAhH,KAAAovE,mBAGApvE,KAAAy3D,UAAAjjB,GACAx0C,KAAA6xE,sBAEA,CACA,UAAAC,GACA9xE,KAAA8L,QAAA9I,EAAA,CAAAulC,MAAAvoC,KAAAy0C,KAAAr9B,MAAAzT,OAAAouE,KACA,CACA,SAAAta,CAAAjjB,GACAx0C,KAAAy0C,KAAAD,EACAx0C,KAAAgyE,kBACA,CACA,cAAA5C,GACA,MAAA93D,EAAAtX,KAAAwsE,MACAt5C,EAAA,IAAAF,GAAA,EAAA,EAAA1b,EAAAA,GACA4b,EAAAC,OAAAnzB,KAAAm/D,WACAn/D,KAAAiyE,kBAAA/+C,GACAlzB,KAAAgyE,kBACA,CACA,mBAAAH,GACA,MAAAr9B,EAAAx0C,KAAAy0C,KAAAn9B,EAAAtX,KAAAwsE,MACAt5C,EAAA,IAAAF,GAAAwhB,EAAA1tC,EAAA0tC,EAAAxtC,EAAAsQ,EAAAA,GACA4b,EAAAC,OAAAnzB,KAAAm/D,WACAn/D,KAAAiyE,kBAAA/+C,GACAlzB,KAAAgyE,kBACA,CACA,iBAAAC,CAAAC,GACAlyE,KAAAoxE,aAAAc,EAAA3/C,WACAvyB,KAAAsxE,mBAAAY,EAAA1/C,SAAAD,UACA,CACA,gBAAAy/C,GACA,MAAAx9B,EAAAx0C,KAAAy0C,KAAAn9B,EAAAtX,KAAAwsE,MACAt5C,EAAA,IAAAF,GAAAwhB,EAAA1tC,EAAA0tC,EAAAxtC,EAAAsQ,EAAAA,GACAtX,KAAAmxE,QAAAj+C,EAAAX,WACAvyB,KAAAkxE,cAAAh+C,EAAAV,SAAAD,UACA,CACA,QAAAmuC,CAAAlmB,EAAAx0B,GACA,MAAA3c,EAAArJ,KAAAivE,iBAAAz0B,GACAx6C,KAAAm/D,UAAAjlC,QAAA7wB,EAAA0wB,QAAA/T,GACAhmB,KAAAkvE,aAAA7lE,GAAA,EACA,CACA,YAAA6lE,CAAA7lE,EAAAywB,GACA,MAAAq4C,EAAAr4C,EAAA95B,KAAAoe,OAAA9Y,OAAA,EAAA,EAAA8sE,EAAAt4C,EAAA95B,KAAAqe,YAAA/Y,OAAA,EAAA,EACA,IAAAQ,EAAAW,EACA,IAAAX,EAAA,EAAAA,EAAAuD,EAAA+U,OAAA9Y,OAAAQ,IACAW,EAAA4C,EAAA+U,OAAAtY,GACA8B,GAAA5H,KAAAoe,OAAA3X,GACAwC,GAAAjJ,KAAAoe,OAAA3X,EAAA0rE,GAEA,IAAArsE,EAAA,EAAAA,EAAAuD,EAAAysC,KAAAxwC,OAAAQ,IACAW,EAAA4C,EAAAysC,KAAAhwC,GACA8B,GAAA5H,KAAAqe,YAAA5X,GACAwC,GAAAjJ,KAAAqe,YAAA5X,EAAA2rE,EAEA,CACA,gBAAAnD,CAAAz0B,GACA,IAAA10C,EAAA0F,EAAAgvC,EACA,MAAAnxC,EAAA,CACAA,QAAA,GACAA,OAAA,GACAA,KAAA,IAOA,IANAmxC,EAGAp1C,MAAAC,QAAAm1C,KACAhvC,EAAA,CAAAgvC,IAHAhvC,EAAAxL,KAAAm1C,eAAAhpC,QAKArG,EAAA,EAAAA,EAAA0F,EAAAlG,OAAAQ,IAAA,CACA,MAAAW,EAAA+E,EAAA1F,GACAW,aAAAusC,IACA3pC,EAAA+U,OAAAxU,KAAAnD,GACA4C,EAAA0wB,QAAAnwB,KAAAnD,EAAAyX,SAEAzX,aAAA8xD,KACAlvD,EAAAysC,KAAAlsC,KAAAnD,GACA4C,EAAA0wB,QAAAnwB,KAAAnD,EAAAyX,QAEA,CACA,OAAA7U,CACA,CACA,iBAAA0lE,CAAA5+B,GACA,IAAAhsC,EAAAgsC,GACA,OAEA,IAAApyB,EAAA/d,KAAA+4D,SAAA5oB,EAAA0qB,KACA,GAAA98C,EACA,OAAAA,EAEA,MAAArT,EAAAmP,GAAA,CAAA,EAAA7Z,KAAA0K,QAAA+e,eAKA,OAJA/e,EAAAylC,SAAAA,EACApyB,EAAA,IAAAi1B,GAAAtoC,EAAA1K,MACAA,KAAA6pB,SAAA9L,GACA/d,KAAA+4D,SAAA5oB,EAAA0qB,KAAA98C,EACAA,CACA,CACA,QAAAs0D,CAAA5rE,GACAA,aAAAusC,GACAhzC,KAAA6pB,SAAApjB,GAEAA,aAAA8xD,IACAv4D,KAAAiuE,cAAAxnE,EAEA,CACA,aAAA6rE,CAAAtmE,GACAhM,KAAA8L,QAAA,eAAAE,GACAhM,KAAA49D,iBACA,CACA,mBAAA2U,CAAAl9D,GACA,OAAAA,EAAAvB,MAAA,EAAA9T,KAAAsX,OACA,CACA,WAAAq5B,GACA3wC,KAAAoe,OAAA9Y,OAAA,EACAtF,KAAAqe,YAAA/Y,OAAA,EACAtF,KAAAm1C,eAAA7vC,OAAA,EACAf,OAAAiO,KAAAxS,KAAA+4D,UAAAzxD,SAAA7C,WACAzE,KAAA+4D,SAAAt0D,EAAA,IAEAF,OAAAiO,KAAAxS,KAAAsoE,qBAAAhhE,SAAA7C,WACAzE,KAAAsoE,oBAAA7jE,EAAA,IAEAzE,KAAA86D,2BAAAx1D,OAAA,EACAtF,KAAAs1C,gBAAA,IAAAsrB,GAAA,CACA4R,OAAAxyE,KAAA29D,aAAA70D,KAAA9I,MACAyyE,OAAAzyE,KAAA29D,aAAA70D,KAAA9I,QAEAA,KAAA8R,GAAAzB,IACA,CACA,kBAAAohE,GACA,MAAApzD,EAAAre,KAAAqe,YACA,IAAA,IAAA/S,EAAA,EAAAA,EAAA+S,EAAA/Y,OAAAgG,IACA+S,EAAA/S,GAAAujC,SAEA,CACA,MAAA2O,CAAAnN,EAAA4P,QACAt3C,IAAAs3C,GAAA5P,IACA4P,GACAjgD,KAAA4uC,UAAAhlC,KAAAymC,GACArwC,KAAA+oE,aAAA1wC,OAAAgY,EAAAnyB,UAGAtW,GAAA5H,KAAA4uC,UAAAyB,GACArwC,KAAA+oE,aAAAnhE,OAAAyoC,EAAAnyB,SAGA,CACA,eAAAy4B,CAAA54B,EAAAha,GACAA,EACA/D,KAAA41C,mBAAA7f,KAAAhY,GAGA/d,KAAA41C,mBAAA/qC,SAEA,CACA,eAAAgiE,GACA,MAAA6F,EAAA1yE,KAAA4uC,UACA,IAAA,IAAA9oC,EAAA,EAAAA,EAAA4sE,EAAAptE,OAAAQ,IAAA,CACA,MAAAuqC,EAAAqiC,EAAA5sE,GACAuqC,EAAAoJ,eACApJ,EAAAoJ,gBAEApJ,EAAAxB,SACA,CACA,CACA,QAAA8jC,GACA,IAAA,IAAA7sE,EAAA,EAAAA,EAAA9F,KAAAqe,YAAA/Y,OAAAQ,IACA9F,KAAAqe,YAAAvY,GAAA+oC,SAEA,CACA,WAAAy/B,CAAA7nE,EAAAmjB,EAAAgpD,GACAnsE,EAAA/E,QAAA,GACA+E,aAAAusC,IACAhzC,KAAA6yE,qBAAApsE,GACAzG,KAAA8yE,aAAArsE,EAAAmjB,EAAAgpD,IAEAnsE,aAAA8xD,KACAv4D,KAAA+yE,0BAAAtsE,GACAzG,KAAAgzE,kBAAAvsE,EAAAmjB,IAEA5pB,KAAAm/D,UAAAv3D,OAAAnB,EAAAyX,OACA,CACA,yBAAA60D,CAAAtsE,GACAzG,KAAAyzC,cACAzzC,KAAA0K,QAAAqoE,0BAAAtsE,EAAA0pC,iBACAnwC,KAAAsoE,oBAAA7hE,EAAA0pC,SAAA0qB,KAEA,CACA,oBAAAgY,CAAApsE,GACAzG,KAAAyzC,cACAzzC,KAAA0K,QAAAmoE,qBAAApsE,EAAA0pC,iBACAnwC,KAAA+4D,SAAAtyD,EAAA0pC,SAAAr+B,IAEA,CACA,YAAAghE,CAAA/0D,EAAA6L,EAAAgpD,GACA,IAAA9sE,EAAAma,EAAA0vB,EACA,MAAA71B,EAAA,GAAAsN,EAAA,GAOA,IANApnB,KAAAm3C,YAAAuJ,eACA92B,GACA5pB,KAAAs1C,gBAAAqkB,iBAAA,IAAA+F,GAAA3hD,IAEAnW,GAAA5H,KAAAoe,OAAAL,GACA/d,KAAAy8D,gBAAA70D,OAAAmW,GACAjY,EAAA,EAAAA,EAAAiY,EAAA8xB,WAAAvqC,OAAAQ,IAAA,CACA6pC,EAAA5xB,EAAA8xB,WAAA/pC,GACA,IAAA,IAAAgX,EAAA,EAAAA,EAAA6yB,EAAAtxB,YAAA/Y,OAAAwX,IACAmD,EAAA0vB,EAAAtxB,YAAAvB,GACA81D,GAAA3qE,GAAA2qE,EAAA3yD,KACAA,EAAA2P,kBAAA+f,EACA71B,EAAAlQ,KAAAqW,GAEAA,EAAA6P,kBAAA6f,GACAvoB,EAAAxd,KAAAqW,GAIA,CACA,IAAAna,EAAA,EAAAA,EAAAgU,EAAAxU,OAAAQ,IACAgU,EAAAhU,GAAAL,OAAA,KAAAmkB,GACA9P,EAAAhU,GAAA0pC,cAEA,IAAA1pC,EAAA,EAAAA,EAAAshB,EAAA9hB,OAAAQ,IACAshB,EAAAthB,GAAAqI,OAAA,KAAAyb,GACAxC,EAAAthB,GAAA0pC,aAEA,CACA,iBAAAwjC,CAAA/yD,EAAA2J,GACA3J,EAAA2P,iBACAhoB,GAAAqY,EAAA2P,gBAAAvR,YAAA4B,GAEAA,EAAA6P,iBACAloB,GAAAqY,EAAA6P,gBAAAzR,YAAA4B,GAEA2J,GACA5pB,KAAAs1C,gBAAAqkB,iBAAA,IAAA8F,GAAAx/C,IAEArY,GAAA5H,KAAAqe,YAAA4B,EACA,CACA,uBAAAgzD,CAAAl1D,GACA,MAAAM,EAAAN,EAAAM,cACA,IAAA/S,EACA,GAAA+S,EACA,IAAA/S,EAAA,EAAAA,EAAA+S,EAAA/Y,OAAAgG,IACAtL,KAAAsuE,YAAAjwD,EAAA/S,IAAA,EAGA,CACA,eAAAsyD,GACA59D,KAAA0K,QAAA89D,gBACA,CACA,qBAAAgF,GACAxtE,KAAA+sE,UACA/sE,KAAA+sE,QAAA,KAEA,CACA,SAAA/V,GACA,OAAA92D,EAAA4J,CACA,CACA,eAAAopE,GACA,MAAAp7C,EAAA93B,KAAA+2D,OAAAh/B,SACAo7C,EAAAlzE,EAAAmkB,IACA6O,WAAA6E,EAAAhxB,GAAAgxB,EAAA9wB,GACAosE,EAAA,IAAAnzE,EAAA00B,EAAA,CAAA,EAAA,GAAA,CAAAmD,EAAA7iB,MAAA6iB,EAAA9iB,SACAq+D,EAAApzE,EAAAwJ,EAAA6pE,SAAAF,GACAG,EAAA,IAAAtzE,EAAAg4B,EAAA,CAAA/E,UAAAigD,IACAK,EAAA,IAAAvzE,EAAAg4B,EAAA,CAAAw7C,KAAAJ,IACAtxD,EAAA/hB,KAAA+2D,OAAA7iC,eAAAhV,SAAA,GAIA,OAHAs0D,EAAAn7C,OAAAk7C,GAEAA,EAAAr0D,SAAAtV,KAAAmY,GACAyxD,CACA,CACA,YAAAE,GACA,MAAA38D,EAAA,EAAA/W,KAAAwsE,MACA11D,EAAA7W,EAAAmkB,IAAAtN,MAAAC,EAAAA,GACAw8D,EAAA,IAAAtzE,EAAAg4B,EAAA,CACA/E,UAAApc,IAEAiL,EAAA/hB,KAAAm/D,UAAAjrC,eAEA,OADAq/C,EAAAr0D,SAAAtV,KAAAmY,GACAwxD,CACA,CACA,qBAAAla,CAAAp5C,EAAA0zB,GACA,GAAA3zC,KAAA0K,QAAA2uD,sBACA,OAAAr5D,KAAA0K,QAAA2uD,sBAAAp5C,EAAA0zB,EAEA,CACA,gBAAAC,CAAA71B,EAAA41B,GACA,GAAA3zC,KAAA0K,QAAAkpC,iBACA,OAAA5zC,KAAA0K,QAAAkpC,iBAAA71B,EAAA41B,EAEA,GAqKAv0C,EAAAu0E,GAAAnR,GACApjE,EAAA8sC,GAAAu1B,GACAriE,EAAA0I,GAAA+5D,GACAziE,EAAAw0E,GAAA/iC,GACAzxC,EAAAqK,EAAAmO,GACAxY,EAAA6N,EAAAmlB,GACAhzB,EAAAyN,EAAA6H,GACAtV,EAAA4M,EAAAyG,GACArT,EAAAgyB,EAAA3d,GACArU,EAAA2pB,EAAA0R,GACAr7B,EAAA2P,EAAAyuB,GACAp+B,EAAA0G,EAAAktB,GACA5zB,EAAA0d,EAAA4f,GACAt9B,EAAAgT,EAAAqnB,GACAr6B,EAAAgvB,EAAAoI,GACAp3B,EAAA0K,EA/0TA,cAAA6rB,GACA,WAAAlrB,CAAAC,GACAwH,MAAAxH,GACA1K,KAAA47B,QAAAb,GAAAa,QACA57B,KAAA6X,UAAA,IAAA5X,EAAAg4B,EACAj4B,KAAAg7B,SAAAD,GAAAC,SAAAlyB,KAAA9I,MACAA,KAAAk7B,wBAAAH,GAAAG,wBAAApyB,KAAA9I,MACAA,KAAAq7B,cAAAN,GAAAM,cAAAvyB,KAAA9I,MACAA,KAAAw7B,eAAAT,GAAAS,eAAA1yB,KAAA9I,MACAA,KAAAy7B,cAAAV,GAAAU,cAAA3yB,KAAA9I,MACAA,KAAA27B,gBAAAZ,GAAAY,gBAAA7yB,KAAA9I,MACAA,KAAA67B,cAAAd,GAAAc,cAAA/yB,KAAA9I,MACAA,KAAAo8B,eAAArB,GAAAqB,eAAAtzB,KAAA9I,MACAA,KAAA28B,YACA38B,KAAAw7B,gBACA,CACA,gBAAAxH,GACA,OAAAh0B,KAAA6X,SACA,CACA,MAAAoc,CAAAvpB,GACA,GAAAA,EAAA,CAEA,MAAAiB,GADAjB,EAAAA,GAAA,CAAA,GACAiB,KACAuD,EAAAxE,EAAAwE,GACAvD,IACA3L,KAAA0K,QAAAiB,KAAAA,GAEAuD,IACAlP,KAAA0K,QAAAwE,GAAAA,GAEAvD,GAAAuD,GACAlP,KAAAk9B,YACAl9B,KAAAo8B,gBAAA,EAAA1xB,IAGA1K,KAAAo8B,gBAAA,EAAA1xB,GAEAwH,MAAA+hB,OAAAvpB,EACA,CACA,CACA,SAAAiyB,GACA,MAAAjyB,EAAA1K,KAAA0K,QACAwpB,EAAAl0B,KAAAk0B,eAAA,IAAAj0B,EAAAwJ,EAAA,CACAisB,OAAAhrB,EAAAgrB,SAEA11B,KAAA61B,QACA71B,KAAAk9B,YACAl9B,KAAA6X,UAAAwgB,OAAAnE,EACA,CACA,SAAAgJ,GACA,MAAAxyB,EAAA1K,KAAA0K,QACAwpB,EAAAl0B,KAAAk0B,eACAvoB,EAAAjB,EAAAiB,MAAA,IAAA8H,GACAvE,EAAAxE,EAAAwE,IAAA,IAAAuE,GACAygB,EAAAtD,SAAA6L,SAAA,CACAnH,GAAA3pB,EAAA7E,EAAA6E,EAAA3E,GACAsuB,GAAApmB,EAAApI,EAAAoI,EAAAlI,IAEA,GAsxTA5H,EAAA2K,EAj4VA,SAAA8pE,EAAAC,GACA,IAAAhtE,EAAAE,EAAAuM,EACA,GACAzM,EAAA,EAAA9F,KAAAkF,SAAA,EACAc,EAAA,EAAAhG,KAAAkF,SAAA,EACAqN,EAAAzM,EAAAA,EAAAE,EAAAA,SACAuM,GAAAA,EAAA,GACA,OAAAsgE,EAAAC,EAAAhtE,EAAA9F,KAAAgM,MAAA,EAAAhM,KAAA4Q,IAAA2B,GAAAA,EACA,EA03VAnU,EAAAsoC,EAl+TA,cAAAhO,GACA,WAAAjvB,CAAA4L,EAAA3L,GACAwH,MAAAxH,GACA1K,KAAAk0B,eAAA,IAAAj0B,EAAAmS,EAAAojB,GAAAnf,GAAA3L,GACA1K,KAAAg5B,WACA,CACA,IAAA3iB,CAAAA,GACA,GAAAA,EACArW,KAAAk0B,eAAA7d,KAAAmf,GAAAnf,QAEA,CACA,MAAA09D,EAAA/zE,KAAAk0B,eAAA7d,OACA,GAAA09D,EACA,OAAA,IAAAr/D,GAAAq/D,EAAAlkE,OAAA/I,EAAAitE,EAAAlkE,OAAA7I,EAAA+sE,EAAAnuE,KAAAqP,MAAA8+D,EAAAnuE,KAAAoP,OAEA,CACA,CACA,MAAAg/D,GACAh0E,KAAAk0B,eAAA8/C,QACA,CACA,MAAA//C,CAAAvpB,GACAmP,GAAA7Z,KAAAk0B,eAAAxpB,QAAAA,GACAwH,MAAA+hB,OAAAtvB,KAAA3E,KAAA0K,EACA,GA48TAtL,EAAAuO,EAAA0uB,GACAj9B,EAAA8U,EAAA8oB,GACA59B,EAAAmU,EAAAlD,GACAjR,EAAAqN,EAAAitB,GACAt6B,EAAAglB,EAAA+U,GACA/5B,EAAAuoB,EAAA2K,GACAlzB,EAAAsN,EAAAmmB,GACAzzB,EAAAwhB,EAAAgS,GACAxzB,EAAA0H,EAAApG,EACAtB,EAAA4H,EAAAysB,GACAr0B,EAAA8+D,EAAA98D,CAEA","file":"kendo.diagram-common.cmn.chunk.min.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('kendo.drawing.cmn.chunk.js'), require('kendo.common.cmn.chunk.js')) :\n    typeof define === 'function' && define.amd ? define(['exports', 'kendo.drawing.cmn.chunk', 'kendo.common.cmn.chunk'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.kendo = global.kendo || {}, global.kendo._globals = global.kendo._globals || {}, global.kendo._globals.DiagramCommonCmnChunk = {}), global.kendo._globals.DrawingCmnChunk, global.kendo._globals.CommonCmnChunk));\n})(this, (function (exports, kendo_drawing_cmn_chunk_js, kendo_common_cmn_chunk_js) {\n    const __meta__ = {\n        id: \"diagram-common.cmn.chunk\",\n        name: \"DiagramCommonCmnChunk\",\n        category: \"web\",\n        description: \"A reusable outputed chunk of code\",\n        depends: ['drawing.cmn.chunk', 'common.cmn.chunk'],\n        hidden: true,\n        chunk: true,\n        \n    };\n\n    const WIDTH = 'width';\n    const HEIGHT = 'height';\n    const X = 'x';\n    const Y = 'y';\n    const FULL_CIRCLE_ANGLE = 360;\n    const TRANSPARENT = 'transparent';\n    const START$1 = 'start';\n    const END$1 = 'end';\n    const Markers = {\n        none: 'none',\n        arrowStart: 'ArrowStart',\n        filledCircle: 'FilledCircle',\n        arrowEnd: 'ArrowEnd'\n    };\n    const DEG_TO_RAD = Math.PI / 180;\n    const EPSILON = 1e-06;\n    const CHANGE$1 = 'change';\n    const Cursors = {\n        arrow: 'default',\n        grip: 'pointer',\n        cross: 'pointer',\n        add: 'pointer',\n        move: 'move',\n        select: 'pointer',\n        south: 's-resize',\n        east: 'e-resize',\n        west: 'w-resize',\n        north: 'n-resize',\n        rowresize: 'row-resize',\n        colresize: 'col-resize'\n    };\n    const HIT_TEST_DISTANCE = 10, AUTO = 'Auto', TOP = 'Top', RIGHT = 'Right', LEFT = 'Left', BOTTOM = 'Bottom', DEFAULT_SNAP_SIZE = 10, DEFAULT_SNAP_ANGLE = 10, DRAG_START = 'dragStart', DRAG = 'drag', DRAG_END = 'dragEnd', ITEMROTATE = 'itemRotate', ITEMBOUNDSCHANGE = 'itemBoundsChange', MIN_SNAP_SIZE = 5, MIN_SNAP_ANGLE = 5, MOUSE_ENTER = 'mouseEnter', MOUSE_LEAVE = 'mouseLeave', ZOOM_START = 'zoomStart', ZOOM_END = 'zoomEnd', SCROLL_MIN = -20000, SCROLL_MAX = 20000, FRICTION$1 = 0.90, FRICTION_MOBILE = 0.93, VELOCITY_MULTIPLIER$1 = 5, PAN = 'pan', ROTATED = 'rotated', SOURCE = 'source', TARGET = 'target', HANDLE_NAMES = {\n        '-1': SOURCE,\n        '1': TARGET\n    };\n    const ConnectionEditing = 'Connection Editing';\n    const NS = '.kendoDiagram', CASCADING = 'cascading', CLICK = 'click', ERROR = 'error', MAXINT = 9007199254740992, SELECT$1 = 'select', NONE = 'none', DEFAULT_CANVAS_WIDTH = 600, DEFAULT_CANVAS_HEIGHT = 600, DEFAULT_SHAPE_TYPE = 'rectangle', DEFAULT_SHAPE_WIDTH = 100, DEFAULT_SHAPE_HEIGHT = 100, DEFAULT_SHAPE_MINWIDTH = 20, DEFAULT_SHAPE_MINHEIGHT = 20, DEFAULT_SHAPE_POSITION = 0, DEFAULT_CONNECTION_BACKGROUND = 'Yellow', MAX_VALUE = Number.MAX_VALUE, MIN_VALUE = -Number.MAX_VALUE, ABSOLUTE = 'absolute', TRANSFORMED = 'transformed', MOUSEWHEEL_NS = 'DOMMouseScroll' + NS + ' mousewheel' + NS, MOBILE_ZOOM_RATE = 0.05, MOBILE_PAN_DISTANCE = 5, CONNECTION_CONTENT_OFFSET = 5;\n\n    const isNearZero = (value) => Math.abs(value) < EPSILON;\n    const isDefined = (obj) => typeof obj !== 'undefined';\n    const defined = isDefined;\n    const isFunction$1 = (obj) => typeof obj === 'function';\n    const isUndefined = (obj) => typeof obj === 'undefined' || obj === null;\n    /**\n     * Returns whether the given object is an object or a value.\n     */\n    const isObject = (obj) => obj === Object(obj);\n    /**\n     * Returns whether the object has a property with the given name.\n     */\n    const has = (obj, key) => Object.hasOwnProperty.call(obj, key);\n    /**\n     * Returns whether the given object is a string.\n     */\n    const isString$1 = (obj) => {\n        return Object.prototype.toString.call(obj) === '[object String]';\n    };\n    const isBoolean = (obj) => {\n        return Object.prototype.toString.call(obj) === '[object Boolean]';\n    };\n    const isType = (obj, type) => {\n        return Object.prototype.toString.call(obj) === '[object ' + type + ']';\n    };\n    /**\n     * Returns whether the given object is a number.\n     */\n    const isNumber = (obj) => !isNaN(parseFloat(obj)) && isFinite(obj);\n    /**\n     * Return whether the given object (array or dictionary).\n     */\n    const isEmpty = (obj) => {\n        if (obj === null) {\n            return true;\n        }\n        if (Array.isArray(obj) || isString$1(obj)) {\n            return obj.length === 0;\n        }\n        for (const key in obj) {\n            if (has(obj, key)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    const simpleExtend = (destination, source) => {\n        if (!isObject(source)) {\n            return;\n        }\n        for (const name in source) {\n            if (name) {\n                destination[name] = source[name];\n            }\n        }\n    };\n    /**\n     * Returns an array of the specified size and with each entry set to the given value.\n     *\n     * @param size\n     * @param value\n     * @returns {Array}\n     */\n    const initArray = (size, value) => {\n        const array = [];\n        for (let i = 0; i < size; ++i) {\n            array[i] = value;\n        }\n        return array;\n    };\n    const serializePoints = (points) => {\n        const res = [];\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            res.push(p.x + ';' + p.y);\n        }\n        return res.join(';');\n    };\n    const deserializePoints = (s) => {\n        const v = s.split(';');\n        const points = [];\n        if (v.length % 2 !== 0) {\n            throw new Error('Not an array of points.');\n        }\n        for (let i = 0; i < v.length; i += 2) {\n            points.push({\n                x: parseInt(v[i], 10),\n                y: parseInt(v[i + 1], 10)\n            });\n        }\n        return points;\n    };\n    /**\n     * Returns an integer within the given bounds.\n     *\n     * @param lower The inclusive lower bound.\n     * @param upper The exclusive upper bound.\n     * @returns {number}\n     */\n    const randomInteger = (lower, upper) => {\n        const random = Math.floor(Math.random() * upper) + lower;\n        return parseInt(random.toString(), 10);\n    };\n    /*\n     Depth-first traversal of the given node.\n     */\n    const DFT = (el, func) => {\n        func(el);\n        if (el.childNodes) {\n            for (let i = 0; i < el.childNodes.length; i++) {\n                const item = el.childNodes[i];\n                DFT(item, func);\n            }\n        }\n    };\n    /*\n     Returns the angle in degrees for the given matrix\n     */\n    const getMatrixAngle = (m) => {\n        if (m === null || m.d === 0) {\n            return 0;\n        }\n        return Math.atan2(m.b, m.d) * 180 / Math.PI;\n    };\n    /*\n     Returns the scaling factors for the given matrix.\n     */\n    const getMatrixScaling = (m) => {\n        const sX = Math.sqrt(m.a * m.a + m.c * m.c);\n        const sY = Math.sqrt(m.b * m.b + m.d * m.d);\n        return [sX, sY];\n    };\n    const findRadian = (start, end) => {\n        if (start === end) {\n            return 0;\n        }\n        const sngXComp = end.x - start.x;\n        const sngYComp = start.y - end.y;\n        const atan = Math.atan(sngXComp / sngYComp);\n        if (sngYComp >= 0) {\n            return sngXComp < 0 ? atan + (2 * Math.PI) : atan;\n        }\n        return atan + Math.PI;\n    };\n    const sign = (num) => {\n        return num ? num < 0 ? -1 : 1 : 0;\n    };\n    const findAngle = (center, end) => {\n        return findRadian(center, end) * 180 / Math.PI;\n    };\n    const forEach = (arr, iterator, thisRef) => {\n        for (let i = 0; i < arr.length; i++) {\n            iterator.call(thisRef, arr[i], i, arr);\n        }\n    };\n    const getAny = (arr, predicate) => {\n        for (let i = 0; i < arr.length; ++i) {\n            if (predicate(arr[i])) {\n                return arr[i];\n            }\n        }\n        return null;\n    };\n    const remove = (arr, what) => {\n        let ax = arr.indexOf(what);\n        while (ax !== -1) {\n            arr.splice(ax, 1);\n            ax = arr.indexOf(what);\n        }\n        return arr;\n    };\n    const contains = (arr, obj) => {\n        return (arr || []).includes(obj);\n    };\n    const indexOf = (arr, what) => {\n        return arr.indexOf(what);\n    };\n    const inArray = (what, arr) => {\n        return arr.indexOf(what);\n    };\n    const grep$1 = (arr, predicate) => arr.filter(predicate);\n    const fold = (list, iterator, acc, context) => {\n        let initial = acc !== undefined;\n        for (let i = 0; i < list.length; i++) {\n            const value = list[i];\n            if (!initial) {\n                acc = value;\n                initial = true;\n            }\n            else {\n                acc = iterator.call(context, acc, value, i, list);\n            }\n        }\n        if (!initial) {\n            throw new Error('Reduce of empty array with no initial value');\n        }\n        return acc;\n    };\n    const find = (arr, iterator, context) => {\n        return arr.find(iterator.bind(context)) || undefined;\n    };\n    const first = (arr, constraint, context) => {\n        if (arr.length === 0) {\n            return null;\n        }\n        if (isUndefined(constraint)) {\n            return arr[0];\n        }\n        return find(arr, constraint, context);\n    };\n    /**\n     * Inserts the given element at the specified position and returns the result.\n     */\n    const insert = (arr, element, position) => {\n        arr.splice(position, 0, element);\n        return arr;\n    };\n    const all = (arr, iterator, context) => {\n        let result = true;\n        let value;\n        for (let i = 0; i < arr.length; i++) {\n            value = arr[i];\n            result = result && iterator.call(context, value, i, arr);\n            if (!result) {\n                break;\n            }\n        }\n        return result;\n    };\n    const clear = (arr) => {\n        arr.splice(0, arr.length);\n    };\n    const bisort = (a, b, sortfunc) => {\n        if (isUndefined(a)) {\n            throw new Error('First array is not specified.');\n        }\n        if (isUndefined(b)) {\n            throw new Error('Second array is not specified.');\n        }\n        if (a.length !== b.length) {\n            throw new Error('The two arrays should have equal length');\n        }\n        const points = [];\n        for (let i = 0; i < a.length; i++) {\n            points.push({ x: a[i], y: b[i] });\n        }\n        if (isUndefined(sortfunc)) {\n            points.sort((m, n) => m.x - n.x);\n        }\n        else {\n            points.sort((m, n) => sortfunc(m.x, n.x));\n        }\n        clear(a);\n        clear(b);\n        for (let i = 0; i < points.length; i++) {\n            a.push(points[i].x);\n            b.push(points[i].y);\n        }\n    };\n    const addRange = (arr, range) => {\n        arr.push(...range);\n    };\n    const noop$1 = () => { };\n\n    const STRING = 'string';\n    const FUNCTION = 'function';\n    const preventDefault$2 = function () {\n        this._defaultPrevented = true;\n    };\n    const isDefaultPrevented = function () {\n        return this._defaultPrevented === true;\n    };\n    class Observable {\n        constructor() {\n            this.options = {};\n            this.events = [];\n            this._events = {};\n        }\n        destroy() {\n            this.unbind();\n        }\n        bind(event, handlers, one) {\n            if (!handlers && isObject(event) && !Array.isArray(event)) {\n                for (const name in event) {\n                    if (event[name]) {\n                        this.bind(name, event[name]);\n                    }\n                }\n                return this;\n            }\n            const eventNames = typeof event === STRING ? [event] : event, handlersIsFunction = typeof handlers === FUNCTION;\n            let original, handler;\n            for (let idx = 0, length = eventNames.length; idx < length; idx++) {\n                const eventName = eventNames[idx];\n                handler = handlersIsFunction ? handlers : handlers[eventName];\n                if (handler) {\n                    if (one) {\n                        original = handler;\n                        handler = (...args) => {\n                            this.unbind(eventName, handler);\n                            original.apply(this, args);\n                        };\n                        handler.original = original;\n                    }\n                    this._events[eventName] = this._events[eventName] || [];\n                    this._events[eventName].push(handler);\n                }\n            }\n            return this;\n        }\n        one(eventNames, handlers) {\n            return this.bind(eventNames, handlers, true);\n        }\n        first(eventName, handlers) {\n            const eventNames = typeof eventName === STRING ? [String(eventName)] : Array.from(eventName), handlersIsFunction = typeof handlers === FUNCTION;\n            let handler;\n            for (let idx = 0, length = eventNames.length; idx < length; idx++) {\n                const curName = eventNames[idx];\n                handler = handlersIsFunction ? handlers : handlers[curName];\n                if (handler) {\n                    this._events[curName] = this._events[curName] || [];\n                    this._events[curName].unshift(handler);\n                }\n            }\n            return this;\n        }\n        trigger(eventName, eventArgs) {\n            let events = this._events[eventName];\n            if (events) {\n                const e = eventArgs || {};\n                e.sender = this;\n                e._defaultPrevented = false;\n                e.preventDefault = preventDefault$2;\n                e.isDefaultPrevented = isDefaultPrevented;\n                events = events.slice();\n                for (let idx = 0, length = events.length; idx < length; idx++) {\n                    events[idx].call(this, e);\n                }\n                return e._defaultPrevented === true;\n            }\n            return false;\n        }\n        unbind(eventName, handler) {\n            const events = this._events[eventName];\n            if (eventName === undefined) {\n                this._events = {};\n            }\n            else if (events) {\n                if (handler) {\n                    for (let idx = events.length - 1; idx >= 0; idx--) {\n                        if (events[idx] === handler || events[idx].original === handler) {\n                            events.splice(idx, 1);\n                        }\n                    }\n                }\n                else {\n                    this._events[eventName] = [];\n                }\n            }\n            return this;\n        }\n        _setEvents(options) {\n            const length = (this.events || []).length;\n            for (let idx = 0; idx < length; idx++) {\n                const name = this.events[idx];\n                if (this.options[name] && options[name]) {\n                    this.unbind(name, this.options[name]);\n                    if (this._events && this._events[name]) {\n                        delete this._events[name];\n                    }\n                }\n            }\n            this.bind(this.events, options);\n        }\n    }\n\n    var Utils$1 = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        DFT: DFT,\n        Observable: Observable,\n        addRange: addRange,\n        all: all,\n        bisort: bisort,\n        clear: clear,\n        contains: contains,\n        defined: defined,\n        deserializePoints: deserializePoints,\n        find: find,\n        findAngle: findAngle,\n        findRadian: findRadian,\n        first: first,\n        fold: fold,\n        forEach: forEach,\n        getAny: getAny,\n        getMatrixAngle: getMatrixAngle,\n        getMatrixScaling: getMatrixScaling,\n        grep: grep$1,\n        has: has,\n        inArray: inArray,\n        indexOf: indexOf,\n        initArray: initArray,\n        insert: insert,\n        isBoolean: isBoolean,\n        isDefined: isDefined,\n        isEmpty: isEmpty,\n        isFunction: isFunction$1,\n        isNearZero: isNearZero,\n        isNumber: isNumber,\n        isObject: isObject,\n        isString: isString$1,\n        isType: isType,\n        isUndefined: isUndefined,\n        noop: noop$1,\n        randomInteger: randomInteger,\n        remove: remove,\n        serializePoints: serializePoints,\n        sign: sign,\n        simpleExtend: simpleExtend\n    });\n\n    /**\n     * The Range defines an array of equally separated numbers.\n     *\n     * @param start The start-value of the Range.\n     * @param stop The end-value of the Range.\n     * @param step The separation between the values (default:1).\n     * @returns {Array}\n     */\n    function Range(start, stop, step) {\n        if (typeof start == 'undefined' || typeof stop == 'undefined') {\n            return [];\n        }\n        if (step && sign(stop - start) !== sign(step)) {\n            throw new Error('The sign of the increment should allow to reach the stop-value.');\n        }\n        step = step || 1;\n        start = start || 0;\n        stop = stop || start;\n        if ((stop - start) / step === Infinity) {\n            throw new Error('Infinite range defined.');\n        }\n        const range = [];\n        let i = -1, j;\n        function rangeIntegerScale(x) {\n            let curK = 1;\n            while (x * curK % 1) {\n                curK *= 10;\n            }\n            return curK;\n        }\n        const k = rangeIntegerScale(Math.abs(step));\n        start *= k;\n        stop *= k;\n        step *= k;\n        if (start > stop && step > 0) {\n            step = -step;\n        }\n        if (step < 0) {\n            while ((j = start + step * ++i) >= stop) {\n                range.push(j / k);\n            }\n        }\n        else {\n            while ((j = start + step * ++i) <= stop) {\n                range.push(j / k);\n            }\n        }\n        return range;\n    }\n    ;\n\n    const Easing = {\n        easeInOut(pos) {\n            return ((-Math.cos(pos * Math.PI) / 2) + 0.5);\n        }\n    };\n    /**\n     * An animation ticker driving an adapter which sets a particular\n     * property in function of the tick.\n     *\n     * @type {*}\n     */\n    class Ticker {\n        constructor() {\n            this.adapters = [];\n            this.target = 0;\n            this.tick = 0;\n            this.interval = 20;\n            this.duration = 800;\n            this.lastTime = null;\n            this.handlers = [];\n            this.timerDelegate = () => { };\n            this.intervalId = null;\n            this.caller = null;\n            this.timerDelegate = () => {\n                this.onTimerEvent();\n            };\n        }\n        ;\n        addAdapter(a) {\n            this.adapters.push(a);\n        }\n        ;\n        onComplete(handler) {\n            this.handlers.push(handler);\n        }\n        ;\n        removeHandler(handler) {\n            this.handlers = this.handlers.filter((h) => {\n                return h !== handler;\n            });\n        }\n        ;\n        trigger() {\n            if (this.handlers) {\n                forEach(this.handlers, (h) => {\n                    return h.call(this.caller !== null ? this.caller : this);\n                });\n            }\n        }\n        ;\n        onStep() {\n        }\n        ;\n        seekTo(to) {\n            this.seekFromTo(this.tick, to);\n        }\n        ;\n        seekFromTo(from, to) {\n            this.target = Math.max(0, Math.min(1, to));\n            this.tick = Math.max(0, Math.min(1, from));\n            this.lastTime = new Date().getTime();\n            if (!this.intervalId) {\n                this.intervalId = window.setInterval(this.timerDelegate, this.interval);\n            }\n        }\n        ;\n        stop() {\n            if (this.intervalId) {\n                window.clearInterval(this.intervalId);\n                this.intervalId = null;\n                // this.trigger.call(this);\n                this.trigger();\n                // this.next();\n            }\n        }\n        ;\n        play(origin) {\n            if (this.adapters.length === 0) {\n                return;\n            }\n            if (origin !== null) {\n                this.caller = origin;\n            }\n            this.initState();\n            this.seekFromTo(0, 1);\n        }\n        ;\n        reverse() {\n            this.seekFromTo(1, 0);\n        }\n        ;\n        initState() {\n            if (this.adapters.length === 0) {\n                return;\n            }\n            for (let i = 0; i < this.adapters.length; i++) {\n                this.adapters[i].initState();\n            }\n        }\n        ;\n        propagate() {\n            const value = Easing.easeInOut(this.tick);\n            for (let i = 0; i < this.adapters.length; i++) {\n                this.adapters[i].update(value);\n            }\n        }\n        ;\n        onTimerEvent() {\n            const now = new Date().getTime();\n            const timePassed = now - this.lastTime;\n            this.lastTime = now;\n            const movement = (timePassed / this.duration) * (this.tick < this.target ? 1 : -1);\n            if (Math.abs(movement) >= Math.abs(this.tick - this.target)) {\n                this.tick = this.target;\n            }\n            else {\n                this.tick += movement;\n            }\n            try {\n                this.propagate();\n            }\n            finally {\n                this.onStep.call(this);\n                if (this.target === this.tick) {\n                    this.stop();\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns a random identifier which can be used as an ID of objects, eventually augmented with a prefix.\n     *\n     * @returns {string}\n     */\n    function randomId(length) {\n        if (isUndefined(length)) {\n            length = 10;\n        }\n        // old version return Math.floor((1 + Math.random()) * 0x1000000).toString(16).substring(1);\n        let result = '';\n        const chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n        for (let i = length; i > 0; --i) {\n            result += chars.charAt(Math.round(Math.random() * (chars.length - 1)));\n        }\n        return result;\n    }\n\n    /**\n     * Represents a collection of key-value pairs that are organized based on the hash code of the key.\n     * _buckets[hashId] = {key: key, value:...}\n     * Important: do not use the standard Array access method, use the get/set methods instead.\n     * See http://en.wikipedia.org/wiki/Hash_table\n     */\n    class HashTable {\n        constructor() {\n            this._buckets = {};\n            this.length = 0;\n        }\n        /**\n         * Adds the literal object with the given key (of the form {key: key,....}).\n         */\n        add(key, value) {\n            const obj = this._createGetBucket(key);\n            if (isDefined(value)) {\n                obj.value = value;\n            }\n            return obj;\n        }\n        /**\n         * Gets the literal object with the given key.\n         */\n        get(key) {\n            if (this._bucketExists(key)) {\n                return this._createGetBucket(key);\n            }\n            return null;\n        }\n        /**\n         * Set the key-value pair.\n         *\n         * @param key The key of the entry.\n         * @param value The value to set. If the key already exists the value will be overwritten.\n         */\n        set(key, value) {\n            this.add(key, value);\n        }\n        /**\n         * Determines whether the HashTable contains a specific key.\n         */\n        containsKey(key) {\n            return this._bucketExists(key);\n        }\n        /**\n         * Removes the element with the specified key from the hashtable.\n         * Returns the removed bucket.\n         */\n        remove(key) {\n            if (this._bucketExists(key)) {\n                const hashId = this._hash(key);\n                delete this._buckets[hashId];\n                this.length--;\n                return key;\n            }\n        }\n        /**\n         * Foreach with an iterator working on the key-value pairs.\n         *\n         * @param func\n         */\n        forEach(func) {\n            const hashes = this._hashes();\n            for (let i = 0, len = hashes.length; i < len; i++) {\n                const hash = hashes[i];\n                const bucket = this._buckets[hash];\n                if (isUndefined(bucket)) {\n                    continue;\n                }\n                func(bucket);\n            }\n        }\n        /**\n         * Returns a (shallow) clone of the current HashTable.\n         *\n         * @returns {HashTable}\n         */\n        clone() {\n            const ht = new HashTable();\n            const hashes = this._hashes();\n            for (let i = 0, len = hashes.length; i < len; i++) {\n                const hash = hashes[i];\n                const bucket = this._buckets[hash];\n                if (isUndefined(bucket)) {\n                    continue;\n                }\n                ht.add(bucket.key, bucket.value);\n            }\n            return ht;\n        }\n        /**\n         * Returns the hashes of the buckets.\n         *\n         * @returns {Array}\n         * @private\n         */\n        _hashes() {\n            const hashes = [];\n            for (const hash in this._buckets) {\n                if (Object.prototype.hasOwnProperty.call(this._buckets, hash)) {\n                    hashes.push(hash);\n                }\n            }\n            return hashes;\n        }\n        _bucketExists(key) {\n            const hashId = this._hash(key);\n            return isDefined(this._buckets[hashId]);\n        }\n        /**\n         * Returns-adds the createGetBucket with the given key. If not present it will\n         * be created and returned.\n         * A createGetBucket is a literal object of the form {key: key, ...}.\n         */\n        _createGetBucket(key) {\n            const hashId = this._hash(key);\n            let bucket = this._buckets[hashId];\n            if (isUndefined(bucket)) {\n                bucket = { key: key };\n                this._buckets[hashId] = bucket;\n                this.length++;\n            }\n            return bucket;\n        }\n        /**\n         * Hashing of the given key.\n         */\n        _hash(key) {\n            if (isNumber(key)) {\n                return key;\n            }\n            if (isString$1(key)) {\n                return this._hashString(key);\n            }\n            if (isObject(key)) {\n                return this._objectHashId(key);\n            }\n            console.log(key);\n            throw new Error('Unsupported key type.');\n        }\n        /**\n         * Hashing of a string.\n         */\n        _hashString(s) {\n            // see for example http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\n            let result = 0;\n            if (s.length === 0) {\n                return result;\n            }\n            for (let i = 0; i < s.length; i++) {\n                const ch = s.charCodeAt(i);\n                result = ((result * 32) - result) + ch;\n            }\n            return result;\n        }\n        /**\n         * Returns the unique identifier for an object. This is automatically assigned and add on the object.\n         */\n        _objectHashId(key) {\n            let id = key._hashId;\n            if (isUndefined(id)) {\n                id = randomId();\n                key._hashId = id;\n            }\n            return id;\n        }\n    }\n\n    /**\n     * Represents a collection of key-value pairs.\n     * Important: do not use the standard Array access method, use the get/Set methods instead.\n     */\n    class Dictionary extends Observable {\n        /**\n         * Initializes a new instance of the Dictionary class.\n         *\n         * @param dictionary Loads the content of the given dictionary into this new one.\n         */\n        constructor(dictionary) {\n            super();\n            this._hashTable = new HashTable();\n            this.length = 0;\n            if (isDefined(dictionary)) {\n                if (Array.isArray(dictionary)) {\n                    for (let i = 0; i < dictionary.length; i++) {\n                        this.add(dictionary[i]);\n                    }\n                }\n                else {\n                    dictionary.forEach(function (k, v) {\n                        this.add(k, v);\n                    }, this);\n                }\n            }\n        }\n        /**\n         * Adds a key-value to the dictionary.\n         * If the key already exists this will assign the given value to the existing entry.\n         */\n        add(key, value) {\n            let entry = this._hashTable.get(key);\n            if (!entry) {\n                entry = this._hashTable.add(key);\n                this.length++;\n                this.trigger('changed');\n            }\n            entry.value = value;\n        }\n        /**\n         * Set the key-value pair.\n         *\n         * @param key The key of the entry.\n         * @param value The value to set. If the key already exists the value will be overwritten.\n         */\n        set(key, value) {\n            this.add(key, value);\n        }\n        /**\n         * Gets the value associated with the given key in the dictionary.\n         */\n        get(key) {\n            const entry = this._hashTable.get(key);\n            if (entry) {\n                return entry.value;\n            }\n            throw new Error('Cannot find key ' + key);\n        }\n        /**\n         * Returns whether the dictionary contains the given key.\n         */\n        containsKey(key) {\n            return this._hashTable.containsKey(key);\n        }\n        /**\n         * Removes the element with the specified key from the dictionary.\n         */\n        remove(key) {\n            if (this.containsKey(key)) {\n                this.trigger('changed');\n                this.length--;\n                return this._hashTable.remove(key);\n            }\n        }\n        /**\n         * The functional gets the key and value as parameters.\n         */\n        forEach(func, thisRef) {\n            this._hashTable.forEach(function (entry) {\n                func.call(thisRef, entry.key, entry.value);\n            });\n        }\n        /**\n         * Same as forEach except that only the value is passed to the functional.\n         */\n        forEachValue(func, thisRef) {\n            this._hashTable.forEach(function (entry) {\n                func.call(thisRef, entry.value);\n            });\n        }\n        /**\n         * Calls a defined callback function for each key in the dictionary.\n         */\n        forEachKey(func, thisRef) {\n            this._hashTable.forEach(function (entry) {\n                func.call(thisRef, entry.key);\n            });\n        }\n        /**\n         * Gets an array with all keys in the dictionary.\n         */\n        keys() {\n            const keys = [];\n            this.forEachKey(function (key) {\n                keys.push(key);\n            });\n            return keys;\n        }\n    }\n\n    const Geometry = {\n        /**\n         * Returns the squared distance to the line defined by the two given Points.\n         *\n         * @param p An arbitrary Point.\n         * @param a An endpoint of the line or segment.\n         * @param b The complementary endpoint of the line or segment.\n         */\n        _distanceToLineSquared: function (p, a, b) {\n            function d2(pt1, pt2) {\n                return (pt1.x - pt2.x) * (pt1.x - pt2.x) + (pt1.y - pt2.y) * (pt1.y - pt2.y);\n            }\n            if (a === b) { // returns the distance of p to a\n                return d2(p, a);\n            }\n            const vx = b.x - a.x, vy = b.y - a.y;\n            let dot = (p.x - a.x) * vx + (p.y - a.y) * vy;\n            if (dot < 0) {\n                return d2(a, p); // sits on side of a\n            }\n            dot = (b.x - p.x) * vx + (b.y - p.y) * vy;\n            if (dot < 0) {\n                return d2(b, p); // sits on side of b\n            }\n            // regular case, use crossproduct to get the sine out\n            dot = (b.x - p.x) * vy - (b.y - p.y) * vx;\n            return dot * dot / (vx * vx + vy * vy);\n        },\n        /**\n         * Returns the distance to the line defined by the two given Points.\n         *\n         * @param p An arbitrary Point.\n         * @param a An endpoint of the line or segment.\n         * @param b The complementary endpoint of the line or segment.\n         */\n        distanceToLine: function (p, a, b) {\n            return Math.sqrt(this._distanceToLineSquared(p, a, b));\n        },\n        /**\n         * Returns the distance of the given points to the polyline defined by the points.\n         *\n         * @param p An arbitrary point.\n         * @param points The points defining the polyline.\n         * @returns {Number}\n         */\n        distanceToPolyline: function (p, points) {\n            let minimum = Number.MAX_VALUE;\n            if (isUndefined(points) || points.length === 0) {\n                return Number.MAX_VALUE;\n            }\n            for (let s = 0; s < points.length - 1; s++) {\n                const p1 = points[s];\n                const p2 = points[s + 1];\n                const d = this._distanceToLineSquared(p, p1, p2);\n                if (d < minimum) {\n                    minimum = d;\n                }\n            }\n            return Math.sqrt(minimum);\n        }\n    };\n\n    class Polar {\n        constructor(r, a) {\n            this.r = r;\n            this.angle = a;\n        }\n    }\n\n    const HITTESTAREA = 3;\n    class Point extends kendo_drawing_cmn_chunk_js.P {\n        constructor(x, y) {\n            super(x, y);\n        }\n        clone() {\n            return new Point(this.x, this.y);\n        }\n        plus(p) {\n            return new Point(this.x + p.x, this.y + p.y);\n        }\n        minus(p) {\n            return new Point(this.x - p.x, this.y - p.y);\n        }\n        offset(value) {\n            return new Point(this.x - value, this.y - value);\n        }\n        times(s) {\n            return new Point(this.x * s, this.y * s);\n        }\n        normalize() {\n            if (this.length() === 0) {\n                return new Point();\n            }\n            return this.times(1 / this.length());\n        }\n        length() {\n            return Math.sqrt(this.x * this.x + this.y * this.y);\n        }\n        toString() {\n            return '(' + this.x + ',' + this.y + ')';\n        }\n        lengthSquared() {\n            return (this.x * this.x + this.y * this.y);\n        }\n        middleOf(p, q) {\n            return new Point(q.x - p.x, q.y - p.y).times(0.5).plus(p);\n        }\n        toPolar(useDegrees) {\n            let factor = 1;\n            if (useDegrees) {\n                factor = 180 / Math.PI;\n            }\n            const a = Math.atan2(Math.abs(this.y), Math.abs(this.x));\n            const halfpi = Math.PI / 2;\n            const len = this.length();\n            if (this.x === 0) {\n                // note that the angle goes down and not the usual mathematical convention\n                if (this.y === 0) {\n                    return new Polar(0, 0);\n                }\n                if (this.y > 0) {\n                    return new Polar(len, factor * halfpi);\n                }\n                if (this.y < 0) {\n                    return new Polar(len, factor * 3 * halfpi);\n                }\n            }\n            else if (this.x > 0) {\n                if (this.y === 0) {\n                    return new Polar(len, 0);\n                }\n                if (this.y > 0) {\n                    return new Polar(len, factor * a);\n                }\n                if (this.y < 0) {\n                    return new Polar(len, factor * (4 * halfpi - a));\n                }\n            }\n            else {\n                if (this.y === 0) {\n                    return new Polar(len, 2 * halfpi);\n                }\n                if (this.y > 0) {\n                    return new Polar(len, factor * (2 * halfpi - a));\n                }\n                if (this.y < 0) {\n                    return new Polar(len, factor * (2 * halfpi + a));\n                }\n            }\n        }\n        isOnLine(from, to) {\n            if (from.x > to.x) { // from must be the leftmost point\n                const temp = to;\n                to = from;\n                from = temp;\n            }\n            const r1 = new Rect(from.x, from.y).inflate(HITTESTAREA, HITTESTAREA), r2 = new Rect(to.x, to.y).inflate(HITTESTAREA, HITTESTAREA);\n            let o1, u1;\n            if (r1.union(r2).contains(this)) {\n                if (from.x === to.x || from.y === to.y) {\n                    return true;\n                }\n                else if (from.y < to.y) {\n                    o1 = r1.x + (((r2.x - r1.x) * (this.y - (r1.y + r1.height))) / ((r2.y + r2.height) - (r1.y + r1.height)));\n                    u1 = (r1.x + r1.width) + ((((r2.x + r2.width) - (r1.x + r1.width)) * (this.y - r1.y)) / (r2.y - r1.y));\n                }\n                else {\n                    o1 = r1.x + (((r2.x - r1.x) * (this.y - r1.y)) / (r2.y - r1.y));\n                    u1 = (r1.x + r1.width) + ((((r2.x + r2.width) - (r1.x + r1.width)) * (this.y - (r1.y + r1.height))) / ((r2.y + r2.height) - (r1.y + r1.height)));\n                }\n                return (this.x > o1 && this.x < u1);\n            }\n            return false;\n        }\n        parse(str) {\n            const tempStr = str.slice(1, str.length - 1), xy = tempStr.split(','), x = parseInt(xy[0], 10), y = parseInt(xy[1], 10);\n            if (!isNaN(x) && !isNaN(y)) {\n                return new Point(x, y);\n            }\n        }\n    }\n    class Rect {\n        constructor(x, y, width, height) {\n            this.x = x || 0;\n            this.y = y || 0;\n            this.width = width || 0;\n            this.height = height || 0;\n        }\n        contains(point) {\n            return ((point.x >= this.x) && (point.x <= (this.x + this.width)) && (point.y >= this.y) && (point.y <= (this.y + this.height)));\n        }\n        inflate(dx, dy) {\n            if (dy === undefined) {\n                dy = dx;\n            }\n            this.x -= dx;\n            this.y -= dy;\n            this.width += 2 * dx + 1;\n            this.height += 2 * dy + 1;\n            return this;\n        }\n        offset(dx, dy) {\n            let x = dx, y = dy;\n            if (dx instanceof Point) {\n                x = dx.x;\n                y = dx.y;\n            }\n            this.x += x;\n            this.y += y;\n            return this;\n        }\n        union(r) {\n            const x1 = Math.min(this.x, r.x);\n            const y1 = Math.min(this.y, r.y);\n            const x2 = Math.max((this.x + this.width), (r.x + r.width));\n            const y2 = Math.max((this.y + this.height), (r.y + r.height));\n            return new Rect(x1, y1, x2 - x1, y2 - y1);\n        }\n        center() {\n            return new Point(this.x + this.width / 2, this.y + this.height / 2);\n        }\n        top() {\n            return new Point(this.x + this.width / 2, this.y);\n        }\n        right() {\n            return new Point(this.x + this.width, this.y + this.height / 2);\n        }\n        bottom() {\n            return new Point(this.x + this.width / 2, this.y + this.height);\n        }\n        left() {\n            return new Point(this.x, this.y + this.height / 2);\n        }\n        topLeft() {\n            return new Point(this.x, this.y);\n        }\n        topRight() {\n            return new Point(this.x + this.width, this.y);\n        }\n        bottomLeft() {\n            return new Point(this.x, this.y + this.height);\n        }\n        bottomRight() {\n            return new Point(this.x + this.width, this.y + this.height);\n        }\n        clone() {\n            return new Rect(this.x, this.y, this.width, this.height);\n        }\n        isEmpty() {\n            return !this.width && !this.height;\n        }\n        equals(rect) {\n            return this.x === rect.x && this.y === rect.y && this.width === rect.width && this.height === rect.height;\n        }\n        rotatedBounds(angle) {\n            const rect = this.clone(), points = this.rotatedPoints(angle), tl = points[0], tr = points[1], br = points[2], bl = points[3];\n            rect.x = Math.min(br.x, tl.x, tr.x, bl.x);\n            rect.y = Math.min(br.y, tl.y, tr.y, bl.y);\n            rect.width = Math.max(br.x, tl.x, tr.x, bl.x) - rect.x;\n            rect.height = Math.max(br.y, tl.y, tr.y, bl.y) - rect.y;\n            return rect;\n        }\n        rotatedPoints(angle) {\n            const c = this.center(), br = this.bottomRight().rotate(angle, c), tl = this.topLeft().rotate(angle, c), tr = this.topRight().rotate(angle, c), bl = this.bottomLeft().rotate(angle, c);\n            return [tl, tr, br, bl];\n        }\n        toString(delimiter) {\n            delimiter = delimiter || ' ';\n            return this.x + delimiter + this.y + delimiter + this.width + delimiter + this.height;\n        }\n        scale(scaleX, scaleY, staicPoint, adornerCenter, angle) {\n            let tl = this.topLeft();\n            const thisCenter = this.center();\n            tl.rotate(angle, thisCenter).rotate(angle, adornerCenter);\n            const delta = staicPoint.minus(tl);\n            const scaled = new Point(delta.x * scaleX, delta.y * scaleY);\n            const position = delta.minus(scaled);\n            tl = tl.plus(position);\n            tl.rotate(angle, adornerCenter).rotate(angle, thisCenter);\n            this.x = tl.x;\n            this.y = tl.y;\n            this.width *= scaleX;\n            this.height *= scaleY;\n        }\n        zoom(zoom) {\n            this.x *= zoom;\n            this.y *= zoom;\n            this.width *= zoom;\n            this.height *= zoom;\n            return this;\n        }\n        overlaps(rect) {\n            const bottomRight = this.bottomRight();\n            const rectBottomRight = rect.bottomRight();\n            const overlaps = !(bottomRight.x < rect.x || bottomRight.y < rect.y ||\n                rectBottomRight.x < this.x || rectBottomRight.y < this.y);\n            return overlaps;\n        }\n        static toRect(rect) {\n            if (!(rect instanceof Rect)) {\n                rect = new Rect(rect.x, rect.y, rect.width, rect.height);\n            }\n            return rect;\n        }\n        static empty() {\n            return new Rect(0, 0, 0, 0);\n        }\n        static fromPoints(p, q) {\n            if (isNaN(p.x) || isNaN(p.y) || isNaN(q.x) || isNaN(q.y)) {\n                throw new Error('Some values are NaN.');\n            }\n            return new Rect(Math.min(p.x, q.x), Math.min(p.y, q.y), Math.abs(p.x - q.x), Math.abs(p.y - q.y));\n        }\n    }\n    /**\n     * Aligns two rectangles, where one is the container and the other is content.\n     */\n    class RectAlign {\n        constructor(container) {\n            this.container = Rect.toRect(container);\n        }\n        align(content, alignment) {\n            const alignValues = alignment.toLowerCase().split(' ');\n            for (let i = 0; i < alignValues.length; i++) {\n                content = this._singleAlign(content, alignValues[i]);\n            }\n            return content;\n        }\n        _singleAlign(content, alignment) {\n            if (isFunction$1(this[alignment])) {\n                return this[alignment](content);\n            }\n            else {\n                return content;\n            }\n        }\n        left(content) {\n            return this._align(content, this._left);\n        }\n        center(content) {\n            return this._align(content, this._center);\n        }\n        right(content) {\n            return this._align(content, this._right);\n        }\n        stretch(content) {\n            return this._align(content, this._stretch);\n        }\n        top(content) {\n            return this._align(content, this._top);\n        }\n        middle(content) {\n            return this._align(content, this._middle);\n        }\n        bottom(content) {\n            return this._align(content, this._bottom);\n        }\n        _left(container, content) {\n            content.x = container.x;\n        }\n        _center(container, content) {\n            content.x = ((container.width - content.width) / 2) || 0;\n        }\n        _right(container, content) {\n            content.x = container.width - content.width;\n        }\n        _top(container, content) {\n            content.y = container.y;\n        }\n        _middle(container, content) {\n            content.y = ((container.height - content.height) / 2) || 0;\n        }\n        _bottom(container, content) {\n            content.y = container.height - content.height;\n        }\n        _stretch(container, content) {\n            content.x = 0;\n            content.y = 0;\n            content.height = container.height;\n            content.width = container.width;\n        }\n        _align(content, alignCalc) {\n            content = Rect.toRect(content);\n            alignCalc(this.container, content);\n            return content;\n        }\n    }\n\n    class Queue {\n        constructor() {\n            this._tail = null;\n            this._head = null;\n            this.length = 0;\n        }\n        /**\n         * Enqueues an object to the end of the queue.\n         */\n        enqueue(value) {\n            const entry = { value: value, next: null };\n            if (!this._head) {\n                this._head = entry;\n                this._tail = this._head;\n            }\n            else {\n                this._tail.next = entry;\n                this._tail = this._tail.next;\n            }\n            this.length++;\n        }\n        /**\n         * Removes and returns the object at top of the queue.\n         */\n        dequeue() {\n            if (this.length < 1) {\n                throw new Error('The queue is empty.');\n            }\n            const value = this._head.value;\n            this._head = this._head.next;\n            this.length--;\n            return value;\n        }\n        contains(item) {\n            let current = this._head;\n            while (current) {\n                if (current.value === item) {\n                    return true;\n                }\n                current = current.next;\n            }\n            return false;\n        }\n    }\n\n    const OBJECT = 'object';\n    const UNDEFINED = 'undefined';\n    const isFunction = (obj) => typeof obj === 'function';\n    function deepExtendOne(destination, source) {\n        for (const property in source) {\n            if (property === '__proto__' || property === 'constructor') {\n                continue;\n            }\n            const propValue = source[property];\n            const propType = typeof propValue;\n            let propInit;\n            if (propType === OBJECT && propValue !== null) {\n                propInit = propValue.constructor;\n            }\n            else {\n                propInit = null;\n            }\n            if (propInit && propInit !== Array) {\n                if (propValue instanceof Date) {\n                    destination[property] = new Date(propValue.getTime());\n                }\n                else if (isFunction(propValue.clone)) {\n                    destination[property] = propValue.clone();\n                }\n                else {\n                    const destProp = destination[property];\n                    if (typeof (destProp) === OBJECT) {\n                        destination[property] = destProp || {};\n                    }\n                    else {\n                        destination[property] = {};\n                    }\n                    deepExtendOne(destination[property], propValue);\n                }\n            }\n            else if (propType !== UNDEFINED) {\n                destination[property] = propValue;\n            }\n        }\n        return destination;\n    }\n    function deepExtend(destination, ...sources) {\n        const length = sources.length;\n        for (let i = 0; i < length; i++) {\n            deepExtendOne(destination, sources[i]);\n        }\n        return destination;\n    }\n\n    const LayoutDefaultOptions = {\n        type: 'Tree',\n        subtype: 'Down',\n        roots: null,\n        animate: false,\n        // -------------------------------------------------------------------\n        /**\n         * Force-directed option: whether the motion of the nodes should be limited by the boundaries of the diagram surface.\n         */\n        limitToView: false,\n        /**\n         * Force-directed option: the amount of friction applied to the motion of the nodes.\n         */\n        friction: 0.9,\n        /**\n         * Force-directed option: the optimal distance between nodes (minimum energy).\n         */\n        nodeDistance: 50,\n        /**\n         * Force-directed option: the number of time things are being calculated.\n         */\n        iterations: 300,\n        // -------------------------------------------------------------------\n        /**\n         * Tree option: the separation in one direction (depends on the subtype what direction this is).\n         */\n        horizontalSeparation: 90,\n        /**\n         * Tree option: the separation in the complementary direction (depends on the subtype what direction this is).\n         */\n        verticalSeparation: 50,\n        // -------------------------------------------------------------------\n        /**\n         * Tip-over tree option: children-to-parent vertical distance.\n         */\n        underneathVerticalTopOffset: 15,\n        /**\n         * Tip-over tree option: children-to-parent horizontal distance.\n         */\n        underneathHorizontalOffset: 15,\n        /**\n         * Tip-over tree option: leaf-to-next-branch vertical distance.\n         */\n        underneathVerticalSeparation: 15,\n        // -------------------------------------------------------------------\n        /**\n         * Settings object to organize the different components of the diagram in a grid layout structure\n         */\n        grid: {\n            /**\n             * The width of the grid in which components are arranged. Beyond this width a component will be on the next row.\n             */\n            width: 1500,\n            /**\n             * The left offset of the grid.\n             */\n            offsetX: 50,\n            /**\n             * The top offset of the grid.\n             */\n            offsetY: 50,\n            /**\n             * The horizontal padding within a cell of the grid where a single component resides.\n             */\n            componentSpacingX: 20,\n            /**\n             * The vertical padding within a cell of the grid where a single component resides.\n             */\n            componentSpacingY: 20\n        },\n        // -------------------------------------------------------------------\n        /**\n         * Layered option: the separation height/width between the layers.\n         */\n        layerSeparation: 50,\n        /**\n         * Layered option: how many rounds of shifting and fine-tuning.\n         */\n        layeredIterations: 2,\n        /**\n         * Tree-radial option: the angle at which the layout starts.\n         */\n        startRadialAngle: 0,\n        /**\n         * Tree-radial option: the angle at which the layout starts.\n         */\n        endRadialAngle: 360,\n        /**\n         * Tree-radial option: the separation between levels.\n         */\n        radialSeparation: 150,\n        /**\n         * Tree-radial option: the separation between the root and the first level.\n         */\n        radialFirstLevelSeparation: 200,\n        /**\n         * Tree-radial option: whether a virtual roots bing the components in one radial layout.\n         */\n        keepComponentsInOneRadialLayout: false,\n        // -------------------------------------------------------------------\n        // TODO: ensure to change this to false when containers are around\n        ignoreContainers: true,\n        layoutContainerChildren: false,\n        ignoreInvisible: true,\n        animateTransitions: false\n    };\n    /**\n     * Base class for layout algorithms.\n     *\n     * @type {*}\n     */\n    class LayoutBase {\n        constructor() {\n            this.defaultOptions = { ...LayoutDefaultOptions, grid: { ...LayoutDefaultOptions.grid } };\n        }\n        /**\n         * Organizes the components in a grid.\n         * Returns the final set of nodes (not the Graph).\n         *\n         * @param components\n         */\n        gridLayoutComponents(components) {\n            if (!components) {\n                throw new Error('No components supplied.');\n            }\n            // calculate and cache the bounds of the components\n            forEach(components, function (c) {\n                c.calcBounds();\n            });\n            // order by decreasing width\n            components.sort(function (a, b) {\n                return b.bounds.width - a.bounds.width;\n            });\n            const maxWidth = this.options.grid.width, offsetX = this.options.grid.componentSpacingX, offsetY = this.options.grid.componentSpacingY, startX = this.options.grid.offsetX, startY = this.options.grid.offsetY, resultLinkSet = [], resultNodeSet = [];\n            let height = 0, x = startX, y = startY;\n            while (components.length > 0) {\n                if (x >= maxWidth) {\n                    // start a new row\n                    x = startX;\n                    y += height + offsetY;\n                    // reset the row height\n                    height = 0;\n                }\n                const component = components.pop();\n                this.moveToOffset(component, new Point(x, y));\n                for (let i = 0; i < component.nodes.length; i++) {\n                    resultNodeSet.push(component.nodes[i]); // to be returned in the end\n                }\n                for (let i = 0; i < component.links.length; i++) {\n                    resultLinkSet.push(component.links[i]);\n                }\n                const boundingRect = component.bounds;\n                let currentHeight = boundingRect.height;\n                if (currentHeight <= 0 || isNaN(currentHeight)) {\n                    currentHeight = 0;\n                }\n                let currentWidth = boundingRect.width;\n                if (currentWidth <= 0 || isNaN(currentWidth)) {\n                    currentWidth = 0;\n                }\n                if (currentHeight >= height) {\n                    height = currentHeight;\n                }\n                x += currentWidth + offsetX;\n            }\n            return {\n                nodes: resultNodeSet,\n                links: resultLinkSet\n            };\n        }\n        moveToOffset(component, p) {\n            let i, j;\n            const bounds = component.bounds, deltaX = p.x - bounds.x, deltaY = p.y - bounds.y;\n            for (i = 0; i < component.nodes.length; i++) {\n                const node = component.nodes[i];\n                let nodeBounds = node.bounds();\n                if (nodeBounds.width === 0 && nodeBounds.height === 0 && nodeBounds.x === 0 && nodeBounds.y === 0) {\n                    nodeBounds = new Rect(0, 0, 0, 0);\n                }\n                nodeBounds.x += deltaX;\n                nodeBounds.y += deltaY;\n                node.bounds(nodeBounds);\n            }\n            for (i = 0; i < component.links.length; i++) {\n                const link = component.links[i];\n                if (link.points) {\n                    const newPoints = [];\n                    const points = link.points;\n                    for (j = 0; j < points.length; j++) {\n                        const pt = points[j];\n                        pt.x += deltaX;\n                        pt.y += deltaY;\n                        newPoints.push(pt);\n                    }\n                    link.points = newPoints;\n                }\n            }\n            this.currentHorizontalOffset += bounds.width + this.options.grid.offsetX;\n            return new Point(deltaX, deltaY);\n        }\n        transferOptions(options) {\n            // Size options lead to stackoverflow and need special handling\n            this.options = deepExtend({}, this.defaultOptions);\n            if (isUndefined(options)) {\n                return;\n            }\n            this.options = deepExtend(this.options, options || {});\n        }\n    }\n\n    /**\n     * Captures the state of a diagram; node positions, link points and so on.\n     *\n     * @type {*}\n     */\n    class LayoutState {\n        constructor(diagram, graphOrNodes) {\n            if (isUndefined(diagram)) {\n                throw new Error('No diagram given');\n            }\n            this.diagram = diagram;\n            this.nodeMap = new Dictionary();\n            this.linkMap = new Dictionary();\n            this.capture(graphOrNodes ? graphOrNodes : diagram);\n        }\n        /**\n         * Will capture either\n         * - the state of the shapes and the intermediate points of the connections in the diagram\n         * - the bounds of the nodes contained in the Graph together with the intermediate points of the links in the Graph\n         * - the bounds of the nodes in the Array<Node>\n         * - the links points and node bounds in the literal object\n         *\n         * @param diagramOrGraphOrNodes\n         */\n        capture(diagramOrGraphOrNodes) {\n            let node, nodes, shape, i, conn, link, links;\n            if (diagramOrGraphOrNodes && diagramOrGraphOrNodes.type === 'Graph') {\n                for (i = 0; i < diagramOrGraphOrNodes.nodes.length; i++) {\n                    node = diagramOrGraphOrNodes.nodes[i];\n                    shape = node.associatedShape;\n                    // shape.bounds(new Rect(node.x, node.y, node.width, node.height));\n                    this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                }\n                for (i = 0; i < diagramOrGraphOrNodes.links.length; i++) {\n                    link = diagramOrGraphOrNodes.links[i];\n                    conn = link.associatedConnection;\n                    this.linkMap.set(conn.visual.id, link.points());\n                }\n            }\n            else if (diagramOrGraphOrNodes instanceof Array) {\n                nodes = diagramOrGraphOrNodes;\n                for (i = 0; i < nodes.length; i++) {\n                    node = nodes[i];\n                    shape = node.associatedShape;\n                    if (shape) {\n                        this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                    }\n                }\n            }\n            else if (Object.prototype.hasOwnProperty.call(diagramOrGraphOrNodes, 'links') && Object.prototype.hasOwnProperty.call(diagramOrGraphOrNodes, 'nodes')) {\n                nodes = diagramOrGraphOrNodes.nodes;\n                links = diagramOrGraphOrNodes.links;\n                for (i = 0; i < nodes.length; i++) {\n                    node = nodes[i];\n                    shape = node.associatedShape;\n                    if (shape) {\n                        this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                    }\n                }\n                for (i = 0; i < links.length; i++) {\n                    link = links[i];\n                    conn = link.associatedConnection;\n                    if (conn) {\n                        this.linkMap.set(conn.visual.id, link.points);\n                    }\n                }\n            }\n            else { // capture the diagram\n                const shapes = this.diagram.shapes;\n                const connections = this.diagram.connections;\n                for (i = 0; i < shapes.length; i++) {\n                    shape = shapes[i];\n                    this.nodeMap.set(shape.visual.id, shape.bounds());\n                }\n                for (i = 0; i < connections.length; i++) {\n                    conn = connections[i];\n                    this.linkMap.set(conn.visual.id, conn.points());\n                }\n            }\n        }\n    }\n\n    /**\n     * Defines the node (vertex) of a Graph.\n     */\n    let Node$1 = class Node {\n        constructor(id, shape) {\n            /**\n             * Holds all the links incident with the current node.\n             * Do not use this property to manage the incoming links, use the appropriate add/remove methods instead.\n             */\n            this.links = [];\n            /**\n             * Holds the links from the current one to another Node .\n             * Do not use this property to manage the incoming links, use the appropriate add/remove methods instead.\n             */\n            this.outgoing = [];\n            /**\n             * Holds the links from another Node to the current one.\n             * Do not use this property to manage the incoming links, use the appropriate add/remove methods instead.\n             */\n            this.incoming = [];\n            /**\n             * Holds the weight of this Node.\n             */\n            this.weight = 1;\n            /**\n             * The payload of the node.\n             *\n             * @type {null}\n             */\n            this.data = null;\n            this.type = 'Node';\n            /**\n             * Whether this is an injected node during the analysis or layout process.\n             *\n             * @type {boolean}\n             */\n            this.isVirtual = false;\n            if (isDefined(id)) {\n                this.id = id;\n            }\n            else {\n                this.id = randomId();\n            }\n            if (isDefined(shape)) {\n                this.associatedShape = shape;\n                // transfer the shape's bounds to the runtime props\n                const b = shape.bounds();\n                this.width = b.width;\n                this.height = b.height;\n                this.x = b.x;\n                this.y = b.y;\n            }\n            else {\n                this.associatedShape = null;\n            }\n            this.shortForm = 'Node \\'' + this.id + '\\'';\n        }\n        /**\n         * Returns whether this node has no links attached.\n         */\n        isIsolated() {\n            return isEmpty(this.links);\n        }\n        /**\n         * Gets or sets the bounding rectangle of this node.\n         * This should be considered as runtime data, the property is not hotlinked to a SVG item.\n         */\n        bounds(r) {\n            if (!isDefined(r)) {\n                return new Rect(this.x, this.y, this.width, this.height);\n            }\n            this.x = r.x;\n            this.y = r.y;\n            this.width = r.width;\n            this.height = r.height;\n        }\n        /**\n         * Returns whether there is at least one link with the given (complementary) node. This can be either an\n         * incoming or outgoing link.\n         */\n        isLinkedTo(node) {\n            return getAny(this.links, (link) => {\n                return link.getComplement(this) === node;\n            });\n        }\n        /**\n         * Gets the children of this node, defined as the adjacent nodes with a link from this node to the adjacent one.\n         *\n         * @returns {Array}\n         */\n        getChildren() {\n            if (this.outgoing.length === 0) {\n                return [];\n            }\n            const children = [];\n            for (let i = 0, len = this.outgoing.length; i < len; i++) {\n                const link = this.outgoing[i];\n                children.push(link.getComplement(this));\n            }\n            return children;\n        }\n        /**\n         * Gets the parents of this node, defined as the adjacent nodes with a link from the adjacent node to this one.\n         *\n         * @returns {Array}\n         */\n        getParents() {\n            if (this.incoming.length === 0) {\n                return [];\n            }\n            const parents = [];\n            for (let i = 0, len = this.incoming.length; i < len; i++) {\n                const link = this.incoming[i];\n                parents.push(link.getComplement(this));\n            }\n            return parents;\n        }\n        /**\n         * Returns a clone of the Node. Note that the identifier is not cloned since it's a different Node instance.\n         *\n         * @returns {Node}\n         */\n        clone() {\n            const copy = new Node();\n            if (isDefined(this.weight)) {\n                copy.weight = this.weight;\n            }\n            if (isDefined(this.balance)) {\n                copy.balance = this.balance;\n            }\n            if (isDefined(this.owner)) {\n                copy.owner = this.owner;\n            }\n            copy.associatedShape = this.associatedShape;\n            copy.x = this.x;\n            copy.y = this.y;\n            copy.width = this.width;\n            copy.height = this.height;\n            return copy;\n        }\n        /**\n         * Returns whether there is a link from the current node to the given node.\n         */\n        adjacentTo(node) {\n            return this.isLinkedTo(node) !== null;\n        }\n        /**\n         * Removes the given link from the link collection this node owns.\n         *\n         * @param link\n         */\n        removeLink(link) {\n            if (link.source === this) {\n                remove(this.links, link);\n                remove(this.outgoing, link);\n                link.source = null;\n            }\n            if (link.target === this) {\n                remove(this.links, link);\n                remove(this.incoming, link);\n                link.target = null;\n            }\n        }\n        /**\n         * Returns whether there is a (outgoing) link from the current node to the given one.\n         */\n        hasLinkTo(node) {\n            return getAny(this.outgoing, function (link) {\n                return link.target === node;\n            });\n        }\n        /**\n         * Returns the degree of this node, i.e. the sum of incoming and outgoing links.\n         */\n        degree() {\n            return this.links.length;\n        }\n        /**\n         * Returns whether this node is either the source or the target of the given link.\n         */\n        incidentWith(link) {\n            return contains(this.links, link);\n        }\n        /**\n         * Returns the links between this node and the given one.\n         */\n        getLinksWith(node) {\n            return all(this.links, function (link) {\n                return link.getComplement(this) === node;\n            }, this);\n        }\n        /**\n         * Returns the nodes (either parent or child) which are linked to the current one.\n         */\n        getNeighbors() {\n            const neighbors = [];\n            forEach(this.incoming, function (e) {\n                neighbors.push(e.getComplement(this));\n            }, this);\n            forEach(this.outgoing, function (e) {\n                neighbors.push(e.getComplement(this));\n            }, this);\n            return neighbors;\n        }\n    };\n    /**\n     * Defines a directed link (edge, connection) of a Graph.\n     */\n    class Link {\n        constructor(source, target, id, connection) {\n            if (isUndefined(source)) {\n                throw new Error('The source of the new link is not set.');\n            }\n            if (isUndefined(target)) {\n                throw new Error('The target of the new link is not set.');\n            }\n            let sourceFound, targetFound;\n            if (isString$1(source)) {\n                sourceFound = new Node$1(source);\n            }\n            else {\n                sourceFound = source;\n            }\n            if (isString$1(target)) {\n                targetFound = new Node$1(target);\n            }\n            else {\n                targetFound = target;\n            }\n            this.source = sourceFound;\n            this.target = targetFound;\n            this.source.links.push(this);\n            this.target.links.push(this);\n            this.source.outgoing.push(this);\n            this.target.incoming.push(this);\n            if (isDefined(id)) {\n                this.id = id;\n            }\n            else {\n                this.id = randomId();\n            }\n            if (isDefined(connection)) {\n                this.associatedConnection = connection;\n            }\n            else {\n                this.associatedConnection = null;\n            }\n            this.type = 'Link';\n            this.shortForm = 'Link \\'' + this.source.id + '->' + this.target.id + '\\'';\n        }\n        /**\n         * Returns the complementary node of the given one, if any.\n         */\n        getComplement(node) {\n            if (this.source !== node && this.target !== node) {\n                throw new Error('The given node is not incident with this link.');\n            }\n            return this.source === node ? this.target : this.source;\n        }\n        /**\n         * Returns the overlap of the current link with the given one, if any.\n         */\n        getCommonNode(link) {\n            if (this.source === link.source || this.source === link.target) {\n                return this.source;\n            }\n            if (this.target === link.source || this.target === link.target) {\n                return this.target;\n            }\n            return null;\n        }\n        /**\n         * Returns whether the current link is bridging the given nodes.\n         */\n        isBridging(v1, v2) {\n            return this.source === v1 && this.target === v2 || this.source === v2 && this.target === v1;\n        }\n        /**\n         * Returns the source and target of this link as a tuple.\n         */\n        getNodes() {\n            return [this.source, this.target];\n        }\n        /**\n         * Returns whether the given node is either the source or the target of the current link.\n         */\n        incidentWith(node) {\n            return this.source === node || this.target === node;\n        }\n        /**\n         * Returns whether the given link is a continuation of the current one. This can be both\n         * via an incoming or outgoing link.\n         */\n        adjacentTo(link) {\n            return contains(this.source.links, link) || contains(this.target.links, link);\n        }\n        /**\n         * Changes the source-node of this link.\n         */\n        changeSource(node) {\n            remove(this.source.links, this);\n            remove(this.source.outgoing, this);\n            node.links.push(this);\n            node.outgoing.push(this);\n            this.source = node;\n        }\n        /**\n         * Changes the target-node of this link.\n         *\n         * @param node\n         */\n        changeTarget(node) {\n            remove(this.target.links, this);\n            remove(this.target.incoming, this);\n            node.links.push(this);\n            node.incoming.push(this);\n            this.target = node;\n        }\n        /**\n         * Changes both the source and the target nodes of this link.\n         */\n        changesNodes(v, w) {\n            if (this.source === v) {\n                this.changeSource(w);\n            }\n            else if (this.target === v) {\n                this.changeTarget(w);\n            }\n        }\n        /**\n         * Reverses the direction of this link.\n         */\n        reverse() {\n            const oldSource = this.source;\n            const oldTarget = this.target;\n            this.source = oldTarget;\n            remove(oldSource.outgoing, this);\n            this.source.outgoing.push(this);\n            this.target = oldSource;\n            remove(oldTarget.incoming, this);\n            this.target.incoming.push(this);\n            return this;\n        }\n        /**\n         * Ensures that the given target defines the endpoint of this link.\n         */\n        directTo(target) {\n            if (this.source !== target && this.target !== target) {\n                throw new Error('The given node is not incident with this link.');\n            }\n            if (this.target !== target) {\n                this.reverse();\n            }\n        }\n        /**\n         * Returns a reversed clone of this link.\n         */\n        createReverseEdge() {\n            const r = this.clone();\n            r.reverse();\n            r.reversed = true;\n            return r;\n        }\n        /**\n         * Returns a clone of this link.\n         */\n        clone() {\n            const clone = new Link(this.source, this.target);\n            return clone;\n        }\n    }\n    /* --------------Graph structure---------------------------------*/\n    /**\n     * Defines a directed graph structure.\n     * Note that the incidence structure resides in the nodes through the incoming and outgoing links collection, rahter than\n     * inside the Graph.\n     */\n    class Graph {\n        constructor(idOrDiagram) {\n            /**\n             * The links or edge collection of this Graph.\n             *\n             * @type {Array}\n             */\n            this.links = [];\n            /**\n             * The node or vertex collection of this Graph.\n             *\n             * @type {Array}\n             */\n            this.nodes = [];\n            this._nodeMap = new Dictionary();\n            /**\n             * The optional reference to the Diagram on which this Graph is based.\n             *\n             * @type {null}\n             */\n            this.diagram = null;\n            /**\n             * The root of this Graph. If not set explicitly the first Node with zero incoming links will be taken.\n             *\n             * @type {null}\n             * @private\n             */\n            this._root = null;\n            /**\n             * The bounds of this graph if the nodes have spatial extension defined.\n             *\n             * @type {Rect}\n             */\n            this.bounds = new Rect();\n            // keeps track whether the children & parents have been created\n            this._hasCachedRelationships = false;\n            this.type = 'Graph';\n            this.componentIndex = 0;\n            if (isDefined(idOrDiagram)) {\n                if (isString$1(idOrDiagram)) {\n                    this.id = idOrDiagram;\n                }\n                else {\n                    this.diagram = idOrDiagram;\n                    this.id = idOrDiagram.id;\n                }\n            }\n            else {\n                this.id = randomId();\n            }\n        }\n        /**\n         * Caches the relational information of parents and children in the 'parents' and 'children'\n         * properties.\n         *\n         * @param forceRebuild If set to true the relational info will be rebuild even if already present.\n         */\n        cacheRelationships(forceRebuild) {\n            if (isUndefined(forceRebuild)) {\n                forceRebuild = false;\n            }\n            if (this._hasCachedRelationships && !forceRebuild) {\n                return;\n            }\n            for (let i = 0, len = this.nodes.length; i < len; i++) {\n                const node = this.nodes[i];\n                node.children = this.getChildren(node);\n                node.parents = this.getParents(node);\n            }\n            this._hasCachedRelationships = true;\n        }\n        /**\n         * Assigns tree-levels to the nodes assuming this is a tree graph.\n         * If not connected or not a tree the process will succeed but\n         * will have little meaning.\n         *\n         * @param startNode The node from where the level numbering starts, usually the root of the tree.\n         * @param visited The collection of visited nodes.\n         * @param offset The offset or starting counter of the level info.\n         */\n        assignLevels(startNode, offset, visited) {\n            if (!startNode) {\n                throw new Error('Start node not specified.');\n            }\n            if (isUndefined(offset)) {\n                offset = 0;\n            }\n            // if not done before, cache the parents and children\n            this.cacheRelationships();\n            if (isUndefined(visited)) {\n                visited = new Dictionary();\n                forEach(this.nodes, function (n) {\n                    visited.add(n, false);\n                });\n            }\n            visited.set(startNode, true);\n            startNode.level = offset;\n            const children = startNode.children;\n            for (let i = 0, len = children.length; i < len; i++) {\n                const child = children[i];\n                if (!child || visited.get(child)) {\n                    continue;\n                }\n                this.assignLevels(child, offset + 1, visited);\n            }\n        }\n        /**\n         * Gets or set the root of this graph.\n         * If not set explicitly the first Node with zero incoming links will be taken.\n         *\n         * @param value\n         * @returns {*}\n         */\n        root(value) {\n            if (isUndefined(value)) {\n                if (!this._root) {\n                    // TODO: better to use the longest path for the most probable root?\n                    const found = first(this.nodes, function (n) {\n                        return n.incoming.length === 0;\n                    });\n                    if (found) {\n                        return found;\n                    }\n                    return first(this.nodes);\n                }\n                else {\n                    return this._root;\n                }\n            }\n            else {\n                this._root = value;\n            }\n        }\n        /**\n         * Returns the connected components of this graph.\n         * Note that the returned graphs are made up of the nodes and links of this graph, i.e. a pointer to the items of this graph.\n         * If you alter the items of the components you'll alter the original graph and vice versa.\n         *\n         * @returns {Array}\n         */\n        getConnectedComponents() {\n            this.componentIndex = 0;\n            this.setItemIndices();\n            const componentId = initArray(this.nodes.length, -1);\n            for (let v = 0; v < this.nodes.length; v++) {\n                if (componentId[v] === -1) {\n                    this._collectConnectedNodes(componentId, v);\n                    this.componentIndex++;\n                }\n            }\n            const components = [];\n            let i;\n            for (i = 0; i < this.componentIndex; ++i) {\n                components[i] = new Graph();\n            }\n            for (i = 0; i < componentId.length; ++i) {\n                const graph = components[componentId[i]];\n                graph.addNodeAndOutgoings(this.nodes[i]);\n            }\n            // sorting the components in decreasing order of node count\n            components.sort(function (a, b) {\n                return b.nodes.length - a.nodes.length;\n            });\n            return components;\n        }\n        _collectConnectedNodes(setIds, nodeIndex) {\n            setIds[nodeIndex] = this.componentIndex; // part of the current component\n            const node = this.nodes[nodeIndex];\n            forEach(node.links, function (link) {\n                const next = link.getComplement(node);\n                const nextId = next.index;\n                if (setIds[nextId] === -1) {\n                    this._collectConnectedNodes(setIds, nextId);\n                }\n            }, this);\n        }\n        /**\n         * Calculates the bounds of this Graph if the Nodes have spatial dimensions defined.\n         *\n         * @returns {Rect}\n         */\n        calcBounds() {\n            if (this.isEmpty()) {\n                this.bounds = new Rect();\n                return this.bounds;\n            }\n            let b = null;\n            for (let i = 0, len = this.nodes.length; i < len; i++) {\n                const node = this.nodes[i];\n                if (!b) {\n                    b = node.bounds();\n                }\n                else {\n                    b = b.union(node.bounds());\n                }\n            }\n            this.bounds = b;\n            return this.bounds;\n        }\n        /**\n         * Creates a spanning tree for the current graph.\n         * Important: this will not return a spanning forest if the graph is disconnected.\n         * Prim's algorithm  finds a minimum-cost spanning tree of an edge-weighted, connected, undirected graph;\n         * see http://en.wikipedia.org/wiki/Prim%27s_algorithm .\n         *\n         * @param root The root of the spanning tree.\n         * @returns {Graph}\n         */\n        getSpanningTree(root) {\n            const tree = new Graph();\n            const map = new Dictionary();\n            let source, target;\n            const rootClone = root.clone();\n            tree.root(rootClone);\n            rootClone.level = 0;\n            rootClone.id = root.id;\n            map.add(root, tree.root());\n            root.level = 0;\n            const visited = [];\n            const remaining = [];\n            tree._addNode(tree.root());\n            visited.push(root);\n            remaining.push(root);\n            let levelCount = 1;\n            while (remaining.length > 0) {\n                const next = remaining.pop();\n                for (let ni = 0; ni < next.links.length; ni++) {\n                    const link = next.links[ni];\n                    const cn = link.getComplement(next);\n                    if (contains(visited, cn)) {\n                        continue;\n                    }\n                    cn.level = next.level + 1;\n                    if (levelCount < cn.level + 1) {\n                        levelCount = cn.level + 1;\n                    }\n                    if (!contains(remaining, cn)) {\n                        remaining.push(cn);\n                    }\n                    if (!contains(visited, cn)) {\n                        visited.push(cn);\n                    }\n                    if (map.containsKey(next)) {\n                        source = map.get(next);\n                    }\n                    else {\n                        source = next.clone();\n                        source.level = next.level;\n                        source.id = next.id;\n                        map.add(next, source);\n                    }\n                    if (map.containsKey(cn)) {\n                        target = map.get(cn);\n                    }\n                    else {\n                        target = cn.clone();\n                        target.level = cn.level;\n                        target.id = cn.id;\n                        map.add(cn, target);\n                    }\n                    const newLink = new Link(source, target);\n                    tree.addLink(newLink);\n                }\n            }\n            const treeLevels = [];\n            for (let i = 0; i < levelCount; i++) {\n                treeLevels.push([]);\n            }\n            forEach(tree.nodes, function (node) {\n                treeLevels[node.level].push(node);\n            });\n            tree.treeLevels = treeLevels;\n            tree.cacheRelationships();\n            return tree;\n        }\n        /**\n         * Returns a random node in this graph.\n         *\n         * @param excludedNodes The collection of nodes which should not be considered.\n         * @param incidenceLessThan The maximum degree or incidence the random node should have.\n         * @returns {*}\n         */\n        takeRandomNode(excludedNodes, incidenceLessThan) {\n            if (isUndefined(excludedNodes)) {\n                excludedNodes = [];\n            }\n            if (isUndefined(incidenceLessThan)) {\n                incidenceLessThan = 4;\n            }\n            if (this.nodes.length === 0) {\n                return null;\n            }\n            if (this.nodes.length === 1) {\n                return contains(excludedNodes, this.nodes[0]) ? null : this.nodes[0];\n            }\n            const pool = this.nodes.filter(function (node) {\n                return !contains(excludedNodes, node) && node.degree() <= incidenceLessThan;\n            });\n            if (isEmpty(pool)) {\n                return null;\n            }\n            return pool[randomInteger(0, pool.length)];\n        }\n        /**\n         * Returns whether this is an empty graph.\n         */\n        isEmpty() {\n            return isEmpty(this.nodes);\n        }\n        /**\n         * Checks whether the endpoints of the links are all in the nodes collection.\n         */\n        isHealthy() {\n            return all(this.links, function (link) {\n                return contains(this.nodes, link.source) && contains(this.nodes, link.target);\n            }, this);\n        }\n        /**\n         * Gets the parents of this node, defined as the adjacent nodes with a link from the adjacent node to this one.\n         *\n         * @returns {Array}\n         */\n        getParents(n) {\n            if (!this.hasNode(n)) {\n                throw new Error('The given node is not part of this graph.');\n            }\n            return n.getParents();\n        }\n        /**\n         * Gets the children of this node, defined as the adjacent nodes with a link from this node to the adjacent one.\n         *\n         * @returns {Array}\n         */\n        getChildren(n) {\n            if (!this.hasNode(n)) {\n                throw new Error('The given node is not part of this graph.');\n            }\n            return n.getChildren();\n        }\n        /**\n         * Adds a new link to the graph between the given nodes.\n         */\n        addLink(sourceOrLink, target, owner) {\n            if (isUndefined(sourceOrLink)) {\n                throw new Error('The source of the link is not defined.');\n            }\n            if (isUndefined(target)) {\n                // can only be undefined if the first one is a Link\n                if (isDefined(sourceOrLink.type) && sourceOrLink.type === 'Link') {\n                    this.addExistingLink(sourceOrLink);\n                    return;\n                }\n                else {\n                    throw new Error('The target of the link is not defined.');\n                }\n            }\n            let foundSource = this.getNode(sourceOrLink);\n            if (isUndefined(foundSource)) {\n                foundSource = this.addNode(sourceOrLink);\n            }\n            let foundTarget = this.getNode(target);\n            if (isUndefined(foundTarget)) {\n                foundTarget = this.addNode(target);\n            }\n            const newLink = new Link(foundSource, foundTarget);\n            if (isDefined(owner)) {\n                newLink.owner = owner;\n            }\n            /* newLink.source.outgoing.push(newLink);\n                newLink.source.links.push(newLink);\n                newLink.target.incoming.push(newLink);\n                newLink.target.links.push(newLink);*/\n            this.links.push(newLink);\n            return newLink;\n        }\n        /**\n         * Removes all the links in this graph.\n         */\n        removeAllLinks() {\n            while (this.links.length > 0) {\n                const link = this.links[0];\n                this.removeLink(link);\n            }\n        }\n        /**\n         * Adds the given link to the current graph.\n         */\n        addExistingLink(link) {\n            if (this.hasLink(link)) {\n                return;\n            }\n            this.links.push(link);\n            if (this.hasNode(link.source.id)) {\n                // priority to the existing node with the id even if other props are different\n                const s = this.getNode(link.source.id);\n                link.changeSource(s);\n            }\n            else {\n                this.addNode(link.source);\n            }\n            if (this.hasNode(link.target.id)) {\n                const t = this.getNode(link.target.id);\n                link.changeTarget(t);\n            }\n            else {\n                this.addNode(link.target);\n            }\n            /*  if (!link.source.outgoing.contains(link)) {\n                link.source.outgoing.push(link);\n                }\n                if (!link.source.links.contains(link)) {\n                link.source.links.push(link);\n                }\n                if (!link.target.incoming.contains(link)) {\n                link.target.incoming.push(link);\n                }\n                if (!link.target.links.contains(link)) {\n                link.target.links.push(link);\n                }*/\n        }\n        /**\n         * Returns whether the given identifier or Link is part of this graph.\n         *\n         * @param linkOrId An identifier or a Link object.\n         * @returns {*}\n         */\n        hasLink(linkOrId) {\n            if (isString$1(linkOrId)) {\n                return getAny(this.links, function (link) {\n                    return link.id === linkOrId;\n                });\n            }\n            if (linkOrId.type === 'Link') {\n                return contains(this.links, linkOrId);\n            }\n            throw new Error('The given object is neither an identifier nor a Link.');\n        }\n        /**\n         * Gets the node with the specified Id or null if not part of this graph.\n         */\n        getNode(nodeOrId) {\n            const id = nodeOrId.id || nodeOrId;\n            if (this._nodeMap.containsKey(id)) {\n                return this._nodeMap.get(id);\n            }\n        }\n        /**\n         * Returns whether the given node or node Id is part of this graph.\n         */\n        hasNode(nodeOrId) {\n            const id = nodeOrId.id || nodeOrId;\n            return this._nodeMap.containsKey(id);\n        }\n        _addNode(node) {\n            this.nodes.push(node);\n            this._nodeMap.add(node.id, node);\n        }\n        _removeNode(node) {\n            remove(this.nodes, node);\n            this._nodeMap.remove(node.id);\n        }\n        /**\n         * Removes the given node from this graph.\n         * The node can be specified as an object or as an identifier (string).\n         */\n        removeNode(nodeOrId) {\n            let n = nodeOrId;\n            if (isString$1(nodeOrId)) {\n                n = this.getNode(nodeOrId);\n            }\n            if (isDefined(n)) {\n                const links = n.links;\n                n.links = [];\n                for (let i = 0, len = links.length; i < len; i++) {\n                    const link = links[i];\n                    this.removeLink(link);\n                }\n                this._removeNode(n);\n            }\n            else {\n                throw new Error('The identifier should be a Node or the Id (string) of a node.');\n            }\n        }\n        /**\n         * Returns whether the given nodes are connected with a least one link independently of the direction.\n         */\n        areConnected(n1, n2) {\n            return getAny(this.links, function (link) {\n                return link.source === n1 && link.target === n2 || link.source === n2 && link.target === n1;\n            });\n        }\n        /**\n         * Removes the given link from this graph.\n         */\n        removeLink(link) {\n            /*    if (!this.links.contains(link)) {\n                throw \"The given link is not part of the Graph.\";\n                }\n                */\n            remove(this.links, link);\n            remove(link.source.outgoing, link);\n            remove(link.source.links, link);\n            remove(link.target.incoming, link);\n            remove(link.target.links, link);\n        }\n        /**\n         * Adds a new node to this graph, if not already present.\n         * The node can be an existing Node or the identifier of a new node.\n         * No error is thrown if the node is already there and the existing one is returned.\n         */\n        addNode(nodeOrId, layoutRect, owner) {\n            let newNode = null;\n            if (!isDefined(nodeOrId)) {\n                throw new Error('No Node or identifier for a new Node is given.');\n            }\n            if (isString$1(nodeOrId)) {\n                if (this.hasNode(nodeOrId)) {\n                    return this.getNode(nodeOrId);\n                }\n                newNode = new Node$1(nodeOrId);\n            }\n            else {\n                if (this.hasNode(nodeOrId)) {\n                    return this.getNode(nodeOrId);\n                }\n                // todo: ensure that the param is a Node?\n                newNode = nodeOrId;\n            }\n            if (isDefined(layoutRect)) {\n                newNode.bounds(layoutRect);\n            }\n            if (isDefined(owner)) {\n                newNode.owner = owner;\n            }\n            this._addNode(newNode);\n            return newNode;\n        }\n        /**\n         * Adds the given Node and its outgoing links.\n         */\n        addNodeAndOutgoings(node) {\n            if (!this.hasNode(node)) {\n                this._addNode(node);\n            }\n            const newLinks = node.outgoing;\n            node.outgoing = [];\n            forEach(newLinks, function (link) {\n                this.addExistingLink(link);\n            }, this);\n        }\n        /**\n         * Sets the 'index' property on the links and nodes of this graph.\n         */\n        setItemIndices() {\n            let i;\n            for (i = 0; i < this.nodes.length; ++i) {\n                this.nodes[i].index = i;\n            }\n            for (i = 0; i < this.links.length; ++i) {\n                this.links[i].index = i;\n            }\n        }\n        /**\n         * Returns a clone of this graph.\n         */\n        clone(saveMapping) {\n            const copy = new Graph();\n            const save = isDefined(saveMapping) && saveMapping === true;\n            if (save) {\n                copy.nodeMap = new Dictionary();\n                copy.linkMap = new Dictionary();\n            }\n            // we need a map even if the saveMapping is not set\n            const map = new Dictionary();\n            forEach(this.nodes, function (nOriginal) {\n                const nCopy = nOriginal.clone();\n                map.set(nOriginal, nCopy);\n                copy._addNode(nCopy);\n                if (save) {\n                    copy.nodeMap.set(nCopy, nOriginal);\n                }\n            });\n            forEach(this.links, function (linkOriginal) {\n                if (map.containsKey(linkOriginal.source) && map.containsKey(linkOriginal.target)) {\n                    const linkCopy = copy.addLink(map.get(linkOriginal.source), map.get(linkOriginal.target));\n                    if (save) {\n                        copy.linkMap.set(linkCopy, linkOriginal);\n                    }\n                }\n            });\n            return copy;\n        }\n        /**\n         * The parsing allows a quick way to create graphs.\n         *  - [\"n1->n2\", \"n2->n3\"]: creates the three nodes and adds the links\n         *  - [\"n1->n2\", {id: \"QSDF\"}, \"n2->n3\"]: same as previous but also performs a deep extend of the link between n1 and n2 with the given object.\n         */\n        linearize(addIds) {\n            return Graph.Utils.linearize(this, addIds);\n        }\n        /**\n         * Performs a depth-first traversal starting at the given node.\n         *\n         * @param startNode a node or id of a node in this graph\n         * @param action\n         */\n        depthFirstTraversal(startNode, action) {\n            if (isUndefined(startNode)) {\n                throw new Error('You need to supply a starting node.');\n            }\n            if (isUndefined(action)) {\n                throw new Error('You need to supply an action.');\n            }\n            if (!this.hasNode(startNode)) {\n                throw new Error('The given start-node is not part of this graph');\n            }\n            const foundNode = this.getNode(startNode); // case the given one is an Id\n            const visited = [];\n            this._dftIterator(foundNode, action, visited);\n        }\n        _dftIterator(node, action, visited) {\n            action(node);\n            visited.push(node);\n            const children = node.getChildren();\n            for (let i = 0, len = children.length; i < len; i++) {\n                const child = children[i];\n                if (contains(visited, child)) {\n                    continue;\n                }\n                this._dftIterator(child, action, visited);\n            }\n        }\n        /**\n         * Performs a breadth-first traversal starting at the given node.\n         *\n         * @param startNode a node or id of a node in this graph\n         * @param action\n         */\n        breadthFirstTraversal(startNode, action) {\n            if (isUndefined(startNode)) {\n                throw new Error('You need to supply a starting node.');\n            }\n            if (isUndefined(action)) {\n                throw new Error('You need to supply an action.');\n            }\n            if (!this.hasNode(startNode)) {\n                throw new Error('The given start-node is not part of this graph');\n            }\n            const foundNode = this.getNode(startNode); // case the given one is an Id\n            const queue = new Queue();\n            const visited = [];\n            queue.enqueue(foundNode);\n            while (queue.length > 0) {\n                const node = queue.dequeue();\n                action(node);\n                visited.push(node);\n                const children = node.getChildren();\n                for (let i = 0, len = children.length; i < len; i++) {\n                    const child = children[i];\n                    if (contains(visited, child) || queue.contains(child)) {\n                        continue;\n                    }\n                    queue.enqueue(child);\n                }\n            }\n        }\n        /**\n         * This is the classic Tarjan algorithm for strongly connected components.\n         * See e.g. http://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm\n         *\n         * @param excludeSingleItems Whether isolated nodes should be excluded from the analysis.\n         * @param node The start node from which the analysis starts.\n         * @param indices  Numbers the nodes consecutively in the order in which they are discovered.\n         * @param lowLinks The smallest index of any node known to be reachable from the node, including the node itself\n         * @param connected The current component.\n         * @param stack The bookkeeping stack of things to visit.\n         * @param index The counter of visited nodes used to assign the indices.\n         * @private\n         */\n        _stronglyConnectedComponents(excludeSingleItems, node, indices, lowLinks, connected, stack, index) {\n            indices.add(node, index);\n            lowLinks.add(node, index);\n            index++;\n            stack.push(node);\n            const children = node.getChildren();\n            let next;\n            for (let i = 0, len = children.length; i < len; i++) {\n                next = children[i];\n                if (!indices.containsKey(next)) {\n                    this._stronglyConnectedComponents(excludeSingleItems, next, indices, lowLinks, connected, stack, index);\n                    lowLinks.add(node, Math.min(lowLinks.get(node), lowLinks.get(next)));\n                }\n                else if (contains(stack, next)) {\n                    lowLinks.add(node, Math.min(lowLinks.get(node), indices.get(next)));\n                }\n            }\n            // If v is a root node, pop the stack and generate a strong component\n            if (lowLinks.get(node) === indices.get(node)) {\n                const component = [];\n                do {\n                    next = stack.pop();\n                    component.push(next);\n                } while (next !== node);\n                if (!excludeSingleItems || (component.length > 1)) {\n                    connected.push(component);\n                }\n            }\n        }\n        /**\n         * Returns the cycles found in this graph.\n         * The returned arrays consist of the nodes which are strongly coupled.\n         *\n         * @param excludeSingleItems Whether isolated nodes should be excluded.\n         * @returns {Array} The array of cycles found.\n         */\n        findCycles(excludeSingleItems) {\n            if (isUndefined(excludeSingleItems)) {\n                excludeSingleItems = true;\n            }\n            const indices = new Dictionary();\n            const lowLinks = new Dictionary();\n            const connected = [];\n            const stack = [];\n            for (let i = 0, len = this.nodes.length; i < len; i++) {\n                const node = this.nodes[i];\n                if (indices.containsKey(node)) {\n                    continue;\n                }\n                this._stronglyConnectedComponents(excludeSingleItems, node, indices, lowLinks, connected, stack, 0);\n            }\n            return connected;\n        }\n        /**\n         * Returns whether this graph is acyclic.\n         *\n         * @returns {*}\n         */\n        isAcyclic() {\n            return isEmpty(this.findCycles());\n        }\n        /**\n         * Returns whether the given graph is a subgraph of this one.\n         *\n         * @param other Another graph instance.\n         */\n        isSubGraph(other) {\n            const otherArray = other.linearize();\n            const thisArray = this.linearize();\n            return all(otherArray, function (s) {\n                return contains(thisArray, s);\n            });\n        }\n        /**\n         *  Makes an acyclic graph from the current (connected) one.\n         * * @returns {Array} The reversed links.\n         */\n        makeAcyclic() {\n            // if empty or almost empty\n            if (this.isEmpty() || this.nodes.length <= 1 || this.links.length <= 1) {\n                return [];\n            }\n            // singular case of just two nodes\n            if (this.nodes.length === 2) {\n                const result = [];\n                if (this.links.length > 1) {\n                    const oneLink = this.links[0];\n                    const oneNode = oneLink.source;\n                    for (let i = 0, len = this.links.length; i < len; i++) {\n                        const link = this.links[i];\n                        if (link.source === oneNode) {\n                            continue;\n                        }\n                        const rev = link.reverse();\n                        result.push(rev);\n                    }\n                }\n                return result;\n            }\n            const copy = this.clone(true); // copy.nodeMap tells you the mapping\n            const N = this.nodes.length;\n            const intensityCatalog = new Dictionary();\n            /**\n             * If there are both incoming and outgoing links this will return the flow intensity (out-in).\n             * Otherwise the node acts as a flow source with N specifying the (equal) intensity.\n             *\n             * @param node\n             * @returns {number}\n             */\n            const flowIntensity = function (node) {\n                if (node.outgoing.length === 0) {\n                    return (2 - N);\n                }\n                else if (node.incoming.length === 0) {\n                    return (N - 2);\n                }\n                else {\n                    return node.outgoing.length - node.incoming.length;\n                }\n            };\n            /**\n             * Collects the nodes with the same intensity.\n             *\n             * @param node\n             * @param intensityCatalog\n             */\n            const catalogEqualIntensity = function (node) {\n                const intensity = flowIntensity(node);\n                if (!intensityCatalog.containsKey(intensity)) {\n                    intensityCatalog.set(intensity, []);\n                }\n                intensityCatalog.get(intensity).push(node);\n            };\n            forEach(copy.nodes, function (v) {\n                catalogEqualIntensity(v);\n            });\n            let sourceStack = [];\n            const targetStack = [];\n            while (copy.nodes.length > 0) {\n                let source, target, intensity;\n                if (intensityCatalog.containsKey(2 - N)) {\n                    const targets = intensityCatalog.get(2 - N); // nodes without outgoings\n                    while (targets.length > 0) {\n                        target = targets.pop();\n                        for (let li = 0; li < target.links.length; li++) {\n                            const targetLink = target.links[li];\n                            source = targetLink.getComplement(target);\n                            intensity = flowIntensity(source);\n                            remove(intensityCatalog.get(intensity), source);\n                            source.removeLink(targetLink);\n                            catalogEqualIntensity(source);\n                        }\n                        copy._removeNode(target);\n                        targetStack.unshift(target);\n                    }\n                }\n                // move sources to sourceStack\n                if (intensityCatalog.containsKey(N - 2)) {\n                    const sources = intensityCatalog.get(N - 2); // nodes without incomings\n                    while (sources.length > 0) {\n                        source = sources.pop();\n                        for (let si = 0; si < source.links.length; si++) {\n                            const sourceLink = source.links[si];\n                            target = sourceLink.getComplement(source);\n                            intensity = flowIntensity(target);\n                            remove(intensityCatalog.get(intensity), target);\n                            target.removeLink(sourceLink);\n                            catalogEqualIntensity(target);\n                        }\n                        sourceStack.push(source);\n                        copy._removeNode(source);\n                    }\n                }\n                if (copy.nodes.length > 0) {\n                    for (let k = N - 3; k > 2 - N; k--) {\n                        if (intensityCatalog.containsKey(k) &&\n                            intensityCatalog.get(k).length > 0) {\n                            const maxdiff = intensityCatalog.get(k);\n                            const v = maxdiff.pop();\n                            for (let ri = 0; ri < v.links.length; ri++) {\n                                const ril = v.links[ri];\n                                const u = ril.getComplement(v);\n                                intensity = flowIntensity(u);\n                                remove(intensityCatalog.get(intensity), u);\n                                u.removeLink(ril);\n                                catalogEqualIntensity(u);\n                            }\n                            sourceStack.push(v);\n                            copy._removeNode(v);\n                            break;\n                        }\n                    }\n                }\n            }\n            sourceStack = sourceStack.concat(targetStack);\n            const vertexOrder = new Dictionary();\n            for (let kk = 0; kk < this.nodes.length; kk++) {\n                vertexOrder.set(copy.nodeMap.get(sourceStack[kk]), kk);\n            }\n            const reversedEdges = [];\n            forEach(this.links, function (link) {\n                if (vertexOrder.get(link.source) > vertexOrder.get(link.target)) {\n                    link.reverse();\n                    reversedEdges.push(link);\n                }\n            });\n            return reversedEdges;\n        }\n    }\n    /**\n     * A collection of predefined graphs for demo and testing purposes.\n     */\n    Graph.Predefined = {\n        /**\n         * Eight-shapes graph all connected in a cycle.\n         *\n         * @returns {*}\n         * @constructor\n         */\n        EightGraph() {\n            return Graph.Utils.parse(['1->2', '2->3', '3->4', '4->1', '3->5', '5->6', '6->7', '7->3']);\n        },\n        /**\n         * Creates a typical mindmap diagram.\n         *\n         * @returns {*}\n         * @constructor\n         */\n        Mindmap() {\n            return Graph.Utils.parse(['0->1', '0->2', '0->3', '0->4', '0->5', '1->6', '1->7', '7->8', '2->9', '9->10', '9->11', '3->12',\n                '12->13', '13->14', '4->15', '4->16', '15->17', '15->18', '18->19', '18->20', '14->21', '14->22', '5->23', '23->24', '23->25', '6->26']);\n        },\n        /**\n         * Three nodes connected in a cycle.\n         *\n         * @returns {*}\n         * @constructor\n         */\n        ThreeGraph() {\n            return Graph.Utils.parse(['1->2', '2->3', '3->1']);\n        },\n        /**\n         * A tree with each node having two children.\n         *\n         * @param levels How many levels the binary tree should have.\n         * @returns {diagram.Graph}\n         * @constructor\n         */\n        BinaryTree(levels) {\n            if (isUndefined(levels)) {\n                levels = 5;\n            }\n            return Graph.Utils.createBalancedTree(levels, 2);\n        },\n        /**\n         * A linear graph (discrete line segment).\n         *\n         * @param length How many segments (the node count is hence (length+1)).\n         * @returns {diagram.Graph}\n         * @constructor\n         */\n        Linear(length) {\n            if (isUndefined(length)) {\n                length = 10;\n            }\n            return Graph.Utils.createBalancedTree(length, 1);\n        },\n        /**\n         * A standard tree-graph with the specified levels and children (siblings) count.\n         * Note that for a balanced tree of level N and sibling count s, counting the root as level zero:\n         * - NodeCount = (1-s^(N+1))/(1-s)]\n         * - LinkCount = s.(1-s^N)/(1-s)\n         *\n         * @param levels How many levels the tree should have.\n         * @param siblingsCount How many siblings each level should have.\n         * @returns {diagram.Graph}\n         * @constructor\n         */\n        Tree(levels, siblingsCount) {\n            return Graph.Utils.createBalancedTree(levels, siblingsCount);\n        },\n        /**\n         * Creates a forest.\n         * Note that for a balanced forest of level N, sibling count s and tree count t, counting the root as level zero:\n         * - NodeCount = t.(1-s^(N+1))/(1-s)]\n         * - LinkCount = t.s.(1-s^N)/(1-s)\n         *\n         * @param levels How many levels the tree should have.\n         * @param siblingsCount How many siblings each level should have.\n         * @param trees The amount of trees the forest should have.\n         * @returns {diagram.Graph}\n         * @constructor\n         */\n        Forest(levels, siblingsCount, trees) {\n            return Graph.Utils.createBalancedForest(levels, siblingsCount, trees);\n        },\n        /**\n         * A workflow-like graph with cycles.\n         *\n         * @returns {*}\n         * @constructor\n         */\n        Workflow() {\n            return Graph.Utils.parse(['0->1', '1->2', '2->3', '1->4', '4->3', '3->5', '5->6', '6->3', '6->7', '5->4']);\n        },\n        /**\n         * A grid graph with the direction of the links avoiding cycles.\n         * Node count: (n+1).(m+1)\n         * Link count: n.(m+1) + m.(n+1)\n         *\n         * @param n Horizontal count of grid cells. If zero this will result in a linear graph.\n         * @param m Vertical count of grid cells. If zero this will result in a linear graph.\n         * @constructor\n         */\n        Grid(n, m) {\n            const g = new Graph();\n            if (n <= 0 && m <= 0) {\n                return g;\n            }\n            for (let i = 0; i < n + 1; i++) {\n                let previous = null;\n                for (let j = 0; j < m + 1; j++) {\n                    // using x-y coordinates to name the nodes\n                    const node = new Node$1(i.toString() + '.' + j.toString());\n                    g.addNode(node);\n                    if (previous) {\n                        g.addLink(previous, node);\n                    }\n                    if (i > 0) {\n                        const left = g.getNode((i - 1).toString() + '.' + j.toString());\n                        g.addLink(left, node);\n                    }\n                    previous = node;\n                }\n            }\n            return g;\n        }\n    };\n    /**\n     * Graph generation and other utilities.\n     */\n    Graph.Utils = {\n        /**\n         * The parsing allows a quick way to create graphs.\n         *  - [\"n1->n2\", \"n2->n3\"]: creates the three nodes and adds the links\n         *  - [\"n1->n2\", {id: \"id177\"}, \"n2->n3\"]: same as previous but also performs a deep extend of the link between n1 and n2 with the given object.\n         */\n        parse(graphString) {\n            let previousLink;\n            const graph = new Graph(), parts = graphString.slice();\n            for (let i = 0, len = parts.length; i < len; i++) {\n                const part = parts[i];\n                if (isString$1(part)) { // link spec\n                    if (part.indexOf('->') < 0) {\n                        throw new Error('The link should be specified as \\'a->b\\'.');\n                    }\n                    const p = part.split('->');\n                    if (p.length !== 2) {\n                        throw new Error('The link should be specified as \\'a->b\\'.');\n                    }\n                    previousLink = new Link(p[0], p[1]);\n                    graph.addLink(previousLink);\n                }\n                if (isObject(part)) {\n                    if (!previousLink) {\n                        throw new Error('Specification found before Link definition.');\n                    }\n                    deepExtend(previousLink, part);\n                }\n            }\n            return graph;\n        },\n        /**\n         * Returns a linearized representation of the given Graph.\n         * See also the Graph.Utils.parse method for the inverse operation.\n         */\n        linearize(graph, addIds) {\n            if (isUndefined(graph)) {\n                throw new Error('Expected an instance of a Graph object in slot one.');\n            }\n            if (isUndefined(addIds)) {\n                addIds = false;\n            }\n            const lin = [];\n            for (let i = 0, len = graph.links.length; i < len; i++) {\n                const link = graph.links[i];\n                lin.push(link.source.id + '->' + link.target.id);\n                if (addIds) {\n                    lin.push({ id: link.id });\n                }\n            }\n            return lin;\n        },\n        /**\n         * The method used by the diagram creation to instantiate a shape.\n         *\n         * @param kendoDiagram The Kendo diagram where the diagram will be created.\n         * @param p The position at which to place the shape.\n         * @param shapeDefaults Optional Shape options.\n         * @param id Optional identifier of the shape.\n         * @returns {*}\n         * @private\n         */\n        _addShape(kendoDiagram, p, id, shapeDefaults) {\n            if (isUndefined(p)) {\n                p = new Point(0, 0);\n            }\n            if (isUndefined(id)) {\n                id = randomId();\n            }\n            shapeDefaults = deepExtend({\n                width: 20,\n                height: 20,\n                id: id,\n                radius: 10,\n                fill: '#778899',\n                data: 'circle',\n                undoable: false,\n                x: p.x,\n                y: p.y\n            }, shapeDefaults);\n            return kendoDiagram.addShape(shapeDefaults);\n        },\n        /**\n         * The method used by the diagram creation to instantiate a connection.\n         *\n         * @param diagram he Kendo diagram where the diagram will be created.\n         * @param from The source shape.\n         * @param to The target shape.\n         * @param options Optional Connection options.\n         * @returns {*}\n         * @private\n         */\n        _addConnection(diagram, from, to, options) {\n            return diagram.connect(from, to, options);\n        },\n        /**\n         * Creates a diagram from the given Graph.\n         *\n         * @param diagram The Kendo diagram where the diagram will be created.\n         * @param graph The graph structure defining the diagram.\n         */\n        createDiagramFromGraph(diagram, graph, doLayout, randomSize) {\n            if (isUndefined(diagram)) {\n                throw new Error('The diagram surface is undefined.');\n            }\n            if (isUndefined(graph)) {\n                throw new Error('No graph specification defined.');\n            }\n            if (isUndefined(doLayout)) {\n                doLayout = true;\n            }\n            if (isUndefined(randomSize)) {\n                randomSize = false;\n            }\n            const width = diagram.element.clientWidth || 200;\n            const height = diagram.element.clientHeight || 200;\n            const map = [];\n            let node, shape;\n            for (let i = 0, len = graph.nodes.length; i < len; i++) {\n                node = graph.nodes[i];\n                let p = node.position;\n                if (isUndefined(p)) {\n                    if (isDefined(node.x) && isDefined(node.y)) {\n                        p = new Point(node.x, node.y);\n                    }\n                    else {\n                        p = new Point(randomInteger(10, width - 20), randomInteger(10, height - 20));\n                    }\n                }\n                const opt = {};\n                if (node.id === '0') {\n                    /* deepExtend(opt,\n                       {\n                       fill: \"Orange\",\n                       data: 'circle',\n                       width: 100,\n                       height: 100,\n                       center: new Point(50, 50)\n                       });*/\n                }\n                else if (randomSize) {\n                    deepExtend(opt, {\n                        width: Math.random() * 150 + 20,\n                        height: Math.random() * 80 + 50,\n                        data: 'rectangle',\n                        fill: {\n                            color: '#778899'\n                        }\n                    });\n                }\n                shape = this._addShape(diagram, p, node.id, opt);\n                // shape.content(node.id);\n                const bounds = shape.bounds();\n                if (isDefined(bounds)) {\n                    node.x = bounds.x;\n                    node.y = bounds.y;\n                    node.width = bounds.width;\n                    node.height = bounds.height;\n                }\n                map[node.id] = shape;\n            }\n            for (let gli = 0; gli < graph.links.length; gli++) {\n                const link = graph.links[gli];\n                const sourceShape = map[link.source.id];\n                if (isUndefined(sourceShape)) {\n                    continue;\n                }\n                const targetShape = map[link.target.id];\n                if (isUndefined(targetShape)) {\n                    continue;\n                }\n                this._addConnection(diagram, sourceShape, targetShape, { id: link.id });\n            }\n            if (doLayout) {\n                const l = new SpringLayout(diagram);\n                l.layoutGraph(graph, { limitToView: false });\n                for (let shi = 0; shi < graph.nodes.length; shi++) {\n                    node = graph.nodes[shi];\n                    shape = map[node.id];\n                    shape.bounds(new Rect(node.x, node.y, node.width, node.height));\n                }\n            }\n        },\n        /**\n         * Creates a balanced tree with the specified number of levels and siblings count.\n         * Note that for a balanced tree of level N and sibling count s, counting the root as level zero:\n         * - NodeCount = (1-s^(N+1))/(1-s)]\n         * - LinkCount = s.(1-s^N)/(1-s)\n         *\n         * @param levels How many levels the tree should have.\n         * @param siblingsCount How many siblings each level should have.\n         * @returns {diagram.Graph}\n         */\n        createBalancedTree(levels, siblingsCount) {\n            if (isUndefined(levels)) {\n                levels = 3;\n            }\n            if (isUndefined(siblingsCount)) {\n                siblingsCount = 3;\n            }\n            const g = new Graph();\n            let news, counter = -1, lastAdded = [];\n            if (levels <= 0 || siblingsCount <= 0) {\n                return g;\n            }\n            const root = new Node$1((++counter).toString());\n            g.addNode(root);\n            g.root(root);\n            lastAdded.push(root);\n            for (let i = 0; i < levels; i++) {\n                news = [];\n                for (let j = 0; j < lastAdded.length; j++) {\n                    const parent = lastAdded[j];\n                    for (let k = 0; k < siblingsCount; k++) {\n                        const item = new Node$1((++counter).toString());\n                        g.addLink(parent, item);\n                        news.push(item);\n                    }\n                }\n                lastAdded = news;\n            }\n            return g;\n        },\n        /**\n         * Creates a balanced tree with the specified number of levels and siblings count.\n         * Note that for a balanced forest of level N, sibling count s and tree count t, counting the root as level zero:\n         * - NodeCount = t.(1-s^(N+1))/(1-s)]\n         * - LinkCount = t.s.(1-s^N)/(1-s)\n         *\n         * @param levels How many levels the tree should have.\n         * @param siblingsCount How many siblings each level should have.\n         * @returns {diagram.Graph}\n         * @param treeCount The number of trees the forest should have.\n         */\n        createBalancedForest(levels, siblingsCount, treeCount) {\n            if (isUndefined(levels)) {\n                levels = 3;\n            }\n            if (isUndefined(siblingsCount)) {\n                siblingsCount = 3;\n            }\n            if (isUndefined(treeCount)) {\n                treeCount = 5;\n            }\n            const g = new Graph();\n            let counter = -1, lastAdded = [], news;\n            if (levels <= 0 || siblingsCount <= 0 || treeCount <= 0) {\n                return g;\n            }\n            for (let t = 0; t < treeCount; t++) {\n                const root = new Node$1((++counter).toString());\n                g.addNode(root);\n                lastAdded = [root];\n                for (let i = 0; i < levels; i++) {\n                    news = [];\n                    for (let j = 0; j < lastAdded.length; j++) {\n                        const parent = lastAdded[j];\n                        for (let k = 0; k < siblingsCount; k++) {\n                            const item = new Node$1((++counter).toString());\n                            g.addLink(parent, item);\n                            news.push(item);\n                        }\n                    }\n                    lastAdded = news;\n                }\n            }\n            return g;\n        },\n        /**\n         * Creates a random graph (uniform distribution) with the specified amount of nodes.\n         *\n         * @param nodeCount The amount of nodes the random graph should have.\n         * @param maxIncidence The maximum allowed degree of the nodes.\n         * @param isTree Whether the return graph should be a tree (default: false).\n         * @returns {diagram.Graph}\n         */\n        createRandomConnectedGraph(nodeCount, maxIncidence, isTree) {\n            /* Swa's Mathematica export of random Bernoulli graphs\n               gr[n_,p_]:=Module[{g=RandomGraph[BernoulliGraphDistribution[n,p],VertexLabels->\"Name\",DirectedEdges->True]},\n               While[Not[ConnectedGraphQ[g]],g=RandomGraph[BernoulliGraphDistribution[n,p],VertexLabels->\"Name\",DirectedEdges->True]];g];\n               project[a_]:=(\"\\\"\"<>ToString[Part[#,1]]<>\"->\"<>ToString[Part[#,2]]<>\"\\\"\")&     @ a;\n               export[g_]:=project/@ EdgeList[g]\n               g = gr[12,.1]\n               export [g]\n               */\n            if (isUndefined(nodeCount)) {\n                nodeCount = 40;\n            }\n            if (isUndefined(maxIncidence)) {\n                maxIncidence = 4;\n            }\n            if (isUndefined(isTree)) {\n                isTree = false;\n            }\n            const g = new Graph();\n            let counter = -1;\n            if (nodeCount <= 0) {\n                return g;\n            }\n            const root = new Node$1((++counter).toString());\n            g.addNode(root);\n            if (nodeCount === 1) {\n                return g;\n            }\n            if (nodeCount > 1) {\n                // random tree\n                for (let i = 1; i < nodeCount; i++) {\n                    const poolNode = g.takeRandomNode([], maxIncidence);\n                    if (!poolNode) {\n                        // failed to find one so the graph will have less nodes than specified\n                        break;\n                    }\n                    const newNode = g.addNode(i.toString());\n                    g.addLink(poolNode, newNode);\n                }\n                if (!isTree && nodeCount > 1) {\n                    const randomAdditions = randomInteger(1, nodeCount);\n                    for (let ri = 0; ri < randomAdditions; ri++) {\n                        const n1 = g.takeRandomNode([], maxIncidence);\n                        const n2 = g.takeRandomNode([], maxIncidence);\n                        if (n1 && n2 && !g.areConnected(n1, n2)) {\n                            g.addLink(n1, n2);\n                        }\n                    }\n                }\n                return g;\n            }\n        },\n        /**\n         * Generates a random diagram.\n         *\n         * @param diagram The host diagram.\n         * @param shapeCount The number of shapes the random diagram should contain.\n         * @param maxIncidence The maximum degree the shapes can have.\n         * @param isTree Whether the generated diagram should be a tree\n         * @param layoutType The optional layout type to apply after the diagram is generated.\n         */\n        randomDiagram(diagram, shapeCount, maxIncidence, isTree, randomSize) {\n            const g = Graph.Utils.createRandomConnectedGraph(shapeCount, maxIncidence, isTree);\n            Graph.Utils.createDiagramFromGraph(diagram, g, false, randomSize);\n        }\n    };\n    /**\n     * The classic spring-embedder (aka force-directed, Fruchterman-Rheingold, barycentric) algorithm.\n     * http://en.wikipedia.org/wiki/Force-directed_graph_drawing\n     * - Chapter 12 of Tamassia et al. \"Handbook of graph drawing and visualization\".\n     * - Kobourov on preprint arXiv; http://arxiv.org/pdf/1201.3011.pdf\n     * - Fruchterman and Rheingold in SOFTWARE-PRACTICE AND EXPERIENCE, VOL. 21(1 1), 1129-1164 (NOVEMBER 1991)\n     *\n     * @type {*}\n     */\n    class SpringLayout extends LayoutBase {\n        constructor(diagram) {\n            super();\n            if (isUndefined(diagram)) {\n                throw new Error('Diagram is not specified.');\n            }\n            this.diagram = diagram;\n        }\n        layout(options) {\n            this.transferOptions(options);\n            const adapter = new DiagramToHyperTreeAdapter(this.diagram);\n            const graph = adapter.convert(options);\n            if (graph.isEmpty()) {\n                return;\n            }\n            // split into connected components\n            const components = graph.getConnectedComponents();\n            if (isEmpty(components)) {\n                return;\n            }\n            for (let i = 0; i < components.length; i++) {\n                const component = components[i];\n                this.layoutGraph(component, options);\n            }\n            const finalNodeSet = this.gridLayoutComponents(components);\n            return new LayoutState(this.diagram, finalNodeSet);\n        }\n        layoutGraph(graph, options) {\n            if (isDefined(options)) {\n                this.transferOptions(options);\n            }\n            this.graph = graph;\n            const initialTemperature = this.options.nodeDistance * 9;\n            this.temperature = initialTemperature;\n            const guessBounds = this._expectedBounds();\n            this.width = guessBounds.width;\n            this.height = guessBounds.height;\n            for (let step = 0; step < this.options.iterations; step++) {\n                this.refineStage = step >= this.options.iterations * 5 / 6;\n                this.tick();\n                // exponential cooldown\n                this.temperature = this.refineStage ?\n                    initialTemperature / 30 :\n                    initialTemperature * (1 - step / (2 * this.options.iterations));\n            }\n        }\n        /**\n         * Single iteration of the simulation.\n         */\n        tick() {\n            let i;\n            // collect the repulsive forces on each node\n            for (i = 0; i < this.graph.nodes.length; i++) {\n                this._repulsion(this.graph.nodes[i]);\n            }\n            // collect the attractive forces on each node\n            for (i = 0; i < this.graph.links.length; i++) {\n                this._attraction(this.graph.links[i]);\n            }\n            // update the positions\n            for (i = 0; i < this.graph.nodes.length; i++) {\n                const node = this.graph.nodes[i];\n                const offset = Math.sqrt(node.dx * node.dx + node.dy * node.dy);\n                if (offset === 0) {\n                    return;\n                }\n                node.x += Math.min(offset, this.temperature) * node.dx / offset;\n                node.y += Math.min(offset, this.temperature) * node.dy / offset;\n                if (this.options.limitToView) {\n                    node.x = Math.min(this.width, Math.max(node.width / 2, node.x));\n                    node.y = Math.min(this.height, Math.max(node.height / 2, node.y));\n                }\n            }\n        }\n        /**\n         * Shakes the node away from its current position to escape the deadlock.\n         *\n         * @param node A Node.\n         * @private\n         */\n        _shake(node) {\n            // just a simple polar neighborhood\n            const rho = Math.random() * this.options.nodeDistance / 4;\n            const alpha = Math.random() * 2 * Math.PI;\n            node.x += rho * Math.cos(alpha);\n            node.y -= rho * Math.sin(alpha);\n        }\n        /**\n         * The typical Coulomb-Newton force law F=k/r^2\n         *\n         * @remark This only works in dimensions less than three.\n         * @param d\n         * @param n A Node.\n         * @param m Another Node.\n         * @returns {number}\n         * @private\n         */\n        _InverseSquareForce(d, n, m) {\n            let force;\n            if (!this.refineStage) {\n                force = Math.pow(d, 2) / Math.pow(this.options.nodeDistance, 2);\n            }\n            else {\n                const deltax = n.x - m.x;\n                const deltay = n.y - m.y;\n                const wn = n.width / 2;\n                const hn = n.height / 2;\n                const wm = m.width / 2;\n                const hm = m.height / 2;\n                force = (Math.pow(deltax, 2) / Math.pow(wn + wm + this.options.nodeDistance, 2)) + (Math.pow(deltay, 2) / Math.pow(hn + hm + this.options.nodeDistance, 2));\n            }\n            return force * 4 / 3;\n        }\n        /**\n         * The typical Hooke force law F=kr^2\n         *\n         * @param d\n         * @param n\n         * @param m\n         * @returns {number}\n         * @private\n         */\n        _SquareForce(d, n, m) {\n            return 1 / this._InverseSquareForce(d, n, m);\n        }\n        _repulsion(n) {\n            n.dx = 0;\n            n.dy = 0;\n            forEach(this.graph.nodes, function (m) {\n                if (m === n) {\n                    return;\n                }\n                while (n.x === m.x && n.y === m.y) {\n                    this._shake(m);\n                }\n                const vx = n.x - m.x;\n                const vy = n.y - m.y;\n                const distance = Math.sqrt(vx * vx + vy * vy);\n                const r = this._SquareForce(distance, n, m) * 2;\n                n.dx += (vx / distance) * r;\n                n.dy += (vy / distance) * r;\n            }, this);\n        }\n        _attraction(link) {\n            const t = link.target;\n            const s = link.source;\n            if (s === t) {\n                // loops induce endless shakes\n                return;\n            }\n            while (s.x === t.x && s.y === t.y) {\n                this._shake(t);\n            }\n            const vx = s.x - t.x;\n            const vy = s.y - t.y;\n            const distance = Math.sqrt(vx * vx + vy * vy);\n            const a = this._InverseSquareForce(distance, s, t) * 5;\n            const dx = (vx / distance) * a;\n            const dy = (vy / distance) * a;\n            t.dx += dx;\n            t.dy += dy;\n            s.dx -= dx;\n            s.dy -= dy;\n        }\n        /**\n         * Calculates the expected bounds after layout.\n         *\n         * @returns {*}\n         * @private\n         */\n        _expectedBounds() {\n            const N = this.graph.nodes.length, /* golden ration optimal?*/ ratio = 1.5, multiplier = 4;\n            if (N === 0) {\n                return;\n            }\n            const size = fold(this.graph.nodes, function (s, node) {\n                const area = node.width * node.height;\n                if (area > 0) {\n                    s += Math.sqrt(area);\n                    return s;\n                }\n                return 0;\n            }, 0, this);\n            const av = size / N;\n            const squareSize = av * Math.ceil(Math.sqrt(N));\n            const width = squareSize * Math.sqrt(ratio);\n            const height = squareSize / Math.sqrt(ratio);\n            return { width: width * multiplier, height: height * multiplier };\n        }\n    }\n    /**\n     * Adapter between the diagram control and the graph representation. It converts shape and connections to nodes and edges taking into the containers and their collapsef state,\n     * the visibility of items and more. If the layoutContainerChildren is true a hypertree is constructed which holds the hierarchy of containers and many conditions are analyzed\n     * to investigate how the effective graph structure looks like and how the layout has to be performed.\n     *\n     * @type {*}\n     */\n    class DiagramToHyperTreeAdapter {\n        constructor(diagram) {\n            /**\n             * The mapping to/from the original nodes.\n             *\n             * @type {Dictionary}\n             */\n            this.nodeMap = new Dictionary();\n            /**\n             * Gets the mapping of a shape to a container in case the shape sits in a collapsed container.\n             *\n             * @type {Dictionary}\n             */\n            this.shapeMap = new Dictionary();\n            /**\n             * The nodes being mapped.\n             *\n             * @type {Dictionary}\n             */\n            this.nodes = [];\n            /**\n             * The connections being mapped.\n             *\n             * @type {Dictionary}\n             */\n            this.edges = [];\n            // the mapping from an edge to all the connections it represents, this can be both because of multiple connections between\n            // two shapes or because a container holds multiple connections to another shape or container.\n            this.edgeMap = new Dictionary();\n            /**\n             * The resulting set of Nodes when the analysis has finished.\n             *\n             * @type {Array}\n             */\n            this.finalNodes = [];\n            /**\n             * The resulting set of Links when the analysis has finished.\n             *\n             * @type {Array}\n             */\n            this.finalLinks = [];\n            /**\n             * The items being omitted because of multigraph edges.\n             *\n             * @type {Array}\n             */\n            this.ignoredConnections = [];\n            /**\n             * The items being omitted because of containers, visibility and other factors.\n             *\n             * @type {Array}\n             */\n            this.ignoredShapes = [];\n            /**\n             * The map from a node to the partition/hypernode in which it sits. This hyperMap is null if 'options.layoutContainerChildren' is false.\n             *\n             * @type {Dictionary}\n             */\n            this.hyperMap = new Dictionary();\n            /**\n             * The hypertree contains the hierarchy defined by the containers.\n             * It's in essence a Graph of Graphs with a tree structure defined by the hierarchy of containers.\n             *\n             * @type {HyperTree}\n             */\n            this.hyperTree = new Graph();\n            /**\n             * The resulting graph after conversion. Note that this does not supply the information contained in the\n             * ignored connection and shape collections.\n             *\n             * @type {null}\n             */\n            this.finalGraph = null;\n            this.diagram = diagram;\n        }\n        /**\n         * The hyperTree is used when the 'options.layoutContainerChildren' is true. It contains the hierarchy of containers whereby each node is a ContainerGraph.\n         * This type of node has a Container reference to the container which holds the Graph items. There are three possible situations during the conversion process:\n         * - Ignore the containers: the container are non-existent and only normal shapes are mapped. If a shape has a connection to a container it will be ignored as well\n         * since there is no node mapped for the container.\n         * - Do not ignore the containers and leave the content of the containers untouched: the top-level elements are being mapped and the children within a container are not altered.\n         * - Do not ignore the containers and organize the content of the containers as well: the hypertree is constructed and there is a partitioning of all nodes and connections into the hypertree.\n         * The only reason a connection or node is not being mapped might be due to the visibility, which includes the visibility change through a collapsed parent container.\n         *\n         * @param options\n         */\n        convert(options) {\n            if (isUndefined(this.diagram)) {\n                throw new Error('No diagram to convert.');\n            }\n            this.options = deepExtend({\n                ignoreInvisible: true,\n                ignoreContainers: true,\n                layoutContainerChildren: false\n            }, options || {});\n            this.clear();\n            // create the nodes which participate effectively in the graph analysis\n            this._renormalizeShapes();\n            // recreate the incoming and outgoing collections of each and every node\n            this._renormalizeConnections();\n            // export the resulting graph\n            this.finalNodes = new Dictionary(this.nodes);\n            this.finalLinks = new Dictionary(this.edges);\n            this.finalGraph = new Graph();\n            this.finalNodes.forEach(function (n) {\n                this.finalGraph.addNode(n);\n            }, this);\n            this.finalLinks.forEach(function (l) {\n                this.finalGraph.addExistingLink(l);\n            }, this);\n            return this.finalGraph;\n        }\n        /**\n         * Maps the specified connection to an edge of the graph deduced from the given diagram.\n         *\n         * @param connection\n         * @returns {*}\n         */\n        mapConnection(connection) {\n            return this.edgeMap.get(connection.id);\n        }\n        /**\n         * Maps the specified shape to a node of the graph deduced from the given diagram.\n         *\n         * @param shape\n         * @returns {*}\n         */\n        mapShape(shape) {\n            return this.nodeMap.get(shape.id);\n        }\n        /**\n         * Gets the edge, if any, between the given nodes.\n         *\n         * @param a\n         * @param b\n         */\n        getEdge(a, b) {\n            return first(a.links, function (link) {\n                return link.getComplement(a) === b;\n            });\n        }\n        /**\n         * Clears all the collections used by the conversion process.\n         */\n        clear() {\n            this.finalGraph = null;\n            this.hyperTree = (!this.options.ignoreContainers && this.options.layoutContainerChildren) ? new Graph() : null;\n            this.hyperMap = (!this.options.ignoreContainers && this.options.layoutContainerChildren) ? new Dictionary() : null;\n            this.nodeMap = new Dictionary();\n            this.shapeMap = new Dictionary();\n            this.nodes = [];\n            this.edges = [];\n            this.edgeMap = new Dictionary();\n            this.ignoredConnections = [];\n            this.ignoredShapes = [];\n            this.finalNodes = [];\n            this.finalLinks = [];\n        }\n        /**\n         * The path from a given ContainerGraph to the root (container).\n         *\n         * @param containerGraph\n         * @returns {Array}\n         */\n        listToRoot(containerGraph) {\n            const list = [];\n            let s = containerGraph.container;\n            if (!s) {\n                return list;\n            }\n            list.push(s);\n            while (s.parentContainer) {\n                s = s.parentContainer;\n                list.push(s);\n            }\n            list.reverse();\n            return list;\n        }\n        firstNonIgnorableContainer(shape) {\n            if (shape.isContainer && !this.isIgnorableItem(shape)) {\n                return shape;\n            }\n            return !shape.parentContainer ? null : this.firstNonIgnorableContainer(shape.parentContainer);\n        }\n        isContainerConnection(a, b) {\n            if (a.isContainer && this.isDescendantOf(a, b)) {\n                return true;\n            }\n            return b.isContainer && this.isDescendantOf(b, a);\n        }\n        /**\n         * Returns true if the given shape is a direct child or a nested container child of the given container.\n         * If the given container and shape are the same this will return false since a shape cannot be its own child.\n         *\n         * @param scope\n         * @param a\n         * @returns {boolean}\n         */\n        isDescendantOf(scope, a) {\n            if (!scope.isContainer) {\n                throw new Error('Expecting a container.');\n            }\n            if (scope === a) {\n                return false;\n            }\n            if (contains(scope.children, a)) {\n                return true;\n            }\n            const containers = [];\n            for (let i = 0, len = scope.children.length; i < len; i++) {\n                const c = scope.children[i];\n                if (c.isContainer && this.isDescendantOf(c, a)) {\n                    containers.push(c);\n                }\n            }\n            return containers.length > 0;\n        }\n        isIgnorableItem(shape) {\n            if (this.options.ignoreInvisible) {\n                if (shape.isCollapsed && this._isVisible(shape)) {\n                    return false;\n                }\n                if (!shape.isCollapsed && this._isVisible(shape)) {\n                    return false;\n                }\n                return true;\n            }\n            else {\n                return shape.isCollapsed && !this._isTop(shape);\n            }\n        }\n        /**\n         *  Determines whether the shape is or needs to be mapped to another shape. This occurs essentially when the shape sits in\n         *  a collapsed container hierarchy and an external connection needs a node endpoint. This node then corresponds to the mapped shape and is\n         *  necessarily a container in the parent hierarchy of the shape.\n         *\n         * @param shape\n         */\n        isShapeMapped(shape) {\n            return shape.isCollapsed && !this._isVisible(shape) && !this._isTop(shape);\n        }\n        leastCommonAncestor(a, b) {\n            if (!a) {\n                throw new Error('Parameter should not be null.');\n            }\n            if (!b) {\n                throw new Error('Parameter should not be null.');\n            }\n            if (!this.hyperTree) {\n                throw new Error('No hypertree available.');\n            }\n            const al = this.listToRoot(a);\n            const bl = this.listToRoot(b);\n            let found = null;\n            if (isEmpty(al) || isEmpty(bl)) {\n                return this.hyperTree.root().data;\n            }\n            let xa = al[0];\n            let xb = bl[0];\n            let i = 0;\n            while (xa === xb) {\n                found = al[i];\n                i++;\n                if (i >= al.length || i >= bl.length) {\n                    break;\n                }\n                xa = al[i];\n                xb = bl[i];\n            }\n            if (!found) {\n                return this.hyperTree.root().data;\n            }\n            else {\n                return this.hyperTree.nodes.filter(function (n) {\n                    return n.data.container === found;\n                });\n            }\n        }\n        /**\n         * Determines whether the specified item is a top-level shape or container.\n         *\n         * @param item\n         * @returns {boolean}\n         * @private\n         */\n        _isTop(item) {\n            return !item.parentContainer;\n        }\n        /**\n         * Determines iteratively (by walking up the container stack) whether the specified shape is visible.\n         * This does NOT tell whether the item is not visible due to an explicit Visibility change or due to a collapse state.\n         *\n         * @param shape\n         * @returns {*}\n         * @private\n         */\n        _isVisible(shape) {\n            if (!shape.visible()) {\n                return false;\n            }\n            return !shape.parentContainer ? shape.visible() : this._isVisible(shape.parentContainer);\n        }\n        _isCollapsed(shape) {\n            if (shape.isContainer && shape.isCollapsed) {\n                return true;\n            }\n            return shape.parentContainer && this._isCollapsed(shape.parentContainer);\n        }\n        /**\n         * First part of the graph creation; analyzing the shapes and containers and deciding whether they should be mapped to a Node.\n         *\n         * @private\n         */\n        _renormalizeShapes() {\n            // add the nodes, the adjacency structure will be reconstructed later on\n            if (this.options.ignoreContainers) {\n                for (let i = 0, len = this.diagram.shapes.length; i < len; i++) {\n                    const shape = this.diagram.shapes[i];\n                    // if not visible (and ignoring the invisible ones) or a container we skip\n                    if ((this.options.ignoreInvisible && !this._isVisible(shape)) || shape.isContainer) {\n                        this.ignoredShapes.push(shape);\n                        continue;\n                    }\n                    const node = new Node$1(shape.id, shape);\n                    node.isVirtual = false;\n                    // the mapping will always contain singletons and the hyperTree will be null\n                    this.nodeMap.add(shape.id, node);\n                    this.nodes.push(node);\n                }\n            }\n            else {\n                throw new Error('Containers are not supported yet, but stay tuned.');\n            }\n        }\n        /**\n         * Second part of the graph creation; analyzing the connections and deciding whether they should be mapped to an edge.\n         *\n         * @private\n         */\n        _renormalizeConnections() {\n            if (this.diagram.connections.length === 0) {\n                return;\n            }\n            for (let i = 0, len = this.diagram.connections.length; i < len; i++) {\n                const conn = this.diagram.connections[i];\n                if (this.isIgnorableItem(conn)) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n                let source = !conn.sourceConnector ? null : conn.sourceConnector.shape;\n                let sink = !conn.targetConnector ? null : conn.targetConnector.shape;\n                // no layout for floating connections\n                if (!source || !sink) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n                if (contains(this.ignoredShapes, source) && !this.shapeMap.containsKey(source)) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n                if (contains(this.ignoredShapes, sink) && !this.shapeMap.containsKey(sink)) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n                // if the endpoint sits in a collapsed container we need the container rather than the shape itself\n                if (this.shapeMap.containsKey(source)) {\n                    source = this.shapeMap[source];\n                }\n                if (this.shapeMap.containsKey(sink)) {\n                    sink = this.shapeMap[sink];\n                }\n                const sourceNode = this.mapShape(source);\n                const sinkNode = this.mapShape(sink);\n                if ((sourceNode === sinkNode) || this.areConnectedAlready(sourceNode, sinkNode)) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n                if (sourceNode === null || sinkNode === null) {\n                    throw new Error('A shape was not mapped to a node.');\n                }\n                if (this.options.ignoreContainers) {\n                    // much like a floating connection here since at least one end is attached to a container\n                    if (sourceNode.isVirtual || sinkNode.isVirtual) {\n                        this.ignoredConnections.push(conn);\n                        continue;\n                    }\n                    const newEdge = new Link(sourceNode, sinkNode, conn.id, conn);\n                    this.edgeMap.add(conn.id, newEdge);\n                    this.edges.push(newEdge);\n                }\n                else {\n                    throw new Error('Containers are not supported yet, but stay tuned.');\n                }\n            }\n        }\n        areConnectedAlready(n, m) {\n            return getAny(this.edges, function (l) {\n                return l.source === n && l.target === m || l.source === m && l.target === n;\n            });\n        }\n    }\n\n    function intersectLine(start1, end1, start2, end2, isSegment) {\n        const tangensdiff = ((end1.x - start1.x) * (end2.y - start2.y)) - ((end1.y - start1.y) * (end2.x - start2.x));\n        if (isNearZero(tangensdiff)) {\n            // parallel lines\n            return;\n        }\n        const num1 = ((start1.y - start2.y) * (end2.x - start2.x)) - ((start1.x - start2.x) * (end2.y - start2.y));\n        const num2 = ((start1.y - start2.y) * (end1.x - start1.x)) - ((start1.x - start2.x) * (end1.y - start1.y));\n        const r = num1 / tangensdiff;\n        const s = num2 / tangensdiff;\n        if (isSegment && (r < 0 || r > 1 || s < 0 || s > 1)) {\n            // r < 0 => line 1 is below line 2\n            // r > 1 => line 1 is above line 2\n            // s < 0 => line 2 is below line 1\n            // s > 1 => line 2 is above line 1\n            return;\n        }\n        return new Point(start1.x + (r * (end1.x - start1.x)), start1.y + (r * (end1.y - start1.y)));\n    }\n    const Intersect = {\n        lines(start1, end1, start2, end2) {\n            return intersectLine(start1, end1, start2, end2);\n        },\n        segments(start1, end1, start2, end2) {\n            return intersectLine(start1, end1, start2, end2, true);\n        },\n        rectWithLine(rect, start, end) {\n            return Intersect.segments(start, end, rect.topLeft(), rect.topRight()) ||\n                Intersect.segments(start, end, rect.topRight(), rect.bottomRight()) ||\n                Intersect.segments(start, end, rect.bottomLeft(), rect.bottomRight()) ||\n                Intersect.segments(start, end, rect.topLeft(), rect.bottomLeft());\n        },\n        rects(rect1, rect2, angle) {\n            let tl = rect2.topLeft(), tr = rect2.topRight(), bl = rect2.bottomLeft(), br = rect2.bottomRight();\n            const center = rect2.center();\n            if (angle) {\n                tl = tl.rotate(angle, center);\n                tr = tr.rotate(angle, center);\n                bl = bl.rotate(angle, center);\n                br = br.rotate(angle, center);\n            }\n            let intersect = rect1.contains(tl) ||\n                rect1.contains(tr) ||\n                rect1.contains(bl) ||\n                rect1.contains(br) ||\n                Intersect.rectWithLine(rect1, tl, tr) ||\n                Intersect.rectWithLine(rect1, tl, bl) ||\n                Intersect.rectWithLine(rect1, tr, br) ||\n                Intersect.rectWithLine(rect1, bl, br);\n            if (!intersect) { // last possible case is rect1 to be completely within rect2\n                tl = rect1.topLeft();\n                tr = rect1.topRight();\n                bl = rect1.bottomLeft();\n                br = rect1.bottomRight();\n                if (angle) {\n                    const reverseAngle = 360 - angle;\n                    tl = tl.rotate(reverseAngle, center);\n                    tr = tr.rotate(reverseAngle, center);\n                    bl = bl.rotate(reverseAngle, center);\n                    br = br.rotate(reverseAngle, center);\n                }\n                intersect = rect2.contains(tl) ||\n                    rect2.contains(tr) ||\n                    rect2.contains(bl) ||\n                    rect2.contains(br);\n            }\n            return intersect;\n        }\n    };\n\n    const map = (arr, func) => arr.map(func);\n    /**\n     * SVG transformation represented as a vector.\n     */\n    class MatrixVector {\n        constructor(a, b, c, d, e, f) {\n            this.a = a || 0;\n            this.b = b || 0;\n            this.c = c || 0;\n            this.d = d || 0;\n            this.e = e || 0;\n            this.f = f || 0;\n        }\n        fromMatrix(m) {\n            const v = new MatrixVector();\n            v.a = m.a;\n            v.b = m.b;\n            v.c = m.c;\n            v.d = m.d;\n            v.e = m.e;\n            v.f = m.f;\n            return v;\n        }\n    }\n    /**\n     * SVG transformation matrix.\n     */\n    class Matrix {\n        constructor(a, b, c, d, e, f) {\n            this.a = a || 0;\n            this.b = b || 0;\n            this.c = c || 0;\n            this.d = d || 0;\n            this.e = e || 0;\n            this.f = f || 0;\n        }\n        plus(m) {\n            this.a += m.a;\n            this.b += m.b;\n            this.c += m.c;\n            this.d += m.d;\n            this.e += m.e;\n            this.f += m.f;\n        }\n        minus(m) {\n            this.a -= m.a;\n            this.b -= m.b;\n            this.c -= m.c;\n            this.d -= m.d;\n            this.e -= m.e;\n            this.f -= m.f;\n        }\n        times(m) {\n            return new Matrix(this.a * m.a + this.c * m.b, this.b * m.a + this.d * m.b, this.a * m.c + this.c * m.d, this.b * m.c + this.d * m.d, this.a * m.e + this.c * m.f + this.e, this.b * m.e + this.d * m.f + this.f);\n        }\n        apply(p) {\n            return new Point(this.a * p.x + this.c * p.y + this.e, this.b * p.x + this.d * p.y + this.f);\n        }\n        applyRect(r) {\n            return Rect.fromPoints(this.apply(r.topLeft()), this.apply(r.bottomRight()));\n        }\n        toString() {\n            return 'matrix(' + this.a + ' ' + this.b + ' ' + this.c + ' ' + this.d + ' ' + this.e + ' ' + this.f + ')';\n        }\n        static fromSVGMatrix(vm) {\n            const m = new Matrix();\n            m.a = vm.a;\n            m.b = vm.b;\n            m.c = vm.c;\n            m.d = vm.d;\n            m.e = vm.e;\n            m.f = vm.f;\n            return m;\n        }\n        static fromMatrixVector(v) {\n            const m = new Matrix();\n            m.a = v.a;\n            m.b = v.b;\n            m.c = v.c;\n            m.d = v.d;\n            m.e = v.e;\n            m.f = v.f;\n            return m;\n        }\n        static fromList(v) {\n            if (v.length !== 6) {\n                throw new Error('The given list should consist of six elements.');\n            }\n            const m = new Matrix();\n            m.a = v[0];\n            m.b = v[1];\n            m.c = v[2];\n            m.d = v[3];\n            m.e = v[4];\n            m.f = v[5];\n            return m;\n        }\n        static translation(x, y) {\n            const m = new Matrix();\n            m.a = 1;\n            m.b = 0;\n            m.c = 0;\n            m.d = 1;\n            m.e = x;\n            m.f = y;\n            return m;\n        }\n        static unit() {\n            return new Matrix(1, 0, 0, 1, 0, 0);\n        }\n        static rotation(angle, x, y) {\n            const m = new Matrix();\n            m.a = Math.cos(angle * Math.PI / 180);\n            m.b = Math.sin(angle * Math.PI / 180);\n            m.c = -m.b;\n            m.d = m.a;\n            m.e = (x - x * m.a + y * m.b) || 0;\n            m.f = (y - y * m.a - x * m.b) || 0;\n            return m;\n        }\n        static scaling(scaleX, scaleY) {\n            const m = new Matrix();\n            m.a = scaleX;\n            m.b = 0;\n            m.c = 0;\n            m.d = scaleY;\n            m.e = 0;\n            m.f = 0;\n            return m;\n        }\n        static parse(v) {\n            let parts, nums;\n            if (v) {\n                v = v.trim();\n                // of the form \"matrix(...)\"\n                if (v.slice(0, 6).toLowerCase() === 'matrix') {\n                    nums = v.slice(7, v.length - 1).trim();\n                    parts = nums.split(',');\n                    if (parts.length === 6) {\n                        return Matrix.fromList(map(parts, function (p) {\n                            return parseFloat(p);\n                        }));\n                    }\n                    parts = nums.split(' ');\n                    if (parts.length === 6) {\n                        return Matrix.fromList(map(parts, function (p) {\n                            return parseFloat(p);\n                        }));\n                    }\n                }\n                // of the form \"(...)\"\n                if (v.slice(0, 1) === '(' && v.slice(v.length - 1) === ')') {\n                    v = v.substr(1, v.length - 1);\n                }\n                if (v.indexOf(',') > 0) {\n                    parts = v.split(',');\n                    if (parts.length === 6) {\n                        return Matrix.fromList(map(parts, function (p) {\n                            return parseFloat(p);\n                        }));\n                    }\n                }\n                if (v.indexOf(' ') > 0) {\n                    parts = v.split(' ');\n                    if (parts.length === 6) {\n                        return Matrix.fromList(map(parts, function (p) {\n                            return parseFloat(p);\n                        }));\n                    }\n                }\n            }\n            return parts;\n        }\n    }\n\n    /**\n     * Returns a value with Gaussian (normal) distribution.\n     *\n     * @param mean The mean value of the distribution.\n     * @param deviation The deviation (spreading at half-height) of the distribution.\n     * @returns {number}\n     */\n    function normalVariable(mean, deviation) {\n        let x, y, r;\n        do {\n            x = Math.random() * 2 - 1;\n            y = Math.random() * 2 - 1;\n            r = x * x + y * y;\n        } while (!r || r > 1);\n        return mean + deviation * x * Math.sqrt(-2 * Math.log(r) / r);\n    }\n\n    /**\n     * Structure combining a Point with two additional points representing the handles or tangents attached to the first point.\n     * If the additional points are null or equal to the first point the path will be sharp.\n     * Left and right correspond to the direction of the underlying path.\n     */\n    class PathDefiner {\n        constructor(p, left, right) {\n            this.point = p;\n            this.left = left;\n            this.right = right;\n        }\n    }\n\n    /**\n     * While other data structures can have multiple times the same item a Set owns only\n     * once a particular item.\n     *\n     * @type {*}\n     */\n    let Set$1 = class Set extends Observable {\n        constructor(resource) {\n            super();\n            this._hashTable = new HashTable();\n            this.length = 0;\n            if (isDefined(resource)) {\n                if (resource instanceof HashTable) {\n                    resource.forEach(function (d) {\n                        this.add(d);\n                    });\n                }\n                else if (resource instanceof Dictionary) {\n                    resource.forEach(function (k, v) {\n                        this.add({ key: k, value: v });\n                    }, this);\n                }\n            }\n        }\n        contains(item) {\n            return this._hashTable.containsKey(item);\n        }\n        add(item) {\n            const entry = this._hashTable.get(item);\n            if (!entry) {\n                this._hashTable.add(item, item);\n                this.length++;\n                this.trigger('changed');\n            }\n        }\n        get(item) {\n            if (this.contains(item)) {\n                return this._hashTable.get(item).value;\n            }\n            else {\n                return null;\n            }\n        }\n        /**\n         * Returns the hash of the item.\n         *\n         * @param item\n         * @returns {*}\n         */\n        hash(item) {\n            return this._hashTable._hash(item);\n        }\n        /**\n         * Removes the given item from the set. No exception is thrown if the item is not in the Set.\n         *\n         * @param item\n         */\n        remove(item) {\n            if (this.contains(item)) {\n                this._hashTable.remove(item);\n                this.length--;\n                this.trigger('changed');\n            }\n        }\n        /**\n         * Foreach with an iterator working on the key-value pairs.\n         *\n         * @param func\n         */\n        forEach(func, context) {\n            const call = context ? func.bind(context) : func;\n            this._hashTable.forEach(function (kv) {\n                call(kv.value);\n            });\n        }\n        toArray() {\n            const r = [];\n            this.forEach(function (d) {\n                r.push(d);\n            });\n            return r;\n        }\n    };\n\n    class Size {\n        constructor(width, height) {\n            this.width = width;\n            this.height = height;\n        }\n        static Empty() {\n            return new Size(0, 0);\n        }\n    }\n\n    class Rotation {\n        constructor(angle, x, y) {\n            this.x = x || 0;\n            this.y = y || 0;\n            this.angle = angle;\n        }\n        toString() {\n            if (this.x && this.y) {\n                return `rotate(${this.angle},${this.x},${this.y})`;\n            }\n            else {\n                return `rotate(${this.angle})`;\n            }\n        }\n        toMatrix() {\n            return Matrix.rotation(this.angle, this.x, this.y); // T*R*T^-1\n        }\n        center() {\n            return new Point(this.x, this.y);\n        }\n        invert() {\n            return new Rotation(FULL_CIRCLE_ANGLE - this.angle, this.x, this.y);\n        }\n        static create(rotation) {\n            return new Rotation(rotation.angle, rotation.x, rotation.y);\n        }\n        static parse(str) {\n            const values = str.slice(1, str.length - 1).split(',');\n            const angle = parseFloat(values[0]);\n            const x = parseFloat(values[1]);\n            const y = parseFloat(values[2]);\n            return new Rotation(angle, x, y);\n        }\n    }\n    Rotation.ZERO = new Rotation(0);\n\n    class Scale {\n        constructor(x, y) {\n            this.x = x;\n            this.y = y;\n        }\n        toMatrix() {\n            return Matrix.scaling(this.x, this.y);\n        }\n        toString() {\n            return `scale(${this.x},${this.y})`;\n        }\n        invert() {\n            return new Scale(1 / this.x, 1 / this.y);\n        }\n    }\n    ;\n\n    class Translation {\n        constructor(x, y) {\n            this.x = x;\n            this.y = y;\n        }\n        toMatrixVector() {\n            return new MatrixVector(0, 0, 0, 0, this.x, this.y);\n        }\n        toMatrix() {\n            return Matrix.translation(this.x, this.y);\n        }\n        toString() {\n            return `translate(${this.x},${this.y})`;\n        }\n        plus(delta) {\n            this.x += delta.x;\n            this.y += delta.y;\n        }\n        times(factor) {\n            this.x *= factor;\n            this.y *= factor;\n        }\n        length() {\n            return Math.sqrt(this.x * this.x + this.y * this.y);\n        }\n        normalize() {\n            if (this.Length === 0) {\n                return;\n            }\n            this.times(1 / this.length());\n        }\n        invert() {\n            return new Translation(-this.x, -this.y);\n        }\n    }\n\n    class CompositeTransform {\n        constructor(x, y, scaleX, scaleY, angle, center) {\n            this.translate = new Translation(x, y);\n            if (scaleX !== undefined && scaleY !== undefined) {\n                this.scale = new Scale(scaleX, scaleY);\n            }\n            if (angle !== undefined) {\n                this.rotate = center ? new Rotation(angle, center.x, center.y) : new Rotation(angle);\n            }\n        }\n        toString() {\n            const toString = function (transform) {\n                return transform ? transform.toString() : '';\n            };\n            return toString(this.translate) +\n                toString(this.rotate) +\n                toString(this.scale);\n        }\n        render(visual) {\n            visual._transform = this;\n            visual._renderTransform();\n        }\n        toMatrix() {\n            let m = Matrix.unit();\n            if (this.translate) {\n                m = m.times(this.translate.toMatrix());\n            }\n            if (this.rotate) {\n                m = m.times(this.rotate.toMatrix());\n            }\n            if (this.scale) {\n                m = m.times(this.scale.toMatrix());\n            }\n            return m;\n        }\n        invert() {\n            const rotate = this.rotate ? this.rotate.invert() : undefined, rotateMatrix = rotate ? rotate.toMatrix() : Matrix.unit(), scale = this.scale ? this.scale.invert() : undefined, scaleMatrix = scale ? scale.toMatrix() : Matrix.unit();\n            let translatePoint = new Point(-this.translate.x, -this.translate.y);\n            translatePoint = rotateMatrix.times(scaleMatrix).apply(translatePoint);\n            const translate = new Translation(translatePoint.x, translatePoint.y);\n            const transform = new CompositeTransform();\n            transform.translate = translate;\n            transform.rotate = rotate;\n            transform.scale = scale;\n            return transform;\n        }\n    }\n\n    function diffNumericOptions(options, fields) {\n        const elementOptions = this.options;\n        let hasChanges = false;\n        let value, field;\n        for (let i = 0; i < fields.length; i++) {\n            field = fields[i];\n            value = options[field];\n            if (isNumber(value) && elementOptions[field] !== value) {\n                elementOptions[field] = value;\n                hasChanges = true;\n            }\n        }\n        return hasChanges;\n    }\n\n    class Element {\n        constructor(options) {\n            this.options = deepExtend({}, this.options, options);\n            this.id = this.options.id;\n            this._originSize = Rect.empty();\n            this._transform = new CompositeTransform();\n        }\n        visible(value) {\n            return this.drawingContainer().visible(value);\n        }\n        redraw(options) {\n            if (options && options.id) {\n                this.id = options.id;\n            }\n        }\n        position(x, y) {\n            const options = this.options;\n            if (!defined(x)) {\n                return new Point(options.x, options.y);\n            }\n            if (defined(y)) {\n                options.x = x;\n                options.y = y;\n            }\n            else if (x instanceof Point) {\n                options.x = x.x;\n                options.y = x.y;\n            }\n            this._transform.translate = new Translation(options.x, options.y);\n            this._renderTransform();\n        }\n        rotate(angle, center) {\n            if (defined(angle)) {\n                this._transform.rotate = new Rotation(angle, center.x, center.y);\n                this._renderTransform();\n            }\n            return this._transform.rotate || Rotation.ZERO;\n        }\n        drawingContainer() {\n            return this.drawingElement;\n        }\n        _renderTransform() {\n            const matrix = this._transform.toMatrix();\n            this.drawingContainer().transform(new kendo_drawing_cmn_chunk_js.M(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f));\n        }\n        _hover() { }\n        _diffNumericOptions(options, fields) {\n            return diffNumericOptions.call(this, options, fields);\n        }\n        _measure(force) {\n            let rect;\n            if (!this._measured || force) {\n                const box = this._boundingBox() || new kendo_drawing_cmn_chunk_js.R([0, 0], [0, 0]);\n                const startPoint = box.topLeft();\n                rect = new Rect(startPoint.x, startPoint.y, box.width(), box.height());\n                this._originSize = rect;\n                this._originWidth = rect.width;\n                this._originHeight = rect.height;\n                this._measured = true;\n            }\n            else {\n                rect = this._originSize;\n            }\n            return rect;\n        }\n        _boundingBox() {\n            return this.drawingElement.rawBBox();\n        }\n    }\n\n    function sizeOptionsOrDefault(options) {\n        return {\n            x: options.x || 0,\n            y: options.y || 0,\n            width: options.width || 0,\n            height: options.height || 0\n        };\n    }\n    function normalizeDrawingOptions(options) {\n        if (options) {\n            let drawingOptions = options;\n            if (isString$1(drawingOptions)) {\n                drawingOptions = {\n                    color: drawingOptions\n                };\n            }\n            if (drawingOptions.color) {\n                drawingOptions.color = getColor(drawingOptions.color);\n            }\n            return drawingOptions;\n        }\n    }\n    function getColor(value) {\n        let color;\n        if (value !== TRANSPARENT) {\n            color = new kendo_drawing_cmn_chunk_js.C(value).toHex();\n        }\n        else {\n            color = value;\n        }\n        return color;\n    }\n    function lineAngle(p1, p2) {\n        const xDiff = p2.x - p1.x;\n        const yDiff = p2.y - p1.y;\n        const angle = kendo_drawing_cmn_chunk_js.v(Math.atan2(yDiff, xDiff));\n        return angle;\n    }\n    function createSegment(x, y) {\n        return new kendo_drawing_cmn_chunk_js.S(new kendo_drawing_cmn_chunk_js.P(x, y));\n    }\n    function toDrawingRect(rect) {\n        if (rect) {\n            return new kendo_drawing_cmn_chunk_js.R([rect.x, rect.y], [rect.width, rect.height]);\n        }\n    }\n    function removeChildren$1(element) {\n        while (element.firstChild) {\n            element.removeChild(element.firstChild);\n        }\n    }\n\n    const defaultOptions$a = {\n        stroke: {\n            color: 'gray',\n            width: 1\n        },\n        fill: {\n            color: TRANSPARENT\n        }\n    };\n    class VisualBase extends Element {\n        constructor(options) {\n            options = deepExtend({}, defaultOptions$a, options);\n            super(options);\n            options = this.options;\n            options.fill = normalizeDrawingOptions(options.fill);\n            options.stroke = normalizeDrawingOptions(options.stroke);\n        }\n        fill(color, opacity) {\n            this._fill({\n                color: getColor(color),\n                opacity: opacity\n            });\n        }\n        stroke(color, width, opacity) {\n            this._stroke({\n                color: getColor(color),\n                width: width,\n                opacity: opacity\n            });\n        }\n        redraw(options) {\n            if (options) {\n                const stroke = options.stroke;\n                const fill = options.fill;\n                if (stroke) {\n                    this._stroke(normalizeDrawingOptions(stroke));\n                }\n                if (fill) {\n                    this._fill(normalizeDrawingOptions(fill));\n                }\n                super.redraw(options);\n            }\n        }\n        _hover(show) {\n            const drawingElement = this.drawingElement;\n            const options = this.options;\n            const hover = options.hover;\n            if (hover && hover.fill) {\n                const fill = show ? normalizeDrawingOptions(hover.fill) : options.fill;\n                drawingElement.fill(fill.color, fill.opacity);\n            }\n        }\n        _stroke(strokeOptions) {\n            const options = this.options;\n            deepExtend(options, {\n                stroke: strokeOptions\n            });\n            strokeOptions = options.stroke;\n            let stroke = null;\n            if (strokeOptions.width > 0) {\n                stroke = {\n                    color: strokeOptions.color,\n                    width: strokeOptions.width,\n                    opacity: strokeOptions.opacity,\n                    dashType: strokeOptions.dashType\n                };\n            }\n            this.drawingElement.options.set('stroke', stroke);\n        }\n        _fill(fillOptions) {\n            const options = this.options;\n            deepExtend(options, {\n                fill: fillOptions || {}\n            });\n            const fill = options.fill;\n            if (fill.gradient) {\n                const gradient = fill.gradient;\n                const GradientClass = (gradient.type === 'radial' ? kendo_drawing_cmn_chunk_js.i : kendo_drawing_cmn_chunk_js.L);\n                this.drawingElement.fill(new GradientClass(gradient));\n            }\n            else {\n                this.drawingElement.fill(fill.color, fill.opacity);\n            }\n        }\n    }\n\n    const defaultOptions$9 = {\n        stroke: {\n            color: TRANSPARENT,\n            width: 0\n        },\n        fill: {\n            color: 'black'\n        }\n    };\n    class MarkerBase extends VisualBase {\n        constructor(options) {\n            options = deepExtend({}, defaultOptions$9, options);\n            super(options);\n            const anchor = this.options.anchor || {};\n            this.anchor = new kendo_drawing_cmn_chunk_js.P(anchor.x, anchor.y);\n            this.createElement();\n        }\n        createElement() { }\n        _transformToPath(point, path) {\n            const transform = path.transform();\n            if (point && transform) {\n                point = point.transformCopy(transform);\n            }\n            return point;\n        }\n        redraw(options) {\n            if (options) {\n                if (options.position) {\n                    this.options.position = options.position;\n                }\n                super.redraw(options);\n            }\n        }\n    }\n\n    const defaultOptions$8 = {\n        path: 'M 0 0 L 10 5 L 0 10 L 3 5 z',\n        anchor: {\n            x: 10,\n            y: 5\n        }\n    };\n    class ArrowMarker extends MarkerBase {\n        constructor(options) {\n            options = deepExtend({}, defaultOptions$8, options);\n            super(options);\n        }\n        createElement() {\n            const options = this.options;\n            this.drawingElement = kendo_drawing_cmn_chunk_js.b.parse(options.path, {\n                fill: options.fill,\n                stroke: options.stroke\n            });\n        }\n        positionMarker(path) {\n            const points = this._linePoints(path);\n            const start = points.start;\n            const end = points.end;\n            const transform$1 = kendo_drawing_cmn_chunk_js.t();\n            if (start) {\n                transform$1.rotate(lineAngle(start, end), end);\n            }\n            if (end) {\n                const anchor = this.anchor;\n                const translate = end.clone().translate(-anchor.x, -anchor.y);\n                transform$1.translate(translate.x, translate.y);\n            }\n            this.drawingElement.transform(transform$1);\n        }\n        _linePoints(path) {\n            const options = this.options;\n            const segments = path.segments;\n            let startPoint, endPoint, targetSegment;\n            if (options.position === START$1) {\n                targetSegment = segments[0];\n                if (targetSegment) {\n                    endPoint = targetSegment.anchor();\n                    startPoint = targetSegment.controlOut();\n                    const nextSegment = segments[1];\n                    if (!startPoint && nextSegment) {\n                        startPoint = nextSegment.anchor();\n                    }\n                }\n            }\n            else {\n                targetSegment = segments[segments.length - 1];\n                if (targetSegment) {\n                    endPoint = targetSegment.anchor();\n                    startPoint = targetSegment.controlIn();\n                    const prevSegment = segments[segments.length - 2];\n                    if (!startPoint && prevSegment) {\n                        startPoint = prevSegment.anchor();\n                    }\n                }\n            }\n            if (endPoint) {\n                return {\n                    start: this._transformToPath(startPoint, path),\n                    end: this._transformToPath(endPoint, path)\n                };\n            }\n        }\n    }\n\n    let Canvas$1 = class Canvas {\n        constructor(element, options) {\n            this._translate = (x, y) => {\n                const viewBox = this._viewBox;\n                if (defined(x) && defined(y)) {\n                    viewBox.x = x;\n                    viewBox.y = y;\n                    this.surface.translate({ x: x, y: y });\n                }\n                return {\n                    x: viewBox.x,\n                    y: viewBox.y\n                };\n            };\n            options = options || {};\n            this.element = element;\n            this.surface = kendo_drawing_cmn_chunk_js.n.create(element, options);\n            if (isFunction$1(this.surface.translate)) {\n                this.translate = this._translate;\n            }\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.G();\n            this._viewBox = new Rect(0, 0, options.width, options.height);\n            this.size(this._viewBox);\n        }\n        bounds() {\n            const box = this.drawingElement.clippedBBox();\n            return new Rect(0, 0, box.width(), box.height());\n        }\n        size(size) {\n            const viewBox = this._viewBox;\n            if (defined(size)) {\n                viewBox.width = size.width;\n                viewBox.height = size.height;\n                this.surface.setSize(size);\n            }\n            return {\n                width: viewBox.width,\n                height: viewBox.height\n            };\n        }\n        draw() {\n            this.surface.draw(this.drawingElement);\n        }\n        append(visual) {\n            this.drawingElement.append(visual.drawingContainer());\n            return this;\n        }\n        remove(visual) {\n            this.drawingElement.remove(visual.drawingContainer());\n        }\n        insertBefore() { }\n        clear() {\n            this.drawingElement.clear();\n        }\n        destroy(clearHtml) {\n            this.surface.destroy();\n            if (clearHtml) {\n                removeChildren$1(this.element);\n                this.element.remove();\n            }\n        }\n    };\n\n    const AutoSizeableMixin = {\n        _setScale: function () {\n            const options = this.options;\n            const originWidth = this._originWidth;\n            const originHeight = this._originHeight;\n            let scaleX = options.width / originWidth;\n            let scaleY = options.height / originHeight;\n            if (!isNumber(scaleX)) {\n                scaleX = 1;\n            }\n            if (!isNumber(scaleY)) {\n                scaleY = 1;\n            }\n            this._transform.scale = new Scale(scaleX, scaleY);\n        },\n        _setTranslate: function () {\n            const options = this.options;\n            const x = options.x || 0;\n            const y = options.y || 0;\n            this._transform.translate = new Translation(x, y);\n        },\n        _initSize: function () {\n            const options = this.options;\n            let transform = false;\n            if (options.autoSize !== false && (isDefined(options.width) || isDefined(options.height))) {\n                this._measure(true);\n                this._setScale();\n                transform = true;\n            }\n            if (isDefined(options.x) || isDefined(options.y)) {\n                this._setTranslate();\n                transform = true;\n            }\n            if (transform) {\n                this._renderTransform();\n            }\n        },\n        _updateSize: function (options) {\n            let update = false;\n            if (this.options.autoSize !== false && this._diffNumericOptions(options, [WIDTH, HEIGHT])) {\n                update = true;\n                this._measure(true);\n                this._setScale();\n            }\n            if (this._diffNumericOptions(options, [X, Y])) {\n                update = true;\n                this._setTranslate();\n            }\n            if (update) {\n                this._renderTransform();\n            }\n            return update;\n        }\n    };\n\n    class Circle extends VisualBase {\n        constructor(options) {\n            super(options);\n            // Bind mixin methods to current instance\n            this._setScale = AutoSizeableMixin._setScale.bind(this);\n            this._setTranslate = AutoSizeableMixin._setTranslate.bind(this);\n            this._initSize = AutoSizeableMixin._initSize.bind(this);\n            this._updateSize = AutoSizeableMixin._updateSize.bind(this);\n            this._initCircle();\n            this._initSize();\n        }\n        redraw(options) {\n            if (options) {\n                const circleOptions = this.options;\n                if (options.center) {\n                    deepExtend(circleOptions, {\n                        center: options.center\n                    });\n                    this._center.move(circleOptions.center.x, circleOptions.center.y);\n                }\n                if (this._diffNumericOptions(options, ['radius'])) {\n                    this._circle.setRadius(circleOptions.radius);\n                }\n                this._updateSize(options);\n                super.redraw.call(this, options);\n            }\n        }\n        _initCircle() {\n            const options = this.options;\n            let width = options.width;\n            let height = options.height;\n            let radius = options.radius;\n            if (!defined(radius)) {\n                if (!defined(width)) {\n                    width = height;\n                }\n                if (!defined(height)) {\n                    height = width;\n                }\n                options.radius = radius = Math.min(width, height) / 2;\n            }\n            const center = options.center || { x: radius, y: radius };\n            this._center = new kendo_drawing_cmn_chunk_js.P(center.x, center.y);\n            this._circle = new kendo_drawing_cmn_chunk_js.g(this._center, radius);\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.f(this._circle, {\n                stroke: options.stroke\n            });\n            this._fill();\n        }\n    }\n\n    const defaultOptions$7 = {\n        radius: 4,\n        anchor: {\n            x: 0,\n            y: 0\n        }\n    };\n    class CircleMarker extends MarkerBase {\n        constructor(options) {\n            options = deepExtend({}, defaultOptions$7, options);\n            super(options);\n        }\n        createElement() {\n            const options = this.options;\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.f(new kendo_drawing_cmn_chunk_js.g(this.anchor, options.radius), {\n                fill: options.fill,\n                stroke: options.stroke\n            });\n        }\n        positionMarker(path) {\n            const options = this.options;\n            const position = options.position;\n            const segments = path.segments;\n            let targetSegment;\n            let point;\n            if (position === START$1) {\n                targetSegment = segments[0];\n            }\n            else {\n                targetSegment = segments[segments.length - 1];\n            }\n            if (targetSegment) {\n                point = this._transformToPath(targetSegment.anchor(), path);\n                this.drawingElement.transform(kendo_drawing_cmn_chunk_js.t().translate(point.x, point.y));\n            }\n        }\n    }\n\n    class Group extends Element {\n        constructor(options) {\n            options = deepExtend({ autoSize: false }, options);\n            super(options);\n            this.children = [];\n            this._childrenChange = false;\n            // Bind mixin methods to current instance\n            this._setScale = AutoSizeableMixin._setScale.bind(this);\n            this._setTranslate = AutoSizeableMixin._setTranslate.bind(this);\n            this._initSize = AutoSizeableMixin._initSize.bind(this);\n            this._updateSize = AutoSizeableMixin._updateSize.bind(this);\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.G();\n            this._initSize();\n        }\n        append(visual) {\n            this.drawingElement.append(visual.drawingContainer());\n            this.children.push(visual);\n            this._childrenChange = true;\n        }\n        ;\n        remove(visual) {\n            if (this._remove(visual)) {\n                this._childrenChange = true;\n            }\n        }\n        _remove(visual) {\n            const index = this.children.indexOf(visual);\n            if (index >= 0) {\n                this.drawingElement.removeAt(index);\n                this.children.splice(index, 1);\n                return true;\n            }\n        }\n        clear() {\n            this.drawingElement.clear();\n            this.children = [];\n            this._childrenChange = true;\n        }\n        toFront(visuals) {\n            let visual;\n            for (let i = 0; i < visuals.length; i++) {\n                visual = visuals[i];\n                if (this._remove(visual)) {\n                    this.append(visual);\n                }\n            }\n        }\n        // TO DO: add drawing group support for moving and inserting children\n        toBack(visuals) {\n            this._reorderChildren(visuals, 0);\n        }\n        toIndex(visuals, indices) {\n            this._reorderChildren(visuals, indices);\n        }\n        _reorderChildren(visuals, indices) {\n            const group = this.drawingElement;\n            const drawingChildren = group.children.slice(0);\n            const children = this.children;\n            const fixedPosition = isNumber(indices);\n            let i, index, toIndex, drawingElement, visual;\n            for (i = 0; i < visuals.length; i++) {\n                visual = visuals[i];\n                drawingElement = visual.drawingContainer();\n                index = children.indexOf(visual);\n                if (index >= 0) {\n                    drawingChildren.splice(index, 1);\n                    children.splice(index, 1);\n                    toIndex = fixedPosition ? indices : indices[i];\n                    drawingChildren.splice(toIndex, 0, drawingElement);\n                    children.splice(toIndex, 0, visual);\n                }\n            }\n            group.clear();\n            group.append(...drawingChildren);\n        }\n        redraw(options) {\n            if (options) {\n                if (this._childrenChange) {\n                    this._childrenChange = false;\n                    if (!this._updateSize(options)) {\n                        this._initSize();\n                    }\n                }\n                else {\n                    this._updateSize(options);\n                }\n                super.redraw(options);\n            }\n        }\n        _boundingBox() {\n            const children = this.children;\n            let boundingBox;\n            let visual, childBoundingBox;\n            for (let i = 0; i < children.length; i++) {\n                visual = children[i];\n                if (visual.visible() && visual._includeInBBox !== false) {\n                    childBoundingBox = visual.drawingContainer().clippedBBox(null);\n                    if (childBoundingBox) {\n                        if (boundingBox) {\n                            boundingBox = kendo_drawing_cmn_chunk_js.R.union(boundingBox, childBoundingBox);\n                        }\n                        else {\n                            boundingBox = childBoundingBox;\n                        }\n                    }\n                }\n            }\n            return boundingBox;\n        }\n    }\n\n    class Image extends Element {\n        constructor(options) {\n            super(options);\n            this._initImage();\n        }\n        redraw(options) {\n            if (options) {\n                if (options.source) {\n                    this.drawingElement.src(options.source);\n                }\n                if (this._diffNumericOptions(options, [WIDTH, HEIGHT, X, Y])) {\n                    this.drawingElement.rect(this._rect());\n                }\n                super.redraw(options);\n            }\n        }\n        _initImage() {\n            const options = this.options;\n            const rect = this._rect();\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.I(options.source, rect);\n        }\n        _rect() {\n            const sizeOptions = sizeOptionsOrDefault(this.options);\n            const origin = new kendo_drawing_cmn_chunk_js.P(sizeOptions.x, sizeOptions.y);\n            const size = new kendo_drawing_cmn_chunk_js.q(sizeOptions.width, sizeOptions.height);\n            return new kendo_drawing_cmn_chunk_js.R(origin, size);\n        }\n    }\n\n    class Layout extends Group {\n        constructor(rect, options) {\n            super(options);\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.k(toDrawingRect(rect), options);\n            this._initSize();\n        }\n        rect(rect) {\n            if (rect) {\n                this.drawingElement.rect(toDrawingRect(rect));\n            }\n            else {\n                const drawingRect = this.drawingElement.rect();\n                if (drawingRect) {\n                    return new Rect(drawingRect.origin.x, drawingRect.origin.y, drawingRect.size.width, drawingRect.size.height);\n                }\n            }\n        }\n        reflow() {\n            this.drawingElement.reflow();\n        }\n        redraw(options) {\n            deepExtend(this.drawingElement.options, options);\n            super.redraw.call(this, options);\n        }\n    }\n\n    const MarkerPathMixin = {\n        _getPath: function (position) {\n            let path = this.drawingElement;\n            if (path instanceof kendo_drawing_cmn_chunk_js.h) {\n                if (position === START$1) {\n                    path = path.paths[0];\n                }\n                else {\n                    path = path.paths[path.paths.length - 1];\n                }\n            }\n            if (path && path.segments.length) {\n                return path;\n            }\n        },\n        _normalizeMarkerOptions: function (options) {\n            const startCap = options.startCap;\n            const endCap = options.endCap;\n            if (isString$1(startCap)) {\n                options.startCap = {\n                    type: startCap\n                };\n            }\n            if (isString$1(endCap)) {\n                options.endCap = {\n                    type: endCap\n                };\n            }\n        },\n        _removeMarker: function (position) {\n            const marker = this._markers[position];\n            if (marker) {\n                this.drawingContainer().remove(marker.drawingElement);\n                delete this._markers[position];\n            }\n        },\n        _createMarkers: function () {\n            const options = this.options;\n            this._normalizeMarkerOptions(options);\n            this._markers = {};\n            this._markers[START$1] = this._createMarker(options.startCap, START$1);\n            this._markers[END$1] = this._createMarker(options.endCap, END$1);\n        },\n        _createMarker: function (options, position) {\n            const type = (options || {}).type;\n            const path = this._getPath(position);\n            let markerType, marker;\n            if (!path) {\n                this._removeMarker(position);\n                return;\n            }\n            if (type === Markers.filledCircle) {\n                markerType = CircleMarker;\n            }\n            else if (type === Markers.arrowStart || type === Markers.arrowEnd) {\n                markerType = ArrowMarker;\n            }\n            else {\n                this._removeMarker(position);\n            }\n            if (markerType) {\n                marker = new markerType(deepExtend({}, options, {\n                    position: position\n                }));\n                marker.positionMarker(path);\n                this.drawingContainer().append(marker.drawingElement);\n                return marker;\n            }\n        },\n        _positionMarker: function (position) {\n            const marker = this._markers[position];\n            if (marker) {\n                const path = this._getPath(position);\n                if (path) {\n                    marker.positionMarker(path);\n                }\n                else {\n                    this._removeMarker(position);\n                }\n            }\n        },\n        _capMap: {\n            start: 'startCap',\n            end: 'endCap'\n        },\n        _redrawMarker: function (pathChange, position, options) {\n            this._normalizeMarkerOptions(options);\n            const pathOptions = this.options;\n            const cap = this._capMap[position];\n            const pathCapType = (pathOptions[cap] || {}).type;\n            const optionsCap = options[cap];\n            let created = false;\n            if (optionsCap) {\n                pathOptions[cap] = deepExtend({}, pathOptions[cap], optionsCap);\n                if (optionsCap.type && pathCapType !== optionsCap.type) {\n                    this._removeMarker(position);\n                    this._markers[position] = this._createMarker(pathOptions[cap], position);\n                    created = true;\n                }\n                else if (this._markers[position]) {\n                    this._markers[position].redraw(optionsCap);\n                }\n            }\n            else if (pathChange && !this._markers[position] && pathOptions[cap]) {\n                this._markers[position] = this._createMarker(pathOptions[cap], position);\n                created = true;\n            }\n            return created;\n        },\n        _redrawMarkers: function (pathChange, options) {\n            if (!this._redrawMarker(pathChange, START$1, options) && pathChange) {\n                this._positionMarker(START$1);\n            }\n            if (!this._redrawMarker(pathChange, END$1, options) && pathChange) {\n                this._positionMarker(END$1);\n            }\n        }\n    };\n\n    class Line extends VisualBase {\n        constructor(options) {\n            super(options);\n            this._capMap = MarkerPathMixin._capMap;\n            this.container = new kendo_drawing_cmn_chunk_js.G();\n            this._getPath = MarkerPathMixin._getPath.bind(this);\n            this._normalizeMarkerOptions = MarkerPathMixin._normalizeMarkerOptions.bind(this);\n            this._removeMarker = MarkerPathMixin._removeMarker.bind(this);\n            this._createMarkers = MarkerPathMixin._createMarkers.bind(this);\n            this._createMarker = MarkerPathMixin._createMarker.bind(this);\n            this._positionMarker = MarkerPathMixin._positionMarker.bind(this);\n            this._redrawMarker = MarkerPathMixin._redrawMarker.bind(this);\n            this._redrawMarkers = MarkerPathMixin._redrawMarkers.bind(this);\n            this._initPath();\n            this._createMarkers();\n        }\n        drawingContainer() {\n            return this.container;\n        }\n        redraw(options) {\n            if (options) {\n                options = options || {};\n                const from = options.from;\n                const to = options.to;\n                if (from) {\n                    this.options.from = from;\n                }\n                if (to) {\n                    this.options.to = to;\n                }\n                if (from || to) {\n                    this._drawPath();\n                    this._redrawMarkers(true, options);\n                }\n                else {\n                    this._redrawMarkers(false, options);\n                }\n                super.redraw(options);\n            }\n        }\n        _initPath() {\n            const options = this.options;\n            const drawingElement = this.drawingElement = new kendo_drawing_cmn_chunk_js.b({\n                stroke: options.stroke\n            });\n            this._fill();\n            this._drawPath();\n            this.container.append(drawingElement);\n        }\n        _drawPath() {\n            const options = this.options;\n            const drawingElement = this.drawingElement;\n            const from = options.from || new Point();\n            const to = options.to || new Point();\n            drawingElement.segments.elements([\n                createSegment(from.x, from.y),\n                createSegment(to.x, to.y)\n            ]);\n        }\n    }\n\n    class Path extends VisualBase {\n        constructor(options) {\n            options = deepExtend({ autoSize: true }, options);\n            super(options);\n            this._capMap = MarkerPathMixin._capMap;\n            this.container = new kendo_drawing_cmn_chunk_js.G();\n            this._setScale = AutoSizeableMixin._setScale.bind(this);\n            this._setTranslate = AutoSizeableMixin._setTranslate.bind(this);\n            this._initSize = AutoSizeableMixin._initSize.bind(this);\n            this._updateSize = AutoSizeableMixin._updateSize.bind(this);\n            this._getPath = MarkerPathMixin._getPath.bind(this);\n            this._normalizeMarkerOptions = MarkerPathMixin._normalizeMarkerOptions.bind(this);\n            this._removeMarker = MarkerPathMixin._removeMarker.bind(this);\n            this._createMarkers = MarkerPathMixin._createMarkers.bind(this);\n            this._createMarker = MarkerPathMixin._createMarker.bind(this);\n            this._positionMarker = MarkerPathMixin._positionMarker.bind(this);\n            this._redrawMarker = MarkerPathMixin._redrawMarker.bind(this);\n            this._redrawMarkers = MarkerPathMixin._redrawMarkers.bind(this);\n            this._createElements();\n            this._initSize();\n        }\n        drawingContainer() {\n            return this.container;\n        }\n        data(value) {\n            const options = this.options;\n            if (value) {\n                if (options.data !== value) {\n                    options.data = value;\n                    this._setData(value);\n                    this._initSize();\n                    this._redrawMarkers(true, {});\n                }\n            }\n            else {\n                return options.data;\n            }\n        }\n        redraw(options) {\n            if (options) {\n                super.redraw(options);\n                const pathOptions = this.options;\n                const data = options.data;\n                if (defined(data) && pathOptions.data !== data) {\n                    pathOptions.data = data;\n                    this._setData(data);\n                    if (!this._updateSize(options)) {\n                        this._initSize();\n                    }\n                    this._redrawMarkers(true, options);\n                }\n                else {\n                    this._updateSize(options);\n                    this._redrawMarkers(false, options);\n                }\n            }\n        }\n        _createElements() {\n            const options = this.options;\n            this.drawingElement = kendo_drawing_cmn_chunk_js.b.parse(options.data || '', {\n                stroke: options.stroke\n            });\n            this._fill();\n            this.container.append(this.drawingElement);\n            this._createMarkers();\n        }\n        _setData(data) {\n            const drawingElement = this.drawingElement;\n            const multipath = kendo_drawing_cmn_chunk_js.b.parse(data || '');\n            const paths = multipath.paths.slice(0);\n            multipath.paths.elements([]);\n            drawingElement.paths.elements(paths);\n        }\n    }\n\n    class Polyline extends VisualBase {\n        constructor(options) {\n            options = deepExtend({ points: [] }, options);\n            super(options);\n            this._capMap = MarkerPathMixin._capMap;\n            this.container = new kendo_drawing_cmn_chunk_js.G();\n            this._getPath = MarkerPathMixin._getPath.bind(this);\n            this._normalizeMarkerOptions = MarkerPathMixin._normalizeMarkerOptions.bind(this);\n            this._removeMarker = MarkerPathMixin._removeMarker.bind(this);\n            this._createMarkers = MarkerPathMixin._createMarkers.bind(this);\n            this._createMarker = MarkerPathMixin._createMarker.bind(this);\n            this._positionMarker = MarkerPathMixin._positionMarker.bind(this);\n            this._redrawMarker = MarkerPathMixin._redrawMarker.bind(this);\n            this._redrawMarkers = MarkerPathMixin._redrawMarkers.bind(this);\n            this._initPath();\n            this._createMarkers();\n        }\n        drawingContainer() {\n            return this.container;\n        }\n        points(points) {\n            const options = this.options;\n            if (points) {\n                options.points = points;\n                this._updatePath();\n            }\n            else {\n                return options.points;\n            }\n        }\n        redraw(options) {\n            if (options) {\n                const points = options.points;\n                super.redraw.call(this, options);\n                if (points && this._pointsDiffer(points)) {\n                    this.points(points);\n                    this._redrawMarkers(true, options);\n                }\n                else {\n                    this._redrawMarkers(false, options);\n                }\n            }\n        }\n        _initPath() {\n            const options = this.options;\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.b({\n                stroke: options.stroke\n            });\n            this._fill();\n            this.container.append(this.drawingElement);\n            if (options.points) {\n                this._updatePath();\n            }\n        }\n        _pointsDiffer(points) {\n            const currentPoints = this.options.points;\n            let differ = currentPoints.length !== points.length;\n            if (!differ) {\n                for (let i = 0; i < points.length; i++) {\n                    if (currentPoints[i].x !== points[i].x || currentPoints[i].y !== points[i].y) {\n                        differ = true;\n                        break;\n                    }\n                }\n            }\n            return differ;\n        }\n        _updatePath() {\n            const drawingElement = this.drawingElement;\n            const options = this.options;\n            const points = options.points;\n            const segments = [];\n            let point;\n            for (let i = 0; i < points.length; i++) {\n                point = points[i];\n                segments.push(createSegment(point.x, point.y));\n            }\n            drawingElement.segments.elements(segments);\n        }\n    }\n\n    class Rectangle extends VisualBase {\n        constructor(options) {\n            super(options);\n            this._initPath();\n            this._setPosition();\n        }\n        _setPosition() {\n            const options = this.options;\n            const x = options.x;\n            const y = options.y;\n            if (defined(x) || defined(y)) {\n                this.position(x || 0, y || 0);\n            }\n        }\n        redraw(options) {\n            if (options) {\n                super.redraw(options);\n                if (this._diffNumericOptions(options, [WIDTH, HEIGHT])) {\n                    this._drawPath();\n                }\n                if (this._diffNumericOptions(options, [X, Y])) {\n                    this._setPosition();\n                }\n            }\n        }\n        _initPath() {\n            const options = this.options;\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.b({\n                stroke: options.stroke,\n                closed: true\n            });\n            this._fill();\n            this._drawPath();\n        }\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const sizeOptions = sizeOptionsOrDefault(this.options);\n            const width = sizeOptions.width;\n            const height = sizeOptions.height;\n            drawingElement.segments.elements([\n                createSegment(0, 0),\n                createSegment(width, 0),\n                createSegment(width, height),\n                createSegment(0, height)\n            ]);\n        }\n    }\n\n    const textColor = (options) => {\n        if (options && options.color) {\n            options = deepExtend({}, options, {\n                fill: {\n                    color: options.color\n                }\n            });\n        }\n        return options;\n    };\n    const defaultOptions$6 = {\n        fontSize: 15,\n        fontFamily: 'sans-serif',\n        stroke: {\n            width: 0\n        },\n        fill: {\n            color: 'black'\n        },\n        autoSize: true\n    };\n    class TextBlock extends VisualBase {\n        constructor(options) {\n            options = deepExtend({}, defaultOptions$6, options);\n            options = textColor(options);\n            super(options);\n            this._setScale = AutoSizeableMixin._setScale.bind(this);\n            this._setTranslate = AutoSizeableMixin._setTranslate.bind(this);\n            this._initSize = AutoSizeableMixin._initSize.bind(this);\n            this._updateSize = AutoSizeableMixin._updateSize.bind(this);\n            this._font();\n            this._initText();\n            this._initSize();\n        }\n        _initText() {\n            const options = this.options;\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.T(defined(options.text) ? options.text : '', new kendo_drawing_cmn_chunk_js.P(), {\n                font: options.font\n            });\n            this._fill();\n            this._stroke();\n        }\n        _font() {\n            const options = this.options;\n            if (options.fontFamily && defined(options.fontSize)) {\n                const fontOptions = [];\n                if (options.fontStyle) {\n                    fontOptions.push(options.fontStyle);\n                }\n                if (options.fontWeight) {\n                    fontOptions.push(options.fontWeight);\n                }\n                fontOptions.push(options.fontSize + (isNumber(options.fontSize) ? 'px' : ''));\n                fontOptions.push(options.fontFamily);\n                options.font = fontOptions.join(' ');\n            }\n            else {\n                delete options.font;\n            }\n        }\n        content(text) {\n            return this.drawingElement.content(text);\n        }\n        redraw(options) {\n            if (options) {\n                let sizeChanged = false;\n                const textOptions = this.options;\n                options = textColor(options);\n                super.redraw(options);\n                if (options.fontFamily || defined(options.fontSize) || options.fontStyle || options.fontWeight) {\n                    deepExtend(textOptions, {\n                        fontFamily: options.fontFamily,\n                        fontSize: options.fontSize,\n                        fontStyle: options.fontStyle,\n                        fontWeight: options.fontWeight\n                    });\n                    this._font();\n                    this.drawingElement.options.set('font', textOptions.font);\n                    sizeChanged = true;\n                }\n                if (options.text) {\n                    this.content(options.text);\n                    sizeChanged = true;\n                }\n                if (!this._updateSize(options) && sizeChanged) {\n                    this._initSize();\n                }\n            }\n        }\n    }\n\n    /**\n     * The Sugiyama aka layered layout algorithm.\n     *\n     * @type {*}\n     */\n    class LayeredLayout extends LayoutBase {\n        constructor(diagram) {\n            super();\n            if (isUndefined(diagram)) {\n                throw new Error('Diagram is not specified.');\n            }\n            this.diagram = diagram;\n        }\n        layout(options) {\n            this.transferOptions(options);\n            const adapter = new DiagramToHyperTreeAdapter(this.diagram);\n            const graph = adapter.convert(options);\n            if (graph.isEmpty()) {\n                return;\n            }\n            // split into connected components\n            const components = graph.getConnectedComponents();\n            if (isEmpty(components)) {\n                return;\n            }\n            for (let i = 0; i < components.length; i++) {\n                const component = components[i];\n                this.layoutGraph(component, options);\n            }\n            const finalNodeSet = this.gridLayoutComponents(components);\n            return new LayoutState(this.diagram, finalNodeSet);\n        }\n        /**\n         * Initializes the runtime data properties of the layout.\n         *\n         * @private\n         */\n        _initRuntimeProperties() {\n            for (let k = 0; k < this.graph.nodes.length; k++) {\n                const node = this.graph.nodes[k];\n                node.layer = -1;\n                node.downstreamLinkCount = 0;\n                node.upstreamLinkCount = 0;\n                node.isVirtual = false;\n                node.uBaryCenter = 0.0;\n                node.dBaryCenter = 0.0;\n                node.upstreamPriority = 0;\n                node.downstreamPriority = 0;\n                node.gridPosition = 0;\n            }\n        }\n        _prepare(graph) {\n            const current = [];\n            let i, l, link;\n            // defines a mapping of a node to the layer index\n            const layerMap = new Dictionary();\n            let layerCount = 0;\n            let targetLayer, next, target;\n            forEach(graph.nodes, function (node) {\n                if (node.incoming.length === 0) {\n                    layerMap.set(node, 0);\n                    current.push(node);\n                }\n            });\n            while (current.length > 0) {\n                next = current.shift();\n                for (i = 0; i < next.outgoing.length; i++) {\n                    link = next.outgoing[i];\n                    target = link.target;\n                    if (layerMap.containsKey(target)) {\n                        targetLayer = Math.max(layerMap.get(next) + 1, layerMap.get(target));\n                    }\n                    else {\n                        targetLayer = layerMap.get(next) + 1;\n                    }\n                    layerMap.set(target, targetLayer);\n                    if (targetLayer > layerCount) {\n                        layerCount = targetLayer;\n                    }\n                    if (!contains(current, target)) {\n                        current.push(target);\n                    }\n                }\n            }\n            const sortedNodes = layerMap.keys();\n            sortedNodes.sort(function (o1, o2) {\n                const o1layer = layerMap.get(o1);\n                const o2layer = layerMap.get(o2);\n                return sign(o2layer - o1layer);\n            });\n            for (let n = 0; n < sortedNodes.length; ++n) {\n                const node = sortedNodes[n];\n                let minLayer = Number.MAX_VALUE;\n                if (node.outgoing.length === 0) {\n                    continue;\n                }\n                for (l = 0; l < node.outgoing.length; ++l) {\n                    link = node.outgoing[l];\n                    minLayer = Math.min(minLayer, layerMap.get(link.target));\n                }\n                if (minLayer > 1) {\n                    layerMap.set(node, minLayer - 1);\n                }\n            }\n            this.layers = [];\n            let layer;\n            for (i = 0; i < layerCount + 1; i++) {\n                layer = [];\n                layer.linksTo = {};\n                this.layers.push(layer);\n            }\n            layerMap.forEach(function (node, layerVal) {\n                node.layer = layerVal;\n                this.layers[layerVal].push(node);\n            }, this);\n            // set initial grid positions\n            for (l = 0; l < this.layers.length; l++) {\n                layer = this.layers[l];\n                for (i = 0; i < layer.length; i++) {\n                    layer[i].gridPosition = i;\n                }\n            }\n        }\n        /**\n         * Performs the layout of a single component.\n         */\n        layoutGraph(graph, options) {\n            if (isUndefined(graph)) {\n                throw new Error('No graph given or graph analysis of the diagram failed.');\n            }\n            if (isDefined(options)) {\n                this.transferOptions(options);\n            }\n            this.graph = graph;\n            // sets unique indices on the nodes\n            graph.setItemIndices();\n            // ensures no cycles present for this layout\n            const reversedEdges = graph.makeAcyclic();\n            // define the runtime props being used by the layout algorithm\n            this._initRuntimeProperties();\n            this._prepare(graph);\n            this._dummify();\n            this._optimizeCrossings();\n            this._swapPairs();\n            this.arrangeNodes();\n            this._moveThingsAround();\n            this._dedummify();\n            // re-reverse the links which were switched earlier\n            forEach(reversedEdges, function (e) {\n                if (e.points) {\n                    e.points.reverse();\n                }\n            });\n        }\n        setMinDist(m, _n, minDist) {\n            const l = m.layer;\n            const i = m.layerIndex;\n            // Validate indices to prevent prototype pollution\n            if (!Number.isInteger(l) || !Number.isInteger(i) || l < 0 || i < 0) {\n                throw new Error('Invalid layer or index value.');\n            }\n            this.minDistances[l][i] = minDist;\n        }\n        getMinDist(m, n) {\n            let dist = 0;\n            const i1 = m.layerIndex, i2 = n.layerIndex, l = m.layer, min = Math.min(i1, i2), max = Math.max(i1, i2);\n            // use Sum()?\n            for (let k = min; k < max; ++k) {\n                dist += this.minDistances[l][k];\n            }\n            return dist;\n        }\n        placeLeftToRight(leftClasses) {\n            const leftPos = new Dictionary();\n            let n, node;\n            for (let c = 0; c < this.layers.length; ++c) {\n                const classNodes = leftClasses[c];\n                if (!classNodes) {\n                    continue;\n                }\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    if (!leftPos.containsKey(node)) {\n                        this.placeLeft(node, leftPos, c);\n                    }\n                }\n                // adjust class\n                let d = Number.POSITIVE_INFINITY;\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    const rightSibling = this.rightSibling(node);\n                    if (rightSibling && this.nodeLeftClass.get(rightSibling) !== c) {\n                        d = Math.min(d, leftPos.get(rightSibling) - leftPos.get(node) - this.getMinDist(node, rightSibling));\n                    }\n                }\n                if (d === Number.POSITIVE_INFINITY) {\n                    const D = [];\n                    for (n = 0; n < classNodes.length; n++) {\n                        node = classNodes[n];\n                        const neighbors = [];\n                        addRange(neighbors, this.upNodes.get(node));\n                        addRange(neighbors, this.downNodes.get(node));\n                        for (let e = 0; e < neighbors.length; e++) {\n                            const neighbor = neighbors[e];\n                            if (this.nodeLeftClass.get(neighbor) < c) {\n                                D.push(leftPos.get(neighbor) - leftPos.get(node));\n                            }\n                        }\n                    }\n                    D.sort();\n                    if (D.length === 0) {\n                        d = 0;\n                    }\n                    else if (D.length % 2 === 1) {\n                        d = D[this.intDiv(D.length, 2)];\n                    }\n                    else {\n                        d = (D[this.intDiv(D.length, 2) - 1] + D[this.intDiv(D.length, 2)]) / 2;\n                    }\n                }\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    leftPos.set(node, leftPos.get(node) + d);\n                }\n            }\n            return leftPos;\n        }\n        placeRightToLeft(rightClasses) {\n            const rightPos = new Dictionary();\n            let n, node;\n            for (let c = 0; c < this.layers.length; ++c) {\n                const classNodes = rightClasses[c];\n                if (!classNodes) {\n                    continue;\n                }\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    if (!rightPos.containsKey(node)) {\n                        this.placeRight(node, rightPos, c);\n                    }\n                }\n                // adjust class\n                let d = Number.NEGATIVE_INFINITY;\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    const leftSibling = this.leftSibling(node);\n                    if (leftSibling && this.nodeRightClass.get(leftSibling) !== c) {\n                        d = Math.max(d, rightPos.get(leftSibling) - rightPos.get(node) + this.getMinDist(leftSibling, node));\n                    }\n                }\n                if (d === Number.NEGATIVE_INFINITY) {\n                    const D = [];\n                    for (n = 0; n < classNodes.length; n++) {\n                        node = classNodes[n];\n                        const neighbors = [];\n                        addRange(neighbors, this.upNodes.get(node));\n                        addRange(neighbors, this.downNodes.get(node));\n                        for (let e = 0; e < neighbors.length; e++) {\n                            const neighbor = neighbors[e];\n                            if (this.nodeRightClass.get(neighbor) < c) {\n                                D.push(rightPos.get(node) - rightPos.get(neighbor));\n                            }\n                        }\n                    }\n                    D.sort();\n                    if (D.length === 0) {\n                        d = 0;\n                    }\n                    else if (D.length % 2 === 1) {\n                        d = D[this.intDiv(D.length, 2)];\n                    }\n                    else {\n                        d = (D[this.intDiv(D.length, 2) - 1] + D[this.intDiv(D.length, 2)]) / 2;\n                    }\n                }\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    rightPos.set(node, rightPos.get(node) + d);\n                }\n            }\n            return rightPos;\n        }\n        _getLeftWing() {\n            const leftWing = { value: null };\n            const result = this.computeClasses(leftWing, 1);\n            this.nodeLeftClass = leftWing.value;\n            return result;\n        }\n        _getRightWing() {\n            const rightWing = { value: null };\n            const result = this.computeClasses(rightWing, -1);\n            this.nodeRightClass = rightWing.value;\n            return result;\n        }\n        computeClasses(wingPair, d) {\n            let currentWing = 0;\n            const wing = wingPair.value = new Dictionary();\n            for (let l = 0; l < this.layers.length; ++l) {\n                currentWing = l;\n                const layer = this.layers[l];\n                for (let n = d === 1 ? 0 : layer.length - 1; n >= 0 && n < layer.length; n += d) {\n                    const node = layer[n];\n                    if (!wing.containsKey(node)) {\n                        wing.set(node, currentWing);\n                        if (node.isVirtual) {\n                            const ndsinl = this._nodesInLink(node);\n                            for (let kk = 0; kk < ndsinl.length; kk++) {\n                                const vnode = ndsinl[kk];\n                                wing.set(vnode, currentWing);\n                            }\n                        }\n                    }\n                    else {\n                        currentWing = wing.get(node);\n                    }\n                }\n            }\n            const wings = [];\n            for (let i = 0; i < this.layers.length; i++) {\n                wings.push(null);\n            }\n            wing.forEach(function (node, classIndex) {\n                if (wings[classIndex] === null) {\n                    wings[classIndex] = [];\n                }\n                wings[classIndex].push(node);\n            });\n            return wings;\n        }\n        _isVerticalLayout() {\n            return this.options.subtype.toLowerCase() === 'up' || this.options.subtype.toLowerCase() === 'down' || this.options.subtype.toLowerCase() === 'vertical';\n        }\n        _isHorizontalLayout() {\n            return this.options.subtype.toLowerCase() === 'right' || this.options.subtype.toLowerCase() === 'left' || this.options.subtype.toLowerCase() === 'horizontal';\n        }\n        _isIncreasingLayout() {\n            // meaning that the visiting of the layers goes in the natural order of increasing layer index\n            return this.options.subtype.toLowerCase() === 'right' || this.options.subtype.toLowerCase() === 'down';\n        }\n        _moveThingsAround() {\n            let i, l, node, layer, n, w;\n            // sort the layers by their grid position\n            for (l = 0; l < this.layers.length; ++l) {\n                layer = this.layers[l];\n                layer.sort(this._gridPositionComparer.bind(this));\n            }\n            this.minDistances = [];\n            for (l = 0; l < this.layers.length; ++l) {\n                layer = this.layers[l];\n                this.minDistances[l] = [];\n                for (n = 0; n < layer.length; ++n) {\n                    node = layer[n];\n                    node.layerIndex = n;\n                    this.minDistances[l][n] = this.options.nodeDistance;\n                    if (n < layer.length - 1) {\n                        if (this._isVerticalLayout()) {\n                            this.minDistances[l][n] += (node.width + layer[n + 1].width) / 2;\n                        }\n                        else {\n                            this.minDistances[l][n] += (node.height + layer[n + 1].height) / 2;\n                        }\n                    }\n                }\n            }\n            this.downNodes = new Dictionary();\n            this.upNodes = new Dictionary();\n            forEach(this.graph.nodes, function (gNode) {\n                this.downNodes.set(gNode, []);\n                this.upNodes.set(gNode, []);\n            }, this);\n            forEach(this.graph.links, function (link) {\n                const origin = link.source;\n                const dest = link.target;\n                let down = null, up = null;\n                if (origin.layer > dest.layer) {\n                    down = link.source;\n                    up = link.target;\n                }\n                else {\n                    up = link.source;\n                    down = link.target;\n                }\n                this.downNodes.get(up).push(down);\n                this.upNodes.get(down).push(up);\n            }, this);\n            this.downNodes.forEachValue(function (list) {\n                list.sort(this._gridPositionComparer);\n            }, this);\n            this.upNodes.forEachValue(function (list) {\n                list.sort(this._gridPositionComparer);\n            }, this);\n            for (l = 0; l < this.layers.length - 1; ++l) {\n                layer = this.layers[l];\n                for (w = 0; w < layer.length - 1; w++) {\n                    const currentNode = layer[w];\n                    if (!currentNode.isVirtual) {\n                        continue;\n                    }\n                    const currDown = this.downNodes.get(currentNode)[0];\n                    if (!currDown.isVirtual) {\n                        continue;\n                    }\n                    for (n = w + 1; n < layer.length; ++n) {\n                        node = layer[n];\n                        if (!node.isVirtual) {\n                            continue;\n                        }\n                        const downNode = this.downNodes.get(node)[0];\n                        if (!downNode.isVirtual) {\n                            continue;\n                        }\n                        if (currDown.gridPosition > downNode.gridPosition) {\n                            const pos = currDown.gridPosition;\n                            currDown.gridPosition = downNode.gridPosition;\n                            downNode.gridPosition = pos;\n                            const i1 = currDown.layerIndex;\n                            const i2 = downNode.layerIndex;\n                            this.layers[l + 1][i1] = downNode;\n                            this.layers[l + 1][i2] = currDown;\n                            currDown.layerIndex = i2;\n                            downNode.layerIndex = i1;\n                        }\n                    }\n                }\n            }\n            const leftClasses = this._getLeftWing();\n            const rightClasses = this._getRightWing();\n            const leftPos = this.placeLeftToRight(leftClasses);\n            const rightPos = this.placeRightToLeft(rightClasses);\n            const x = new Dictionary();\n            forEach(this.graph.nodes, function (gNode) {\n                x.set(gNode, (leftPos.get(gNode) + rightPos.get(gNode)) / 2);\n            });\n            const order = new Dictionary();\n            const placed = new Dictionary();\n            for (l = 0; l < this.layers.length; ++l) {\n                layer = this.layers[l];\n                let sequenceStart = -1; // , sequenceEnd = -1;\n                for (n = 0; n < layer.length; ++n) {\n                    node = layer[n];\n                    order.set(node, 0);\n                    placed.set(node, false);\n                    if (node.isVirtual) {\n                        if (sequenceStart === -1) {\n                            sequenceStart = n;\n                        }\n                        else if (sequenceStart === n - 1) {\n                            sequenceStart = n;\n                        }\n                        else {\n                            // sequenceEnd = n;\n                            order.set(layer[sequenceStart], 0);\n                            if (x.get(node) - x.get(layer[sequenceStart]) === this.getMinDist(layer[sequenceStart], node)) {\n                                placed.set(layer[sequenceStart], true);\n                            }\n                            else {\n                                placed.set(layer[sequenceStart], false);\n                            }\n                            sequenceStart = n;\n                        }\n                    }\n                }\n            }\n            const directions = [1, -1];\n            forEach(directions, function (d) {\n                const start = d === 1 ? 0 : this.layers.length - 1;\n                for (let ll = start; ll >= 0 && ll < this.layers.length; ll += d) {\n                    const layer2 = this.layers[ll];\n                    let virtualStartIndex = this._firstVirtualNode(layer2);\n                    let virtualStart = null;\n                    let sequence = null;\n                    if (virtualStartIndex !== -1) {\n                        virtualStart = layer2[virtualStartIndex];\n                        sequence = [];\n                        for (i = 0; i < virtualStartIndex; i++) {\n                            sequence.push(layer2[i]);\n                        }\n                    }\n                    else {\n                        virtualStart = null;\n                        sequence = layer2;\n                    }\n                    if (sequence.length > 0) {\n                        this._sequencer(x, null, virtualStart, d, sequence);\n                        for (i = 0; i < sequence.length - 1; ++i) {\n                            this.setMinDist(sequence[i], sequence[i + 1], x.get(sequence[i + 1]) - x.get(sequence[i]));\n                        }\n                        if (virtualStart) {\n                            this.setMinDist(sequence[sequence.length - 1], virtualStart, x.get(virtualStart) - x.get(sequence[sequence.length - 1]));\n                        }\n                    }\n                    while (virtualStart) {\n                        const virtualEnd = this.nextVirtualNode(layer2, virtualStart);\n                        if (!virtualEnd) {\n                            virtualStartIndex = virtualStart.layerIndex;\n                            sequence = [];\n                            for (i = virtualStartIndex + 1; i < layer2.length; i++) {\n                                sequence.push(layer2[i]);\n                            }\n                            if (sequence.length > 0) {\n                                this._sequencer(x, virtualStart, null, d, sequence);\n                                for (i = 0; i < sequence.length - 1; ++i) {\n                                    this.setMinDist(sequence[i], sequence[i + 1], x.get(sequence[i + 1]) - x.get(sequence[i]));\n                                }\n                                this.setMinDist(virtualStart, sequence[0], x.get(sequence[0]) - x.get(virtualStart));\n                            }\n                        }\n                        else if (order.get(virtualStart) === d) {\n                            virtualStartIndex = virtualStart.layerIndex;\n                            const virtualEndIndex = virtualEnd.layerIndex;\n                            sequence = [];\n                            for (i = virtualStartIndex + 1; i < virtualEndIndex; i++) {\n                                sequence.push(layer2[i]);\n                            }\n                            if (sequence.length > 0) {\n                                this._sequencer(x, virtualStart, virtualEnd, d, sequence);\n                            }\n                            placed.set(virtualStart, true);\n                        }\n                        virtualStart = virtualEnd;\n                    }\n                    this.adjustDirections(ll, d, order, placed);\n                }\n            }, this);\n            const fromLayerIndex = this._isIncreasingLayout() ? 0 : this.layers.length - 1;\n            const reachedFinalLayerIndex = function (k, ctx) {\n                if (ctx._isIncreasingLayout()) {\n                    return k < ctx.layers.length;\n                }\n                else {\n                    return k >= 0;\n                }\n            };\n            const layerIncrement = this._isIncreasingLayout() ? +1 : -1;\n            let offset = 0;\n            /**\n             * Calcs the max height of the given layer.\n             */\n            function maximumHeight(layer2, ctx) {\n                let height = Number.MIN_VALUE;\n                for (let nn = 0; nn < layer2.length; ++nn) {\n                    const node2 = layer2[nn];\n                    if (ctx._isVerticalLayout()) {\n                        height = Math.max(height, node2.height);\n                    }\n                    else {\n                        height = Math.max(height, node2.width);\n                    }\n                }\n                return height;\n            }\n            for (i = fromLayerIndex; reachedFinalLayerIndex(i, this); i += layerIncrement) {\n                layer = this.layers[i];\n                const height = maximumHeight(layer, this);\n                for (n = 0; n < layer.length; ++n) {\n                    node = layer[n];\n                    if (this._isVerticalLayout()) {\n                        node.x = x.get(node);\n                        node.y = offset + height / 2;\n                    }\n                    else {\n                        node.x = offset + height / 2;\n                        node.y = x.get(node);\n                    }\n                }\n                offset += this.options.layerSeparation + height;\n            }\n        }\n        adjustDirections(l, d, order, placed) {\n            if (l + d < 0 || l + d >= this.layers.length) {\n                return;\n            }\n            let prevBridge = null, prevBridgeTarget = null;\n            const layer = this.layers[l + d];\n            for (let n = 0; n < layer.length; ++n) {\n                const nextBridge = layer[n];\n                if (nextBridge.isVirtual) {\n                    const nextBridgeTarget = this.getNeighborOnLayer(nextBridge, l);\n                    if (nextBridgeTarget.isVirtual) {\n                        if (prevBridge) {\n                            let p = placed.get(prevBridgeTarget);\n                            const clayer = this.layers[l];\n                            const i1 = prevBridgeTarget.layerIndex;\n                            const i2 = nextBridgeTarget.layerIndex;\n                            for (let i = i1 + 1; i < i2; ++i) {\n                                if (clayer[i].isVirtual) {\n                                    p = p && placed.get(clayer[i]);\n                                }\n                            }\n                            if (p) {\n                                order.set(prevBridge, d);\n                                const j1 = prevBridge.layerIndex;\n                                const j2 = nextBridge.layerIndex;\n                                for (let j = j1 + 1; j < j2; ++j) {\n                                    if (layer[j].isVirtual) {\n                                        order.set(layer[j], d);\n                                    }\n                                }\n                            }\n                        }\n                        prevBridge = nextBridge;\n                        prevBridgeTarget = nextBridgeTarget;\n                    }\n                }\n            }\n        }\n        getNeighborOnLayer(node, l) {\n            let neighbor = this.upNodes.get(node)[0];\n            if (neighbor.layer === l) {\n                return neighbor;\n            }\n            neighbor = this.downNodes.get(node)[0];\n            if (neighbor.layer === l) {\n                return neighbor;\n            }\n            return null;\n        }\n        _sequencer(x, virtualStart, virtualEnd, dir, sequence) {\n            if (sequence.length === 1) {\n                this._sequenceSingle(x, virtualStart, virtualEnd, dir, sequence[0]);\n            }\n            if (sequence.length > 1) {\n                const r = sequence.length, t = this.intDiv(r, 2);\n                this._sequencer(x, virtualStart, virtualEnd, dir, sequence.slice(0, t));\n                this._sequencer(x, virtualStart, virtualEnd, dir, sequence.slice(t));\n                this.combineSequences(x, virtualStart, virtualEnd, dir, sequence);\n            }\n        }\n        _sequenceSingle(x, virtualStart, virtualEnd, dir, node) {\n            const neighbors = dir === -1 ? this.downNodes.get(node) : this.upNodes.get(node);\n            const n = neighbors.length;\n            if (n !== 0) {\n                if (n % 2 === 1) {\n                    x.set(node, x.get(neighbors[this.intDiv(n, 2)]));\n                }\n                else {\n                    x.set(node, (x.get(neighbors[this.intDiv(n, 2) - 1]) + x.get(neighbors[this.intDiv(n, 2)])) / 2);\n                }\n                if (virtualStart) {\n                    x.set(node, Math.max(x.get(node), x.get(virtualStart) + this.getMinDist(virtualStart, node)));\n                }\n                if (virtualEnd) {\n                    x.set(node, Math.min(x.get(node), x.get(virtualEnd) - this.getMinDist(node, virtualEnd)));\n                }\n            }\n        }\n        combineSequences(x, virtualStart, virtualEnd, dir, sequence) {\n            const r = sequence.length, t = this.intDiv(r, 2);\n            // collect left changes\n            const leftHeap = [];\n            let i, c, n, neighbors, neighbor, pair;\n            for (i = 0; i < t; ++i) {\n                c = 0;\n                neighbors = dir === -1 ? this.downNodes.get(sequence[i]) : this.upNodes.get(sequence[i]);\n                for (n = 0; n < neighbors.length; ++n) {\n                    neighbor = neighbors[n];\n                    if (x.get(neighbor) >= x.get(sequence[i])) {\n                        c++;\n                    }\n                    else {\n                        c--;\n                        leftHeap.push({ k: x.get(neighbor) + this.getMinDist(sequence[i], sequence[t - 1]), v: 2 });\n                    }\n                }\n                leftHeap.push({ k: x.get(sequence[i]) + this.getMinDist(sequence[i], sequence[t - 1]), v: c });\n            }\n            if (virtualStart) {\n                leftHeap.push({ k: x.get(virtualStart) + this.getMinDist(virtualStart, sequence[t - 1]), v: Number.MAX_VALUE });\n            }\n            leftHeap.sort(this._positionDescendingComparer.bind(this));\n            // collect right changes\n            const rightHeap = [];\n            for (i = t; i < r; ++i) {\n                c = 0;\n                neighbors = dir === -1 ? this.downNodes.get(sequence[i]) : this.upNodes.get(sequence[i]);\n                for (n = 0; n < neighbors.length; ++n) {\n                    neighbor = neighbors[n];\n                    if (x.get(neighbor) <= x.get(sequence[i])) {\n                        c++;\n                    }\n                    else {\n                        c--;\n                        rightHeap.push({ k: x.get(neighbor) - this.getMinDist(sequence[i], sequence[t]), v: 2 });\n                    }\n                }\n                rightHeap.push({ k: x.get(sequence[i]) - this.getMinDist(sequence[i], sequence[t]), v: c });\n            }\n            if (virtualEnd) {\n                rightHeap.push({ k: x.get(virtualEnd) - this.getMinDist(virtualEnd, sequence[t]), v: Number.MAX_VALUE });\n            }\n            rightHeap.sort(this._positionAscendingComparer.bind(this));\n            let leftRes = 0, rightRes = 0;\n            const m = this.getMinDist(sequence[t - 1], sequence[t]);\n            while (x.get(sequence[t]) - x.get(sequence[t - 1]) < m) {\n                if (leftRes < rightRes) {\n                    if (leftHeap.length === 0) {\n                        x.set(sequence[t - 1], x.get(sequence[t]) - m);\n                        break;\n                    }\n                    else {\n                        pair = leftHeap.shift();\n                        leftRes = leftRes + pair.v;\n                        x.set(sequence[t - 1], pair.k);\n                        x.set(sequence[t - 1], Math.max(x.get(sequence[t - 1]), x.get(sequence[t]) - m));\n                    }\n                }\n                else {\n                    if (rightHeap.length === 0) {\n                        x.set(sequence[t], x.get(sequence[t - 1]) + m);\n                        break;\n                    }\n                    else {\n                        pair = rightHeap.shift();\n                        rightRes = rightRes + pair.v;\n                        x.set(sequence[t], pair.k);\n                        x.set(sequence[t], Math.min(x.get(sequence[t]), x.get(sequence[t - 1]) + m));\n                    }\n                }\n            }\n            for (i = t - 2; i >= 0; i--) {\n                x.set(sequence[i], Math.min(x.get(sequence[i]), x.get(sequence[t - 1]) - this.getMinDist(sequence[i], sequence[t - 1])));\n            }\n            for (i = t + 1; i < r; i++) {\n                x.set(sequence[i], Math.max(x.get(sequence[i]), x.get(sequence[t]) + this.getMinDist(sequence[i], sequence[t])));\n            }\n        }\n        placeLeft(node, leftPos, leftClass) {\n            let pos = Number.NEGATIVE_INFINITY;\n            forEach(this._getComposite(node), function (v) {\n                const leftSibling = this.leftSibling(v);\n                if (leftSibling && this.nodeLeftClass.get(leftSibling) === this.nodeLeftClass.get(v)) {\n                    if (!leftPos.containsKey(leftSibling)) {\n                        this.placeLeft(leftSibling, leftPos, leftClass);\n                    }\n                    pos = Math.max(pos, leftPos.get(leftSibling) + this.getMinDist(leftSibling, v));\n                }\n            }, this);\n            if (pos === Number.NEGATIVE_INFINITY) {\n                pos = 0;\n            }\n            forEach(this._getComposite(node), function (v) {\n                leftPos.set(v, pos);\n            });\n        }\n        placeRight(node, rightPos, rightClass) {\n            let pos = Number.POSITIVE_INFINITY;\n            forEach(this._getComposite(node), function (v) {\n                const rightSibling = this.rightSibling(v);\n                if (rightSibling && this.nodeRightClass.get(rightSibling) === this.nodeRightClass.get(v)) {\n                    if (!rightPos.containsKey(rightSibling)) {\n                        this.placeRight(rightSibling, rightPos, rightClass);\n                    }\n                    pos = Math.min(pos, rightPos.get(rightSibling) - this.getMinDist(v, rightSibling));\n                }\n            }, this);\n            if (pos === Number.POSITIVE_INFINITY) {\n                pos = 0;\n            }\n            forEach(this._getComposite(node), function (v) {\n                rightPos.set(v, pos);\n            });\n        }\n        leftSibling(node) {\n            const layer = this.layers[node.layer], layerIndex = node.layerIndex;\n            return layerIndex === 0 ? null : layer[layerIndex - 1];\n        }\n        rightSibling(node) {\n            const layer = this.layers[node.layer];\n            const layerIndex = node.layerIndex;\n            return layerIndex === layer.length - 1 ? null : layer[layerIndex + 1];\n        }\n        _getComposite(node) {\n            return node.isVirtual ? this._nodesInLink(node) : [node];\n        }\n        arrangeNodes() {\n            let i, l, ni, layer, node;\n            // Initialize node's base priority\n            for (l = 0; l < this.layers.length; l++) {\n                layer = this.layers[l];\n                for (ni = 0; ni < layer.length; ni++) {\n                    node = layer[ni];\n                    node.upstreamPriority = node.upstreamLinkCount;\n                    node.downstreamPriority = node.downstreamLinkCount;\n                }\n            }\n            // Layout is invoked after MinimizeCrossings\n            // so we may assume node's barycenters are initially correct\n            const maxLayoutIterations = 2;\n            for (let it = 0; it < maxLayoutIterations; it++) {\n                for (i = this.layers.length - 1; i >= 1; i--) {\n                    this.layoutLayer(false, i);\n                }\n                for (i = 0; i < this.layers.length - 1; i++) {\n                    this.layoutLayer(true, i);\n                }\n            }\n            // Offset the whole structure so that there are no gridPositions < 0\n            let gridPos = Number.MAX_VALUE;\n            for (l = 0; l < this.layers.length; l++) {\n                layer = this.layers[l];\n                for (ni = 0; ni < layer.length; ni++) {\n                    node = layer[ni];\n                    gridPos = Math.min(gridPos, node.gridPosition);\n                }\n            }\n            if (gridPos < 0) {\n                for (l = 0; l < this.layers.length; l++) {\n                    layer = this.layers[l];\n                    for (ni = 0; ni < layer.length; ni++) {\n                        node = layer[ni];\n                        node.gridPosition = node.gridPosition - gridPos;\n                    }\n                }\n            }\n        }\n        /// <summary>\n        /// Layout of a single layer.\n        /// </summary>\n        /// <param name=\"layerIndex\">The layer to organize.</param>\n        /// <param name=\"movingDownwards\">If set to <c>true</c> we move down in the layer stack.</param>\n        /// <seealso cref=\"OptimizeCrossings()\"/>\n        layoutLayer(down, layer) {\n            let iconsidered;\n            let considered;\n            if (down) {\n                considered = this.layers[iconsidered = layer + 1];\n            }\n            else {\n                considered = this.layers[iconsidered = layer - 1];\n            }\n            // list containing the nodes in the considered layer sorted by priority\n            const sorted = [];\n            for (let n = 0; n < considered.length; n++) {\n                sorted.push(considered[n]);\n            }\n            sorted.sort(function (n1, n2) {\n                const n1Priority = (n1.upstreamPriority + n1.downstreamPriority) / 2;\n                const n2Priority = (n2.upstreamPriority + n2.downstreamPriority) / 2;\n                if (Math.abs(n1Priority - n2Priority) < 0.0001) {\n                    return 0;\n                }\n                if (n1Priority < n2Priority) {\n                    return 1;\n                }\n                return -1;\n            });\n            // each node strives for its barycenter; high priority nodes start first\n            forEach(sorted, function (node) {\n                let nodeGridPos = node.gridPosition;\n                const nodeBaryCenter = this.calcBaryCenter(node);\n                const nodePriority = (node.upstreamPriority + node.downstreamPriority) / 2;\n                if (Math.abs(nodeGridPos - nodeBaryCenter) < 0.0001) {\n                    // This node is exactly at its barycenter -> perfect\n                    return;\n                }\n                if (Math.abs(nodeGridPos - nodeBaryCenter) < 0.25 + 0.0001) {\n                    // This node is close enough to the barycenter -> should work\n                    return;\n                }\n                if (nodeGridPos < nodeBaryCenter) {\n                    // Try to move the node to the right in an\n                    // attempt to reach its barycenter\n                    while (nodeGridPos < nodeBaryCenter) {\n                        if (!this.moveRight(node, considered, nodePriority)) {\n                            break;\n                        }\n                        nodeGridPos = node.gridPosition;\n                    }\n                }\n                else {\n                    // Try to move the node to the left in an\n                    // attempt to reach its barycenter\n                    while (nodeGridPos > nodeBaryCenter) {\n                        if (!this.moveLeft(node, considered, nodePriority)) {\n                            break;\n                        }\n                        nodeGridPos = node.gridPosition;\n                    }\n                }\n            }, this);\n            // after the layer has been rearranged we need to recalculate the barycenters\n            // of the nodes in the surrounding layers\n            if (iconsidered > 0) {\n                this.calcDownData(iconsidered - 1);\n            }\n            if (iconsidered < this.layers.length - 1) {\n                this.calcUpData(iconsidered + 1);\n            }\n        }\n        /// <summary>\n        /// Moves the node to the right and returns <c>true</c> if this was possible.\n        /// </summary>\n        /// <param name=\"node\">The node.</param>\n        /// <param name=\"layer\">The layer.</param>\n        /// <returns>Returns <c>true</c> if the shift was possible, otherwise <c>false</c>.</returns>\n        moveRight(node, layer, priority) {\n            const index = indexOf(layer, node);\n            if (index === layer.length - 1) {\n                // this is the last node in the layer, so we can move to the right without troubles\n                node.gridPosition = node.gridPosition + 0.5;\n                return true;\n            }\n            const rightNode = layer[index + 1];\n            const rightNodePriority = (rightNode.upstreamPriority + rightNode.downstreamPriority) / 2;\n            // check if there is space between the right and the current node\n            if (rightNode.gridPosition > node.gridPosition + 1) {\n                node.gridPosition = node.gridPosition + 0.5;\n                return true;\n            }\n            // we have reached a node with higher priority; no movement is allowed\n            if (rightNodePriority > priority ||\n                Math.abs(rightNodePriority - priority) < 0.0001) {\n                return false;\n            }\n            // the right node has lower priority - try to move it\n            if (this.moveRight(rightNode, layer, priority)) {\n                node.gridPosition = node.gridPosition + 0.5;\n                return true;\n            }\n            return false;\n        }\n        /// <summary>\n        /// Moves the node to the left and returns <c>true</c> if this was possible.\n        /// </summary>\n        /// <param name=\"node\">The node.</param>\n        /// <param name=\"layer\">The layer.</param>\n        /// <returns>Returns <c>true</c> if the shift was possible, otherwise <c>false</c>.</returns>\n        moveLeft(node, layer, priority) {\n            const index = indexOf(layer, node);\n            if (index === 0) {\n                // this is the last node in the layer, so we can move to the left without troubles\n                node.gridPosition = node.gridPosition - 0.5;\n                return true;\n            }\n            const leftNode = layer[index - 1];\n            const leftNodePriority = (leftNode.upstreamPriority + leftNode.downstreamPriority) / 2;\n            // check if there is space between the left and the current node\n            if (leftNode.gridPosition < node.gridPosition - 1) {\n                node.gridPosition = node.gridPosition - 0.5;\n                return true;\n            }\n            // we have reached a node with higher priority; no movement is allowed\n            if (leftNodePriority > priority ||\n                Math.abs(leftNodePriority - priority) < 0.0001) {\n                return false;\n            }\n            // The left node has lower priority - try to move it\n            if (this.moveLeft(leftNode, layer, priority)) {\n                node.gridPosition = node.gridPosition - 0.5;\n                return true;\n            }\n            return false;\n        }\n        mapVirtualNode(node, link) {\n            this.nodeToLinkMap.set(node, link);\n            if (!this.linkToNodeMap.containsKey(link)) {\n                this.linkToNodeMap.set(link, []);\n            }\n            this.linkToNodeMap.get(link).push(node);\n        }\n        _nodesInLink(node) {\n            return this.linkToNodeMap.get(this.nodeToLinkMap.get(node));\n        }\n        /// <summary>\n        /// Inserts dummy nodes to break long links.\n        /// </summary>\n        _dummify() {\n            this.linkToNodeMap = new Dictionary();\n            this.nodeToLinkMap = new Dictionary();\n            const links = this.graph.links.slice(0);\n            const layers = this.layers;\n            let layer, pos, newNode, node, r, newLink, i, l;\n            const addLinkBetweenLayers = function (upLayer, downLayer, link) {\n                layers[upLayer].linksTo[downLayer] = layers[upLayer].linksTo[downLayer] || [];\n                layers[upLayer].linksTo[downLayer].push(link);\n            };\n            for (l = 0; l < links.length; l++) {\n                const link = links[l];\n                const o = link.source;\n                const d = link.target;\n                const oLayer = o.layer;\n                const dLayer = d.layer;\n                const oPos = o.gridPosition;\n                const dPos = d.gridPosition;\n                const step = (dPos - oPos) / Math.abs(dLayer - oLayer);\n                let p = o;\n                if (oLayer - dLayer > 1) {\n                    for (i = oLayer - 1; i > dLayer; i--) {\n                        newNode = new Node();\n                        newNode.x = o.x;\n                        newNode.y = o.y;\n                        newNode.width = o.width / 100;\n                        newNode.height = o.height / 100;\n                        layer = layers[i];\n                        pos = (i - dLayer) * step + oPos;\n                        if (pos > layer.length) {\n                            pos = layer.length;\n                        }\n                        // check if origin and dest are both last\n                        if (oPos >= layers[oLayer].length - 1 &&\n                            dPos >= layers[dLayer].length - 1) {\n                            pos = layer.length;\n                        }\n                        else if (oPos === 0 && dPos === 0) { // check if origin and destination are both first\n                            pos = 0;\n                        }\n                        newNode.layer = i;\n                        newNode.uBaryCenter = 0.0;\n                        newNode.dBaryCenter = 0.0;\n                        newNode.upstreamLinkCount = 0;\n                        newNode.downstreamLinkCount = 0;\n                        newNode.gridPosition = pos;\n                        newNode.isVirtual = true;\n                        insert(layer, newNode, pos);\n                        // translate rightwards nodes' positions\n                        for (r = pos + 1; r < layer.length; r++) {\n                            node = layer[r];\n                            node.gridPosition = node.gridPosition + 1;\n                        }\n                        newLink = new Link(p, newNode);\n                        newLink.depthOfDumminess = 0;\n                        addLinkBetweenLayers(i - 1, i, newLink);\n                        p = newNode;\n                        // add the new node and the new link to the graph\n                        this.graph._addNode(newNode);\n                        this.graph.addLink(newLink);\n                        newNode.index = this.graph.nodes.length - 1;\n                        this.mapVirtualNode(newNode, link);\n                    }\n                    // set the origin of the real arrow to the last dummy\n                    addLinkBetweenLayers(dLayer - 1, dLayer, newLink);\n                    link.changeSource(p);\n                    link.depthOfDumminess = oLayer - dLayer - 1;\n                }\n                else if (oLayer - dLayer < -1) {\n                    for (i = oLayer + 1; i < dLayer; i++) {\n                        newNode = new Node();\n                        newNode.x = o.x;\n                        newNode.y = o.y;\n                        newNode.width = o.width / 100;\n                        newNode.height = o.height / 100;\n                        layer = layers[i];\n                        pos = (i - oLayer) * step + oPos;\n                        if (pos > layer.length) {\n                            pos = layer.length;\n                        }\n                        // check if origin and dest are both last\n                        if (oPos >= layers[oLayer].length - 1 &&\n                            dPos >= layers[dLayer].length - 1) {\n                            pos = layer.length;\n                        }\n                        else if (oPos === 0 && dPos === 0) { // check if origin and destination are both first\n                            pos = 0;\n                        }\n                        newNode.layer = i;\n                        newNode.uBaryCenter = 0.0;\n                        newNode.dBaryCenter = 0.0;\n                        newNode.upstreamLinkCount = 0;\n                        newNode.downstreamLinkCount = 0;\n                        newNode.gridPosition = pos;\n                        newNode.isVirtual = true;\n                        pos = Math.floor(pos); // truncates to int\n                        insert(layer, newNode, pos);\n                        // translate rightwards nodes' positions\n                        for (r = pos + 1; r < layer.length; r++) {\n                            node = layer[r];\n                            node.gridPosition = node.gridPosition + 1;\n                        }\n                        newLink = new Link(p, newNode);\n                        newLink.depthOfDumminess = 0;\n                        addLinkBetweenLayers(i - 1, i, newLink);\n                        p = newNode;\n                        // add the new node and the new link to the graph\n                        this.graph._addNode(newNode);\n                        this.graph.addLink(newLink);\n                        newNode.index = this.graph.nodes.length - 1;\n                        this.mapVirtualNode(newNode, link);\n                    }\n                    addLinkBetweenLayers(dLayer - 1, dLayer, link);\n                    // Set the origin of the real arrow to the last dummy\n                    link.changeSource(p);\n                    link.depthOfDumminess = dLayer - oLayer - 1;\n                }\n                else {\n                    addLinkBetweenLayers(oLayer, dLayer, link);\n                }\n            }\n        }\n        /// <summary>\n        /// Removes the dummy nodes inserted earlier to break long links.\n        /// </summary>\n        /// <remarks>The virtual nodes are effectively turned into intermediate connection points.</remarks>\n        _dedummify() {\n            let dedum = true;\n            while (dedum) {\n                dedum = false;\n                for (let l = 0; l < this.graph.links.length; l++) {\n                    const link = this.graph.links[l];\n                    if (!link.depthOfDumminess) {\n                        continue;\n                    }\n                    const points = [];\n                    // add points in reverse order\n                    points.unshift({ x: link.target.x, y: link.target.y });\n                    points.unshift({ x: link.source.x, y: link.source.y });\n                    // _dedummify the link\n                    let temp = link;\n                    const depthOfDumminess = link.depthOfDumminess;\n                    for (let d = 0; d < depthOfDumminess; d++) {\n                        const node = temp.source;\n                        const prevLink = node.incoming[0];\n                        points.unshift({ x: prevLink.source.x, y: prevLink.source.y });\n                        temp = prevLink;\n                    }\n                    // restore the original link origin\n                    link.changeSource(temp.source);\n                    // reset dummification flag\n                    link.depthOfDumminess = 0;\n                    // note that we only need the intermediate points, floating links have been dropped in the analysis\n                    if (points.length > 2) {\n                        // first and last are the endpoints\n                        points.splice(0, 1);\n                        points.splice(points.length - 1);\n                        link.points = points;\n                    }\n                    else {\n                        link.points = [];\n                    }\n                    // we are not going to delete the dummy elements;\n                    // they won't be needed anymore anyway.\n                    dedum = true;\n                    break;\n                }\n            }\n        }\n        /// <summary>\n        /// Optimizes/reduces the crossings between the layers by turning the crossing problem into a (combinatorial) number ordering problem.\n        /// </summary>\n        _optimizeCrossings() {\n            let moves = -1, i;\n            const maxIterations = 3;\n            let iter = 0;\n            while (moves !== 0) {\n                if (iter++ > maxIterations) {\n                    break;\n                }\n                moves = 0;\n                for (i = this.layers.length - 1; i >= 1; i--) {\n                    moves += this.optimizeLayerCrossings(false, i);\n                }\n                for (i = 0; i < this.layers.length - 1; i++) {\n                    moves += this.optimizeLayerCrossings(true, i);\n                }\n            }\n        }\n        calcUpData(layer) {\n            if (layer === 0) {\n                return;\n            }\n            const considered = this.layers[layer];\n            let i, l, link;\n            const upLayer = new Set();\n            const temp = this.layers[layer - 1];\n            for (i = 0; i < temp.length; i++) {\n                upLayer.add(temp[i]);\n            }\n            for (i = 0; i < considered.length; i++) {\n                const node = considered[i];\n                // calculate barycenter\n                let sum = 0;\n                let total = 0;\n                for (l = 0; l < node.incoming.length; l++) {\n                    link = node.incoming[l];\n                    if (upLayer.has(link.source)) {\n                        total++;\n                        sum += link.source.gridPosition;\n                    }\n                }\n                for (l = 0; l < node.outgoing.length; l++) {\n                    link = node.outgoing[l];\n                    if (upLayer.has(link.target)) {\n                        total++;\n                        sum += link.target.gridPosition;\n                    }\n                }\n                if (total > 0) {\n                    node.uBaryCenter = sum / total;\n                    node.upstreamLinkCount = total;\n                }\n                else {\n                    node.uBaryCenter = i;\n                    node.upstreamLinkCount = 0;\n                }\n            }\n        }\n        calcDownData(layer) {\n            if (layer === this.layers.length - 1) {\n                return;\n            }\n            const considered = this.layers[layer];\n            let i, l, link;\n            const downLayer = new Set();\n            const temp = this.layers[layer + 1];\n            for (i = 0; i < temp.length; i++) {\n                downLayer.add(temp[i]);\n            }\n            for (i = 0; i < considered.length; i++) {\n                const node = considered[i];\n                // calculate barycenter\n                let sum = 0;\n                let total = 0;\n                for (l = 0; l < node.incoming.length; l++) {\n                    link = node.incoming[l];\n                    if (downLayer.has(link.source)) {\n                        total++;\n                        sum += link.source.gridPosition;\n                    }\n                }\n                for (l = 0; l < node.outgoing.length; l++) {\n                    link = node.outgoing[l];\n                    if (downLayer.has(link.target)) {\n                        total++;\n                        sum += link.target.gridPosition;\n                    }\n                }\n                if (total > 0) {\n                    node.dBaryCenter = sum / total;\n                    node.downstreamLinkCount = total;\n                }\n                else {\n                    node.dBaryCenter = i;\n                    node.downstreamLinkCount = 0;\n                }\n            }\n        }\n        /// <summary>\n        /// Optimizes the crossings.\n        /// </summary>\n        /// <remarks>The big trick here is the usage of weights or values attached to connected nodes which turn a problem of crossing links\n        /// to an a problem of ordering numbers.</remarks>\n        /// <param name=\"layerIndex\">The layer index.</param>\n        /// <param name=\"movingDownwards\">If set to <c>true</c> we move down in the layer stack.</param>\n        /// <returns>The number of nodes having moved, i.e. the number of crossings reduced.</returns>\n        optimizeLayerCrossings(down, layer) {\n            let iconsidered;\n            let considered;\n            if (down) {\n                considered = this.layers[iconsidered = layer + 1];\n            }\n            else {\n                considered = this.layers[iconsidered = layer - 1];\n            }\n            // remember what it was\n            const presorted = considered.slice(0);\n            // calculate barycenters for all nodes in the considered layer\n            if (down) {\n                this.calcUpData(iconsidered);\n            }\n            else {\n                this.calcDownData(iconsidered);\n            }\n            // sort nodes within this layer according to the barycenters\n            considered.sort((n1, n2) => {\n                const n1BaryCenter = this.calcBaryCenter(n1), n2BaryCenter = this.calcBaryCenter(n2);\n                if (Math.abs(n1BaryCenter - n2BaryCenter) < 0.0001) {\n                    // in case of coinciding barycenters compare by the count of in/out links\n                    if (n1.degree() === n2.degree()) {\n                        return this.compareByIndex(n1, n2);\n                    }\n                    else if (n1.degree() < n2.degree()) {\n                        return 1;\n                    }\n                    return -1;\n                }\n                const compareValue = (n2BaryCenter - n1BaryCenter) * 1000;\n                if (compareValue > 0) {\n                    return -1;\n                }\n                else if (compareValue < 0) {\n                    return 1;\n                }\n                return this.compareByIndex(n1, n2);\n            });\n            // count relocations\n            let i, moves = 0;\n            for (i = 0; i < considered.length; i++) {\n                if (considered[i] !== presorted[i]) {\n                    moves++;\n                }\n            }\n            if (moves > 0) {\n                // now that the boxes have been arranged, update their grid positions\n                let inode = 0;\n                for (i = 0; i < considered.length; i++) {\n                    const node = considered[i];\n                    node.gridPosition = inode++;\n                }\n            }\n            return moves;\n        }\n        /// <summary>\n        /// Swaps a pair of nodes in a layer.\n        /// </summary>\n        /// <param name=\"layerIndex\">Index of the layer.</param>\n        /// <param name=\"n\">The Nth node in the layer.</param>\n        _swapPairs() {\n            const maxIterations = this.options.layeredIterations;\n            let iter = 0;\n            while (true) {\n                if (iter++ > maxIterations) {\n                    break;\n                }\n                const downwards = (iter % 4 <= 1);\n                const secondPass = (iter % 4 === 1);\n                for (let l = (downwards ? 0 : this.layers.length - 1); downwards ? l <= this.layers.length - 1 : l >= 0; l += (downwards ? 1 : -1)) {\n                    const layer = this.layers[l];\n                    let hasSwapped = false;\n                    // there is no need to recalculate crossings if they were calculated\n                    // on the previous step and nothing has changed\n                    let calcCrossings = true;\n                    let memCrossings = 0;\n                    for (let n = 0; n < layer.length - 1; n++) {\n                        // count crossings\n                        let up = 0;\n                        let down = 0;\n                        let crossBefore = 0;\n                        if (calcCrossings) {\n                            if (l !== 0) {\n                                up = this.countLinksCrossingBetweenTwoLayers(l - 1, l);\n                            }\n                            if (l !== this.layers.length - 1) {\n                                down = this.countLinksCrossingBetweenTwoLayers(l, l + 1);\n                            }\n                            if (downwards) {\n                                up *= 2;\n                            }\n                            else {\n                                down *= 2;\n                            }\n                            crossBefore = up + down;\n                        }\n                        else {\n                            crossBefore = memCrossings;\n                        }\n                        if (crossBefore === 0) {\n                            continue;\n                        }\n                        // Swap nodes\n                        let node1 = layer[n];\n                        let node2 = layer[n + 1];\n                        let node1GridPos = node1.gridPosition;\n                        let node2GridPos = node2.gridPosition;\n                        layer[n] = node2;\n                        layer[n + 1] = node1;\n                        node1.gridPosition = node2GridPos;\n                        node2.gridPosition = node1GridPos;\n                        // count crossings again and if worse than before, restore swapping\n                        up = 0;\n                        if (l !== 0) {\n                            up = this.countLinksCrossingBetweenTwoLayers(l - 1, l);\n                        }\n                        down = 0;\n                        if (l !== this.layers.length - 1) {\n                            down = this.countLinksCrossingBetweenTwoLayers(l, l + 1);\n                        }\n                        if (downwards) {\n                            up *= 2;\n                        }\n                        else {\n                            down *= 2;\n                        }\n                        const crossAfter = up + down;\n                        let revert = false;\n                        if (secondPass) {\n                            revert = crossAfter >= crossBefore;\n                        }\n                        else {\n                            revert = crossAfter > crossBefore;\n                        }\n                        if (revert) {\n                            node1 = layer[n];\n                            node2 = layer[n + 1];\n                            node1GridPos = node1.gridPosition;\n                            node2GridPos = node2.gridPosition;\n                            layer[n] = node2;\n                            layer[n + 1] = node1;\n                            node1.gridPosition = node2GridPos;\n                            node2.gridPosition = node1GridPos;\n                            // nothing has changed, remember the crossings so that\n                            // they are not calculated again on the next step\n                            memCrossings = crossBefore;\n                            calcCrossings = false;\n                        }\n                        else {\n                            hasSwapped = true;\n                            calcCrossings = true;\n                        }\n                    }\n                    if (hasSwapped) {\n                        if (l !== this.layers.length - 1) {\n                            this.calcUpData(l + 1);\n                        }\n                        if (l !== 0) {\n                            this.calcDownData(l - 1);\n                        }\n                    }\n                }\n            }\n        }\n        /// <summary>\n        /// Counts the number of links crossing between two layers.\n        /// </summary>\n        /// <param name=\"layerIndex1\">The layer index.</param>\n        /// <param name=\"layerIndex2\">Another layer index.</param>\n        /// <returns></returns>\n        countLinksCrossingBetweenTwoLayers(ulayer, dlayer) {\n            const links = this.layers[ulayer].linksTo[dlayer];\n            let link1, link2, n11, n12, n21, n22, l1, l2;\n            let crossings = 0;\n            const length = links.length;\n            for (l1 = 0; l1 < length; l1++) {\n                link1 = links[l1];\n                for (l2 = l1 + 1; l2 < length; l2++) {\n                    link2 = links[l2];\n                    if (link1.target.layer === dlayer) {\n                        n11 = link1.source;\n                        n12 = link1.target;\n                    }\n                    else {\n                        n11 = link1.target;\n                        n12 = link1.source;\n                    }\n                    if (link2.target.layer === dlayer) {\n                        n21 = link2.source;\n                        n22 = link2.target;\n                    }\n                    else {\n                        n21 = link2.target;\n                        n22 = link2.source;\n                    }\n                    const n11gp = n11.gridPosition;\n                    const n12gp = n12.gridPosition;\n                    const n21gp = n21.gridPosition;\n                    const n22gp = n22.gridPosition;\n                    if ((n11gp - n21gp) * (n12gp - n22gp) < 0) {\n                        crossings++;\n                    }\n                }\n            }\n            return crossings;\n        }\n        calcBaryCenter(node) {\n            const upstreamLinkCount = node.upstreamLinkCount;\n            const downstreamLinkCount = node.downstreamLinkCount;\n            const uBaryCenter = node.uBaryCenter;\n            const dBaryCenter = node.dBaryCenter;\n            if (upstreamLinkCount > 0 && downstreamLinkCount > 0) {\n                return (uBaryCenter + dBaryCenter) / 2;\n            }\n            if (upstreamLinkCount > 0) {\n                return uBaryCenter;\n            }\n            if (downstreamLinkCount > 0) {\n                return dBaryCenter;\n            }\n            return 0;\n        }\n        _gridPositionComparer(x, y) {\n            if (x.gridPosition < y.gridPosition) {\n                return -1;\n            }\n            if (x.gridPosition > y.gridPosition) {\n                return 1;\n            }\n            return 0;\n        }\n        _positionAscendingComparer(x, y) {\n            return x.k < y.k ? -1 : x.k > y.k ? 1 : 0;\n        }\n        _positionDescendingComparer(x, y) {\n            return x.k < y.k ? 1 : x.k > y.k ? -1 : 0;\n        }\n        _firstVirtualNode(layer) {\n            for (let c = 0; c < layer.length; c++) {\n                if (layer[c].isVirtual) {\n                    return c;\n                }\n            }\n            return -1;\n        }\n        compareByIndex(o1, o2) {\n            const i1 = o1.index;\n            const i2 = o2.index;\n            if (i1 < i2) {\n                return 1;\n            }\n            if (i1 > i2) {\n                return -1;\n            }\n            return 0;\n        }\n        intDiv(numerator, denominator) {\n            return (numerator - numerator % denominator) / denominator;\n        }\n        nextVirtualNode(layer, node) {\n            const nodeIndex = node.layerIndex;\n            for (let i = nodeIndex + 1; i < layer.length; ++i) {\n                if (layer[i].isVirtual) {\n                    return layer[i];\n                }\n            }\n            return null;\n        }\n    }\n\n    class TreeLayoutProcessor {\n        constructor(options) {\n            this.center = null;\n            this.options = options;\n        }\n        layout(treeGraph, root) {\n            this.graph = treeGraph;\n            if (!this.graph.nodes || this.graph.nodes.length === 0) {\n                return;\n            }\n            if (!contains(this.graph.nodes, root)) {\n                throw new Error('The given root is not in the graph.');\n            }\n            this.center = root;\n            this.graph.cacheRelationships();\n            /* var nonull = this.graph.nodes.where(function (n) {\n             return n.associatedShape != null;\n             });*/\n            // transfer the rects\n            /* nonull.forEach(function (n) {\n             n.Location = n.associatedShape.Position;\n             n.NodeSize = n.associatedShape.ActualBounds.ToSize();\n             }\n\n             );*/\n            // caching the children\n            /* nonull.forEach(function (n) {\n             n.children = n.getChildren();\n             });*/\n            this.layoutSwitch();\n            // apply the layout to the actual visuals\n            // nonull.ForEach(n => n.associatedShape.Position = n.Location);\n        }\n        layoutLeft(left) {\n            this.setChildrenDirection(this.center, 'Left', false);\n            this.setChildrenLayout(this.center, 'Default', false);\n            let h = 0, w = 0, y, i, node;\n            for (i = 0; i < left.length; i++) {\n                node = left[i];\n                node.TreeDirection = 'Left';\n                const s = this.measure(node, Size.Empty.bind(this));\n                w = Math.max(w, s.width);\n                h += s.height + this.options.verticalSeparation;\n            }\n            h -= this.options.verticalSeparation;\n            const x = this.center.x - this.options.horizontalSeparation;\n            y = this.center.y + ((this.center.height - h) / 2);\n            for (i = 0; i < left.length; i++) {\n                node = left[i];\n                const p = new Point(x - node.Size.width, y);\n                this.arrange(node, p);\n                y += node.Size.height + this.options.verticalSeparation;\n            }\n        }\n        layoutRight(right) {\n            this.setChildrenDirection(this.center, 'Right', false);\n            this.setChildrenLayout(this.center, 'Default', false);\n            let h = 0, w = 0, y, i, node;\n            for (i = 0; i < right.length; i++) {\n                node = right[i];\n                node.TreeDirection = 'Right';\n                const s = this.measure(node, Size.Empty.bind(this));\n                w = Math.max(w, s.width);\n                h += s.height + this.options.verticalSeparation;\n            }\n            h -= this.options.verticalSeparation;\n            const x = this.center.x + this.options.horizontalSeparation + this.center.width;\n            y = this.center.y + ((this.center.height - h) / 2);\n            for (i = 0; i < right.length; i++) {\n                node = right[i];\n                const p = new Point(x, y);\n                this.arrange(node, p);\n                y += node.Size.height + this.options.verticalSeparation;\n            }\n        }\n        layoutUp(up) {\n            this.setChildrenDirection(this.center, 'Up', false);\n            this.setChildrenLayout(this.center, 'Default', false);\n            let w = 0, y, node, i;\n            for (i = 0; i < up.length; i++) {\n                node = up[i];\n                node.TreeDirection = 'Up';\n                const s = this.measure(node, Size.Empty.bind(this));\n                w += s.width + this.options.horizontalSeparation;\n            }\n            w -= this.options.horizontalSeparation;\n            let x = this.center.x + (this.center.width / 2) - (w / 2);\n            // y = this.center.y -verticalSeparation -this.center.height/2 - h;\n            for (i = 0; i < up.length; i++) {\n                node = up[i];\n                y = this.center.y - this.options.verticalSeparation - node.Size.height;\n                const p = new Point(x, y);\n                this.arrange(node, p);\n                x += node.Size.width + this.options.horizontalSeparation;\n            }\n        }\n        layoutDown(down) {\n            let node, i;\n            this.setChildrenDirection(this.center, 'Down', false);\n            this.setChildrenLayout(this.center, 'Default', false);\n            let w = 0;\n            for (i = 0; i < down.length; i++) {\n                node = down[i];\n                node.treeDirection = 'Down';\n                const s = this.measure(node, Size.Empty.bind(this));\n                w += s.width + this.options.horizontalSeparation;\n            }\n            w -= this.options.horizontalSeparation;\n            let x = this.center.x + (this.center.width / 2) - (w / 2);\n            const y = this.center.y + this.options.verticalSeparation + this.center.height;\n            for (i = 0; i < down.length; i++) {\n                node = down[i];\n                const p = new Point(x, y);\n                this.arrange(node, p);\n                x += node.Size.width + this.options.horizontalSeparation;\n            }\n        }\n        layoutRadialTree() {\n            // var rmax = children.Aggregate(0D, (current, node) => Math.max(node.SectorAngle, current));\n            this.setChildrenDirection(this.center, 'Radial', false);\n            this.setChildrenLayout(this.center, 'Default', false);\n            this.previousRoot = null;\n            const startAngle = this.options.startRadialAngle * DEG_TO_RAD;\n            const endAngle = this.options.endRadialAngle * DEG_TO_RAD;\n            if (endAngle <= startAngle) {\n                throw new Error('Final angle should not be less than the start angle.');\n            }\n            this.maxDepth = 0;\n            this.origin = new Point(this.center.x, this.center.y);\n            this.calculateAngularWidth(this.center, 0);\n            // perform the layout\n            if (this.maxDepth > 0) {\n                this.radialLayout(this.center, this.options.radialFirstLevelSeparation, startAngle, endAngle);\n            }\n            // update properties of the root node\n            this.center.Angle = endAngle - startAngle;\n        }\n        tipOverTree(down, startFromLevel) {\n            if (isUndefined(startFromLevel)) {\n                startFromLevel = 0;\n            }\n            this.setChildrenDirection(this.center, 'Down', false);\n            this.setChildrenLayout(this.center, 'Default', false);\n            this.setChildrenLayout(this.center, 'Underneath', false, startFromLevel);\n            let w = 0, node, i;\n            for (i = 0; i < down.length; i++) {\n                node = down[i];\n                // if (node.IsSpecial) continue;\n                node.TreeDirection = 'Down';\n                const s = this.measure(node, Size.Empty.bind(this));\n                w += s.width + this.options.horizontalSeparation;\n            }\n            w -= this.options.horizontalSeparation;\n            // putting the root in the center with respect to the whole diagram is not a nice result, let's put it with respect to the first level only\n            w -= down[down.length - 1].width;\n            w += down[down.length - 1].associatedShape.bounds().width;\n            let x = this.center.x + (this.center.width / 2) - (w / 2);\n            const y = this.center.y + this.options.verticalSeparation + this.center.height;\n            for (i = 0; i < down.length; i++) {\n                node = down[i];\n                // if (node.IsSpecial) continue;\n                const p = new Point(x, y);\n                this.arrange(node, p);\n                x += node.Size.width + this.options.horizontalSeparation;\n            }\n            /*/ /let's place the special node, assuming there is only one\n             if (down.Count(n => n.IsSpecial) > 0)\n             {\n             var special = (from n in down where n.IsSpecial select n).First();\n             if (special.Children.Count > 0)\n             throw new DiagramException(\"The 'special' element should not have children.\");\n             special.Data.Location = new Point(Center.Data.Location.X + Center.AssociatedShape.BoundingRectangle.Width + this.options.HorizontalSeparation, Center.Data.Location.Y);\n             }*/\n        }\n        calculateAngularWidth(n, d) {\n            if (d > this.maxDepth) {\n                this.maxDepth = d;\n            }\n            const w = 1000, h = 1000, diameter = d === 0 ? 0 : Math.sqrt((w * w) + (h * h)) / d;\n            let aw = 0;\n            if (n.children.length > 0) {\n                // eventually with n.IsExpanded\n                for (let i = 0, len = n.children.length; i < len; i++) {\n                    const child = n.children[i];\n                    aw += this.calculateAngularWidth(child, d + 1);\n                }\n                aw = Math.max(diameter, aw);\n            }\n            else {\n                aw = diameter;\n            }\n            n.sectorAngle = aw;\n            return aw;\n        }\n        sortChildren(n) {\n            let basevalue = 0, i;\n            // update basevalue angle for node ordering\n            if (n.parents.length > 1) {\n                throw new Error('Node is not part of a tree.');\n            }\n            const p = n.parents[0];\n            if (p) {\n                const pl = new Point(p.x, p.y);\n                const nl = new Point(n.x, n.y);\n                basevalue = this.normalizeAngle(Math.atan2(pl.y - nl.y, pl.x - nl.x));\n            }\n            const count = n.children.length;\n            if (count === 0) {\n                return null;\n            }\n            const angle = [];\n            const idx = [];\n            for (i = 0; i < count; ++i) {\n                const c = n.children[i];\n                const l = new Point(c.x, c.y);\n                idx[i] = i;\n                angle[i] = this.normalizeAngle(-basevalue + Math.atan2(l.y - l.y, l.x - l.x));\n            }\n            bisort(angle, idx);\n            const col = []; // list of nodes\n            const children = n.children;\n            for (i = 0; i < count; ++i) {\n                col.push(children[idx[i]]);\n            }\n            return col;\n        }\n        normalizeAngle(angle) {\n            while (angle > Math.PI * 2) {\n                angle -= 2 * Math.PI;\n            }\n            while (angle < 0) {\n                angle += Math.PI * 2;\n            }\n            return angle;\n        }\n        radialLayout(node, radius, startAngle, endAngle) {\n            const deltaTheta = endAngle - startAngle;\n            const deltaThetaHalf = deltaTheta / 2.0;\n            const parentSector = node.sectorAngle;\n            let fraction = 0;\n            const sorted = this.sortChildren(node);\n            for (let i = 0, len = sorted.length; i < len; i++) {\n                const childNode = sorted[i];\n                const cp = childNode;\n                const childAngleFraction = cp.sectorAngle / parentSector;\n                if (childNode.children.length > 0) {\n                    this.radialLayout(childNode, radius + this.options.radialSeparation, startAngle + (fraction * deltaTheta), startAngle + ((fraction + childAngleFraction) * deltaTheta));\n                }\n                this.setPolarLocation(childNode, radius, startAngle + (fraction * deltaTheta) + (childAngleFraction * deltaThetaHalf));\n                cp.angle = childAngleFraction * deltaTheta;\n                fraction += childAngleFraction;\n            }\n        }\n        setPolarLocation(node, radius, angle) {\n            node.x = this.origin.x + (radius * Math.cos(angle));\n            node.y = this.origin.y + (radius * Math.sin(angle));\n            node.BoundingRectangle = new Rect(node.x, node.y, node.width, node.height);\n        }\n        /**\n         * Sets the children direction recursively.\n         *\n         * @param node\n         * @param direction\n         * @param includeStart\n         */\n        setChildrenDirection(node, direction, includeStart) {\n            const rootDirection = node.treeDirection;\n            this.graph.depthFirstTraversal(node, (n) => {\n                n.treeDirection = direction;\n            });\n            if (!includeStart) {\n                node.treeDirection = rootDirection;\n            }\n        }\n        /**\n         * Sets the children layout recursively.\n         *\n         * @param node\n         * @param layout\n         * @param includeStart\n         * @param startFromLevel\n         */\n        setChildrenLayout(node, layout, includeStart, startFromLevel) {\n            if (isUndefined(startFromLevel)) {\n                startFromLevel = 0;\n            }\n            const rootLayout = node.childrenLayout;\n            if (startFromLevel > 0) {\n                // assign levels to the Node.Level property\n                this.graph.assignLevels(node);\n                // assign the layout on the condition that the level is at least the 'startFromLevel'\n                this.graph.depthFirstTraversal(node, (s) => {\n                    if (s.level >= startFromLevel + 1) {\n                        s.childrenLayout = layout;\n                    }\n                });\n            }\n            else {\n                this.graph.depthFirstTraversal(node, (s) => {\n                    s.childrenLayout = layout;\n                });\n                // if the start should not be affected we put the state back\n                if (!includeStart) {\n                    node.childrenLayout = rootLayout;\n                }\n            }\n        }\n        /**\n         * Returns the actual size of the node. The given size is the allowed space wherein the node can lay out itself.\n         *\n         * @param node\n         * @param givenSize\n         * @returns {Size}\n         */\n        measure(node, givenSize) {\n            let w = 0, h = 0, s;\n            let result = new Size(0, 0);\n            if (!node) {\n                throw new Error('Node is not defined.');\n            }\n            const b = node.associatedShape.bounds();\n            const shapeWidth = b.width;\n            const shapeHeight = b.height;\n            if (node.parents.length !== 1) {\n                throw new Error('Node not in a spanning tree.');\n            }\n            const parent = node.parents[0];\n            if (node.treeDirection === 'Undefined') {\n                node.treeDirection = parent.treeDirection;\n            }\n            if (isEmpty(node.children)) {\n                result = new Size(Math.abs(shapeWidth) < EPSILON ? 50 : shapeWidth, Math.abs(shapeHeight) < EPSILON ? 25 : shapeHeight);\n            }\n            else if (node.children.length === 1) {\n                switch (node.treeDirection) {\n                    case 'Radial':\n                        s = this.measure(node.children[0], givenSize); // child size\n                        w = shapeWidth + (this.options.radialSeparation * Math.cos(node.AngleToParent)) + s.width;\n                        h = shapeHeight + Math.abs(this.options.radialSeparation * Math.sin(node.AngleToParent)) + s.height;\n                        break;\n                    case 'Left':\n                    case 'Right':\n                        switch (node.childrenLayout) {\n                            case 'TopAlignedWithParent':\n                                break;\n                            case 'BottomAlignedWithParent':\n                                break;\n                            case 'Underneath':\n                                s = this.measure(node.children[0], givenSize);\n                                w = shapeWidth + s.width + this.options.underneathHorizontalOffset;\n                                h = shapeHeight + this.options.underneathVerticalTopOffset + s.height;\n                                break;\n                            case 'Default':\n                                s = this.measure(node.children[0], givenSize);\n                                w = shapeWidth + this.options.horizontalSeparation + s.width;\n                                h = Math.max(shapeHeight, s.height);\n                                break;\n                            default:\n                                throw new Error('Unhandled TreeDirection in the Radial layout measuring.');\n                        }\n                        break;\n                    case 'Up':\n                    case 'Down':\n                        switch (node.childrenLayout) {\n                            case 'TopAlignedWithParent':\n                            case 'BottomAlignedWithParent':\n                                break;\n                            case 'Underneath':\n                                s = this.measure(node.children[0], givenSize);\n                                w = Math.max(shapeWidth, s.width + this.options.underneathHorizontalOffset);\n                                h = shapeHeight + this.options.underneathVerticalTopOffset + s.height;\n                                break;\n                            case 'Default':\n                                s = this.measure(node.children[0], givenSize);\n                                h = shapeHeight + this.options.verticalSeparation + s.height;\n                                w = Math.max(shapeWidth, s.width);\n                                break;\n                            default:\n                                throw new Error('Unhandled TreeDirection in the Down layout measuring.');\n                        }\n                        break;\n                    default:\n                        throw new Error('Unhandled TreeDirection in the layout measuring.');\n                }\n                result = new Size(w, h);\n            }\n            else {\n                let i, childNode;\n                switch (node.treeDirection) {\n                    case 'Left':\n                    case 'Right':\n                        switch (node.childrenLayout) {\n                            case 'TopAlignedWithParent':\n                            case 'BottomAlignedWithParent':\n                                break;\n                            case 'Underneath':\n                                w = shapeWidth;\n                                h = shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < node.children.length; i++) {\n                                    childNode = node.children[i];\n                                    s = this.measure(childNode, givenSize);\n                                    w = Math.max(w, s.width + this.options.underneathHorizontalOffset);\n                                    h += s.height + this.options.underneathVerticalSeparation;\n                                }\n                                h -= this.options.underneathVerticalSeparation;\n                                break;\n                            case 'Default':\n                                w = shapeWidth;\n                                h = 0;\n                                for (i = 0; i < node.children.length; i++) {\n                                    childNode = node.children[i];\n                                    s = this.measure(childNode, givenSize);\n                                    w = Math.max(w, shapeWidth + this.options.horizontalSeparation + s.width);\n                                    h += s.height + this.options.verticalSeparation;\n                                }\n                                h -= this.options.verticalSeparation;\n                                break;\n                            default:\n                                throw new Error('Unhandled TreeDirection in the Right layout measuring.');\n                        }\n                        break;\n                    case 'Up':\n                    case 'Down':\n                        switch (node.childrenLayout) {\n                            case 'TopAlignedWithParent':\n                            case 'BottomAlignedWithParent':\n                                break;\n                            case 'Underneath':\n                                w = shapeWidth;\n                                h = shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < node.children.length; i++) {\n                                    childNode = node.children[i];\n                                    s = this.measure(childNode, givenSize);\n                                    w = Math.max(w, s.width + this.options.underneathHorizontalOffset);\n                                    h += s.height + this.options.underneathVerticalSeparation;\n                                }\n                                h -= this.options.underneathVerticalSeparation;\n                                break;\n                            case 'Default':\n                                w = 0;\n                                h = 0;\n                                for (i = 0; i < node.children.length; i++) {\n                                    childNode = node.children[i];\n                                    s = this.measure(childNode, givenSize);\n                                    w += s.width + this.options.horizontalSeparation;\n                                    h = Math.max(h, s.height + this.options.verticalSeparation + shapeHeight);\n                                }\n                                w -= this.options.horizontalSeparation;\n                                break;\n                            default:\n                                throw new Error('Unhandled TreeDirection in the Down layout measuring.');\n                        }\n                        break;\n                    default:\n                        throw new Error('Unhandled TreeDirection in the layout measuring.');\n                }\n                result = new Size(w, h);\n            }\n            node.SectorAngle = Math.sqrt((w * w / 4) + (h * h / 4));\n            node.Size = result;\n            return result;\n        }\n        arrange(n, p) {\n            const b = n.associatedShape.bounds();\n            let i, pp, child, node, childrenwidth;\n            const shapeWidth = b.width;\n            const shapeHeight = b.height;\n            if (isEmpty(n.children)) {\n                n.x = p.x;\n                n.y = p.y;\n                n.BoundingRectangle = new Rect(p.x, p.y, shapeWidth, shapeHeight);\n            }\n            else {\n                let x, y;\n                let selfLocation;\n                switch (n.treeDirection) {\n                    case 'Left':\n                        switch (n.childrenLayout) {\n                            case 'TopAlignedWithParent':\n                            case 'BottomAlignedWithParent':\n                                break;\n                            case 'Underneath':\n                                selfLocation = p;\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < node.children.length; i++) {\n                                    node = node.children[i];\n                                    x = selfLocation.x - node.associatedShape.width - this.options.underneathHorizontalOffset;\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.underneathVerticalSeparation;\n                                }\n                                break;\n                            case 'Default':\n                                selfLocation = new Point(p.x + n.Size.width - shapeWidth, p.y + ((n.Size.height - shapeHeight) / 2));\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                x = selfLocation.x - this.options.horizontalSeparation; // alignment of children\n                                y = p.y;\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    pp = new Point(x - node.Size.width, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.verticalSeparation;\n                                }\n                                break;\n                            default:\n                                throw new Error('Unsupported TreeDirection');\n                        }\n                        break;\n                    case 'Right':\n                        switch (n.childrenLayout) {\n                            case 'TopAlignedWithParent':\n                            case 'BottomAlignedWithParent':\n                                break;\n                            case 'Underneath':\n                                selfLocation = p;\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                x = p.x + shapeWidth + this.options.underneathHorizontalOffset;\n                                // alignment of children left-underneath the parent\n                                y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.underneathVerticalSeparation;\n                                }\n                                break;\n                            case 'Default':\n                                selfLocation = new Point(p.x, p.y + ((n.Size.height - shapeHeight) / 2));\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                x = p.x + shapeWidth + this.options.horizontalSeparation; // alignment of children\n                                y = p.y;\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.verticalSeparation;\n                                }\n                                break;\n                            default:\n                                throw new Error('Unsupported TreeDirection');\n                        }\n                        break;\n                    case 'Up':\n                        selfLocation = new Point(p.x + ((n.Size.width - shapeWidth) / 2), p.y + n.Size.height - shapeHeight);\n                        n.x = selfLocation.x;\n                        n.y = selfLocation.y;\n                        n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                        if (Math.abs(selfLocation.x - p.x) < EPSILON) {\n                            childrenwidth = 0;\n                            // means there is an aberration due to the oversized Element with respect to the children\n                            for (i = 0; i < n.children.length; i++) {\n                                child = n.children[i];\n                                childrenwidth += child.Size.width + this.options.horizontalSeparation;\n                            }\n                            childrenwidth -= this.options.horizontalSeparation;\n                            x = p.x + ((shapeWidth - childrenwidth) / 2);\n                        }\n                        else {\n                            x = p.x;\n                        }\n                        for (i = 0; i < n.children.length; i++) {\n                            node = n.children[i];\n                            y = selfLocation.y - this.options.verticalSeparation - node.Size.height;\n                            pp = new Point(x, y);\n                            this.arrange(node, pp);\n                            x += node.Size.width + this.options.horizontalSeparation;\n                        }\n                        break;\n                    case 'Down':\n                        switch (n.childrenLayout) {\n                            case 'TopAlignedWithParent':\n                            case 'BottomAlignedWithParent':\n                                break;\n                            case 'Underneath':\n                                selfLocation = p;\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                x = p.x + this.options.underneathHorizontalOffset; // alignment of children left-underneath the parent\n                                y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.underneathVerticalSeparation;\n                                }\n                                break;\n                            case 'Default':\n                                selfLocation = new Point(p.x + ((n.Size.width - shapeWidth) / 2), p.y);\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                if (Math.abs(selfLocation.x - p.x) < EPSILON) {\n                                    childrenwidth = 0;\n                                    // means there is an aberration due to the oversized Element with respect to the children\n                                    for (i = 0; i < n.children.length; i++) {\n                                        child = n.children[i];\n                                        childrenwidth += child.Size.width + this.options.horizontalSeparation;\n                                    }\n                                    childrenwidth -= this.options.horizontalSeparation;\n                                    x = p.x + ((shapeWidth - childrenwidth) / 2);\n                                }\n                                else {\n                                    x = p.x;\n                                }\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    y = selfLocation.y + this.options.verticalSeparation + shapeHeight;\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    x += node.Size.width + this.options.horizontalSeparation;\n                                }\n                                break;\n                            default:\n                                throw new Error('Unsupported TreeDirection');\n                        }\n                        break;\n                    case 'None':\n                        break;\n                    default:\n                        throw new Error('Unsupported TreeDirection');\n                }\n            }\n        }\n        layoutSwitch() {\n            if (!this.center) {\n                return;\n            }\n            if (isEmpty(this.center.children)) {\n                return;\n            }\n            let type = this.options.subtype;\n            if (isUndefined(type)) {\n                type = 'Down';\n            }\n            let single, male, female, leftcount;\n            const children = this.center.children;\n            switch (type.toLowerCase()) {\n                case 'radial':\n                case 'radialtree':\n                    this.layoutRadialTree();\n                    break;\n                case 'mindmaphorizontal':\n                case 'mindmap':\n                    single = this.center.children;\n                    if (this.center.children.length === 1) {\n                        this.layoutRight(single);\n                    }\n                    else {\n                        // odd number will give one more at the right\n                        leftcount = children.length / 2;\n                        male = grep$1(this.center.children, function (n) {\n                            return indexOf(children, n) < leftcount;\n                        });\n                        female = grep$1(this.center.children, function (n) {\n                            return indexOf(children, n) >= leftcount;\n                        });\n                        this.layoutLeft(male);\n                        this.layoutRight(female);\n                    }\n                    break;\n                case 'mindmapvertical':\n                    single = this.center.children;\n                    if (this.center.children.length === 1) {\n                        this.layoutDown(single);\n                    }\n                    else {\n                        // odd number will give one more at the right\n                        leftcount = children.length / 2;\n                        male = grep$1(this.center.children, function (n) {\n                            return indexOf(children, n) < leftcount;\n                        });\n                        female = grep$1(this.center.children, function (n) {\n                            return indexOf(children, n) >= leftcount;\n                        });\n                        this.layoutUp(male);\n                        this.layoutDown(female);\n                    }\n                    break;\n                case 'right':\n                    this.layoutRight(this.center.children);\n                    break;\n                case 'left':\n                    this.layoutLeft(this.center.children);\n                    break;\n                case 'up':\n                case 'bottom':\n                    this.layoutUp(this.center.children);\n                    break;\n                case 'down':\n                case 'top':\n                    this.layoutDown(this.center.children);\n                    break;\n                case 'tipover':\n                case 'tipovertree':\n                    if (this.options.tipOverTreeStartLevel < 0) {\n                        throw new Error('The tip-over level should be a positive integer.');\n                    }\n                    this.tipOverTree(this.center.children, this.options.tipOverTreeStartLevel);\n                    break;\n                case 'undefined':\n                case 'none':\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n\n    /**\n     * The various tree layout algorithms.\n     *\n     * @type {*}\n     */\n    class TreeLayout extends LayoutBase {\n        constructor(diagram) {\n            super();\n            if (isUndefined(diagram)) {\n                throw new Error('No diagram specified.');\n            }\n            this.diagram = diagram;\n        }\n        /**\n         * Arranges the diagram in a tree-layout with the specified options and tree subtype.\n         */\n        layout(options) {\n            this.transferOptions(options);\n            // transform the diagram into a Graph\n            const adapter = new DiagramToHyperTreeAdapter(this.diagram);\n            /**\n             * The Graph reduction from the given diagram.\n             *\n             * @type {*}\n             */\n            this.graph = adapter.convert();\n            const finalNodeSet = this.layoutComponents();\n            // note that the graph contains the original data and\n            // the components are another instance of nodes referring to the same set of shapes\n            return new LayoutState(this.diagram, finalNodeSet);\n        }\n        layoutComponents() {\n            if (this.graph.isEmpty()) {\n                return;\n            }\n            // split into connected components\n            const components = this.graph.getConnectedComponents();\n            if (isEmpty(components)) {\n                return;\n            }\n            const layout = new TreeLayoutProcessor(this.options);\n            const trees = [];\n            // find a spanning tree for each component\n            for (let i = 0; i < components.length; i++) {\n                const component = components[i];\n                const treeGraph = this.getTree(component);\n                if (!treeGraph) {\n                    throw new Error('Failed to find a spanning tree for the component.');\n                }\n                const root = treeGraph.root;\n                const tree = treeGraph.tree;\n                layout.layout(tree, root);\n                trees.push(tree);\n            }\n            return this.gridLayoutComponents(trees);\n        }\n        /**\n         * Gets a spanning tree (and root) for the given graph.\n         * Ensure that the given graph is connected!\n         *\n         * @param graph\n         * @returns {*} A literal object consisting of the found root and the spanning tree.\n         */\n        getTree(graph) {\n            let root = null;\n            if (this.options.roots && this.options.roots.length > 0) {\n                for (let i = 0, len = graph.nodes.length; i < len; i++) {\n                    const node = graph.nodes[i];\n                    for (let j = 0; j < this.options.roots.length; j++) {\n                        const givenRootShape = this.options.roots[j];\n                        if (givenRootShape === node.associatedShape) {\n                            root = node;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!root) {\n                // finds the most probable root on the basis of the longest path in the component\n                root = graph.root();\n                // should not happen really\n                if (!root) {\n                    throw new Error('Unable to find a root for the tree.');\n                }\n            }\n            return this.getTreeForRoot(graph, root);\n        }\n        getTreeForRoot(graph, root) {\n            const tree = graph.getSpanningTree(root);\n            if (isUndefined(tree) || tree.isEmpty()) {\n                return null;\n            }\n            return {\n                tree: tree,\n                root: tree.root()\n            };\n        }\n    }\n\n    class AdornerBase {\n        constructor(diagram, options) {\n            this.diagram = diagram;\n            this.options = deepExtend({}, this.options, options);\n            this.visual = new Group();\n            this.diagram._adorners.push(this);\n        }\n        refresh() { }\n    }\n\n    class ConnectionEditUndoUnit {\n        constructor(item, undoSource, undoTarget) {\n            this.item = item;\n            this._undoSource = undoSource;\n            this._undoTarget = undoTarget;\n            this._redoSource = item.source();\n            this._redoTarget = item.target();\n            this.title = ConnectionEditing;\n        }\n        undo() {\n            this.item._updateConnector(this._undoSource, SOURCE);\n            this.item._updateConnector(this._undoTarget, TARGET);\n            this.item.updateModel();\n        }\n        redo() {\n            this.item._updateConnector(this._redoSource, SOURCE);\n            this.item._updateConnector(this._redoTarget, TARGET);\n            this.item.updateModel();\n        }\n    }\n\n    function mwDelta(e) {\n        let delta = 0;\n        if (e.wheelDelta) {\n            delta = -e.wheelDelta / 40;\n            delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n        }\n        else if (e.detail) {\n            delta = e.detail;\n        }\n        return delta;\n    }\n    function isAutoConnector(connector) {\n        return connector.options.name.toLowerCase() === AUTO.toLowerCase();\n    }\n    function closestConnector(point, connectors) {\n        let minimumDistance = MAXINT, resCtr, connector;\n        for (let i = 0; i < connectors.length; i++) {\n            connector = connectors[i];\n            if (!isAutoConnector(connector)) {\n                const dist = point.distanceTo(connector.position());\n                if (dist < minimumDistance) {\n                    minimumDistance = dist;\n                    resCtr = connector;\n                }\n            }\n        }\n        return resCtr;\n    }\n    function indicesOfItems(group, visuals) {\n        const indices = [];\n        let i, visual;\n        const children = group.drawingContainer().children;\n        const length = children.length;\n        for (i = 0; i < visuals.length; i++) {\n            visual = visuals[i];\n            for (let j = 0; j < length; j++) {\n                if (children[j] === visual.drawingContainer()) {\n                    indices.push(j);\n                    break;\n                }\n            }\n        }\n        return indices;\n    }\n    function translateToOrigin(visual) {\n        const bbox = visual.drawingContainer().clippedBBox(null);\n        if (bbox.origin.x !== 0 || bbox.origin.y !== 0) {\n            visual.position(-bbox.origin.x, -bbox.origin.y);\n        }\n    }\n    function filterShapeDataItem(dataItem) {\n        const result = {};\n        dataItem = dataItem || {};\n        if (defined(dataItem.text) && dataItem.text !== null) {\n            result.text = dataItem.text;\n        }\n        if (defined(dataItem.x) && dataItem.x !== null) {\n            result.x = dataItem.x;\n        }\n        if (defined(dataItem.y) && dataItem.y !== null) {\n            result.y = dataItem.y;\n        }\n        if (defined(dataItem.width) && dataItem.width !== null) {\n            result.width = dataItem.width;\n        }\n        if (defined(dataItem.height) && dataItem.height !== null) {\n            result.height = dataItem.height;\n        }\n        if (defined(dataItem.type) && dataItem.type !== null) {\n            result.type = dataItem.type;\n        }\n        return result;\n    }\n    function filterConnectionDataItem(dataItem) {\n        const result = {};\n        dataItem = dataItem || {};\n        if (defined(dataItem.text) && dataItem.text !== null) {\n            result.content = dataItem.text;\n        }\n        if (defined(dataItem.type) && dataItem.type !== null) {\n            result.type = dataItem.type;\n        }\n        if (defined(dataItem.from) && dataItem.from !== null) {\n            result.from = dataItem.from;\n        }\n        if (defined(dataItem.fromConnector) && dataItem.fromConnector !== null) {\n            result.fromConnector = dataItem.fromConnector;\n        }\n        if (defined(dataItem.fromX) && dataItem.fromX !== null) {\n            result.fromX = dataItem.fromX;\n        }\n        if (defined(dataItem.fromY) && dataItem.fromY !== null) {\n            result.fromY = dataItem.fromY;\n        }\n        if (defined(dataItem.to) && dataItem.to !== null) {\n            result.to = dataItem.to;\n        }\n        if (defined(dataItem.toConnector) && dataItem.toConnector !== null) {\n            result.toConnector = dataItem.toConnector;\n        }\n        if (defined(dataItem.toX) && dataItem.toX !== null) {\n            result.toX = dataItem.toX;\n        }\n        if (defined(dataItem.toY) && dataItem.toY !== null) {\n            result.toY = dataItem.toY;\n        }\n        return result;\n    }\n\n    class RotateUnit {\n        constructor(adorner, shapes, undoRotates) {\n            this.shapes = shapes;\n            this.undoRotates = undoRotates;\n            this.title = 'Rotation';\n            this.redoRotates = [];\n            this.redoAngle = adorner._angle;\n            this.adorner = adorner;\n            this.center = adorner._innerBounds.center();\n            for (let i = 0; i < this.shapes.length; i++) {\n                const shape = this.shapes[i];\n                this.redoRotates.push(shape.rotate().angle);\n            }\n        }\n        undo() {\n            let i, shape;\n            for (i = 0; i < this.shapes.length; i++) {\n                shape = this.shapes[i];\n                shape.rotate(this.undoRotates[i], this.center, false);\n                if ('layout' in shape) {\n                    shape.layout(shape);\n                }\n                shape.updateModel();\n            }\n            if (this.adorner) {\n                this.adorner._initialize();\n                this.adorner.refresh();\n            }\n        }\n        redo() {\n            let i, shape;\n            for (i = 0; i < this.shapes.length; i++) {\n                shape = this.shapes[i];\n                shape.rotate(this.redoRotates[i], this.center, false);\n                if ('layout' in shape) {\n                    shape.layout(shape);\n                }\n                shape.updateModel();\n            }\n            if (this.adorner) {\n                this.adorner._initialize();\n                this.adorner.refresh();\n            }\n        }\n    }\n\n    const defaultOptions$5 = {\n        width: 7,\n        height: 7,\n        fill: {\n            color: DEFAULT_CONNECTION_BACKGROUND\n        },\n        hover: {}\n    };\n    class Connector {\n        constructor(shape, options) {\n            this.options = deepExtend({}, defaultOptions$5, options);\n            this.connections = [];\n            this.shape = shape;\n        }\n        position() {\n            if (this.options.position) {\n                return this.options.position(this.shape);\n            }\n            else {\n                return this.shape.getPosition(this.options.name);\n            }\n        }\n        toJSON() {\n            return {\n                shapeId: this.shape.toString(),\n                connector: this.options.name\n            };\n        }\n        static parse(diagram, str) {\n            const tempStr = str.split(':'), id = tempStr[0], name = tempStr[1] || AUTO;\n            for (let i = 0; i < diagram.shapes.length; i++) {\n                const shape = diagram.shapes[i];\n                if (shape.options.id === id) {\n                    return shape.getConnector(name.trim());\n                }\n            }\n        }\n        ;\n    }\n\n    const DefaultConnectors = [{\n            name: TOP\n        }, {\n            name: BOTTOM\n        }, {\n            name: LEFT\n        }, {\n            name: RIGHT\n        }, {\n            name: AUTO,\n            position: function (shape) {\n                return shape.getPosition('center');\n            }\n        }];\n    const shapeDefaults = function (extra) {\n        const defaults = {\n            type: DEFAULT_SHAPE_TYPE,\n            path: '',\n            autoSize: true,\n            visual: null,\n            x: DEFAULT_SHAPE_POSITION,\n            y: DEFAULT_SHAPE_POSITION,\n            minWidth: DEFAULT_SHAPE_MINWIDTH,\n            minHeight: DEFAULT_SHAPE_MINHEIGHT,\n            width: DEFAULT_SHAPE_WIDTH,\n            height: DEFAULT_SHAPE_HEIGHT,\n            hover: {},\n            editable: {\n                connect: true,\n                tools: []\n            },\n            connectors: DefaultConnectors,\n            rotation: {\n                angle: 0\n            }\n        };\n        simpleExtend(defaults, extra);\n        return defaults;\n    };\n\n    const defaultOptions$4 = {\n        hover: {},\n        cursor: Cursors.grip,\n        content: {\n            align: 'center middle'\n        },\n        selectable: true,\n        serializable: true,\n        enable: true\n    };\n    class DiagramElement extends Observable {\n        constructor(options) {\n            super();\n            this.dataItem = (options || {}).dataItem;\n            this.options = deepExtend({ id: randomId() }, defaultOptions$4, options);\n            this.isSelected = false;\n            this.visual = new Group({\n                id: this.options.id,\n                autoSize: this.options.autoSize\n            });\n            this.id = this.options.id;\n            this._template();\n        }\n        _getCursor(point) {\n            if (this.adorner) {\n                return this.adorner._getCursor(point);\n            }\n            return this.options.cursor;\n        }\n        visible(value) {\n            if (isUndefined(value)) {\n                return this.visual.visible();\n            }\n            else {\n                this.visual.visible(value);\n            }\n        }\n        bounds(value) {\n            if (isUndefined(value)) {\n                return null;\n            }\n            return null;\n        }\n        refresh() {\n            this.visual.redraw();\n        }\n        position(point) {\n            this.options.x = point.x;\n            this.options.y = point.y;\n            this.visual.position(point);\n        }\n        toString() {\n            return this.options.id;\n        }\n        serialize() {\n            // the options json object describes the shape perfectly. So this object can serve as shape serialization.\n            const json = deepExtend({}, { options: this.options });\n            if (this.dataItem) {\n                json.dataItem = this.dataItem.toString();\n            }\n            return json;\n        }\n        _content(content) {\n            if (content !== undefined) {\n                const options = this.options;\n                if (isString$1(content)) {\n                    options.content.text = content;\n                }\n                else {\n                    deepExtend(options.content, content);\n                }\n                const contentOptions = options.content;\n                const contentVisual = this._contentVisual;\n                if (!contentVisual) {\n                    this._createContentVisual(contentOptions);\n                }\n                else {\n                    this._updateContentVisual(contentOptions);\n                }\n            }\n            return this.options.content.text;\n        }\n        _createContentVisual(options) {\n            if (options.text) {\n                this._contentVisual = new TextBlock(options);\n                this._contentVisual._includeInBBox = false;\n                this.visual.append(this._contentVisual);\n            }\n        }\n        _updateContentVisual(options) {\n            this._contentVisual.redraw(options);\n        }\n        _hitTest(point) {\n            const bounds = this.bounds();\n            return this.visible() && bounds.contains(point) && this.options.enable;\n        }\n        _template() {\n            if (this.options.content.template) {\n                const data = this.dataItem || {}, elementTemplate = this.options.kendoTemplate(this.options.content.template, {\n                    paramName: 'dataItem'\n                });\n                this.options.content.text = elementTemplate(data);\n            }\n        }\n        _canSelect() {\n            return this.options.selectable !== false;\n        }\n        toJSON() {\n            return {\n                id: this.options.id\n            };\n        }\n    }\n\n    class Shape extends DiagramElement {\n        constructor(options, diagram) {\n            super(options);\n            this.options = deepExtend({}, this.options, shapeDefaults(), options);\n            this.diagram = diagram;\n            this.updateOptionsFromModel();\n            options = this.options;\n            this.connectors = [];\n            this.type = options.type;\n            this.createShapeVisual();\n            this.updateBounds();\n            this.content(this.content());\n            this._createConnectors();\n        }\n        _setOptionsFromModel(model) {\n            const modelOptions = filterShapeDataItem(model || this.dataItem);\n            this.options = deepExtend({}, this.options, modelOptions);\n            this.redrawVisual();\n        }\n        updateOptionsFromModel(model, field) {\n            if (this.diagram && this.diagram._isEditable) {\n                const modelOptions = filterShapeDataItem(model || this.dataItem);\n                if (model && field) {\n                    if (!contains(['x', 'y', 'width', 'height'], field)) {\n                        if (this.options.visual) {\n                            this._redrawVisual();\n                        }\n                        else if (modelOptions.type) {\n                            this.options = deepExtend({}, this.options, modelOptions);\n                            this._redrawVisual();\n                        }\n                        if (this.options.content) {\n                            this._template();\n                            this.content(this.options.content);\n                        }\n                    }\n                    else {\n                        const bounds = this.bounds();\n                        bounds[field] = model[field];\n                        this.bounds(bounds);\n                    }\n                }\n                else {\n                    this.options = deepExtend({}, this.options, modelOptions);\n                }\n            }\n        }\n        _redrawVisual() {\n            this.visual.clear();\n            this._contentVisual = null;\n            this.options.dataItem = this.dataItem;\n            this.createShapeVisual();\n            this.updateBounds();\n        }\n        redrawVisual() {\n            this._redrawVisual();\n            if (this.options.content) {\n                this._template();\n                this.content(this.options.content);\n            }\n        }\n        updateModel(syncChanges) {\n            const diagram = this.diagram;\n            if (diagram && diagram._isEditable) {\n                diagram.updateShapeModel(this, syncChanges);\n            }\n        }\n        updateBounds() {\n            const bounds = this.visual._measure(true);\n            const options = this.options;\n            this.bounds(new Rect(options.x, options.y, bounds.width, bounds.height));\n            this._rotate();\n            this._alignContent();\n        }\n        content(content) {\n            const result = this._content(content);\n            this._alignContent();\n            return result;\n        }\n        _alignContent() {\n            const contentOptions = this.options.content || {};\n            const contentVisual = this._contentVisual;\n            if (contentVisual && contentOptions.align) {\n                const containerRect = this.visual._measure();\n                const aligner = new RectAlign(containerRect);\n                const contentBounds = contentVisual.drawingElement.bbox(null);\n                const contentRect = new Rect(0, 0, contentBounds.width(), contentBounds.height());\n                const alignedBounds = aligner.align(contentRect, contentOptions.align);\n                contentVisual.position(alignedBounds.topLeft());\n            }\n        }\n        _createConnectors() {\n            const options = this.options, length = options.connectors.length, connectorDefaults = options.connectorDefaults;\n            let connector, i;\n            for (i = 0; i < length; i++) {\n                connector = new Connector(this, deepExtend({}, connectorDefaults, options.connectors[i]));\n                this.connectors.push(connector);\n            }\n        }\n        bounds(value) {\n            let bounds;\n            if (value) {\n                if (isString$1(value)) {\n                    switch (value) {\n                        case TRANSFORMED: {\n                            bounds = this._transformedBounds();\n                            break;\n                        }\n                        case ABSOLUTE: {\n                            bounds = this._transformedBounds();\n                            const pan = this.diagram._pan;\n                            bounds.x += pan.x;\n                            bounds.y += pan.y;\n                            break;\n                        }\n                        case ROTATED: {\n                            bounds = this._rotatedBounds();\n                            break;\n                        }\n                        default: {\n                            bounds = this._bounds;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    this._setBounds(value);\n                    this._triggerBoundsChange();\n                    if (!(this.diagram && this.diagram._layouting)) {\n                        this.refreshConnections();\n                    }\n                }\n            }\n            else {\n                bounds = this._bounds;\n            }\n            return bounds;\n        }\n        _setBounds(rect) {\n            const options = this.options;\n            const topLeft = rect.topLeft();\n            const x = options.x = topLeft.x;\n            const y = options.y = topLeft.y;\n            const width = options.width = Math.max(rect.width, options.minWidth);\n            const height = options.height = Math.max(rect.height, options.minHeight);\n            this._bounds = new Rect(x, y, width, height);\n            this.visual.redraw({\n                x: x,\n                y: y,\n                width: width,\n                height: height\n            });\n        }\n        position(point) {\n            if (point) {\n                this.bounds(new Rect(point.x, point.y, this._bounds.width, this._bounds.height));\n            }\n            else {\n                return this._bounds.topLeft();\n            }\n        }\n        /**\n         * Returns a clone of this shape.\n         *\n         * @returns {Shape}\n         */\n        clone() {\n            const json = this.serialize();\n            json.options.id = randomId();\n            if (this.diagram && this.diagram._isEditable && defined(this.dataItem)) {\n                json.options.dataItem = this.diagram.options.cloneDataItem(this.dataItem);\n            }\n            return new Shape(json.options, undefined);\n        }\n        select(value) {\n            const diagram = this.diagram;\n            let selected, deselected;\n            if (isUndefined(value)) {\n                value = true;\n            }\n            if (this._canSelect()) {\n                if (this.isSelected !== value) {\n                    selected = [];\n                    deselected = [];\n                    this.isSelected = value;\n                    if (this.isSelected) {\n                        diagram._selectedItems.push(this);\n                        selected.push(this);\n                    }\n                    else {\n                        remove(diagram._selectedItems, this);\n                        deselected.push(this);\n                    }\n                    if (!diagram._internalSelection) {\n                        diagram._selectionChanged(selected, deselected);\n                    }\n                    return true;\n                }\n            }\n        }\n        rotate(angle, center, undoable) {\n            const rotate = this.visual.rotate();\n            if (angle !== undefined) {\n                if (undoable !== false && this.diagram && this.diagram.undoRedoService && angle !== rotate.angle) {\n                    this.diagram.undoRedoService.add(new RotateUnit(this.diagram._resizingAdorner, [this], [rotate.angle]), false);\n                }\n                const b = this.bounds(), sc = new Point(b.width / 2, b.height / 2);\n                let deltaAngle, newPosition;\n                if (center) {\n                    deltaAngle = angle - rotate.angle;\n                    newPosition = b.center().rotate(deltaAngle, center).minus(sc);\n                    this._rotationOffset = this._rotationOffset.plus(newPosition.minus(b.topLeft()));\n                    this.position(newPosition);\n                }\n                this.visual.rotate(angle, sc);\n                this.options.rotation.angle = angle;\n                if (this.diagram && this.diagram._connectorsAdorner) {\n                    this.diagram._connectorsAdorner.refresh();\n                }\n                this.refreshConnections();\n                if (this.diagram) {\n                    this.diagram.trigger(ITEMROTATE, { item: this });\n                }\n            }\n            return rotate;\n        }\n        connections(type) {\n            const result = [];\n            let i, j, con, cons, ctr;\n            for (i = 0; i < this.connectors.length; i++) {\n                ctr = this.connectors[i];\n                cons = ctr.connections;\n                for (j = 0, cons; j < cons.length; j++) {\n                    con = cons[j];\n                    if (type === 'out') {\n                        const source = con.source();\n                        if (source.shape && source.shape === this) {\n                            result.push(con);\n                        }\n                    }\n                    else if (type === 'in') {\n                        const target = con.target();\n                        if (target.shape && target.shape === this) {\n                            result.push(con);\n                        }\n                    }\n                    else {\n                        result.push(con);\n                    }\n                }\n            }\n            return result;\n        }\n        refreshConnections() {\n            this.connections().forEach(function (connection) {\n                connection.refresh();\n            });\n        }\n        /**\n         * Gets a connector of this shape either by the connector's supposed name or\n         * via a Point in which case the closest connector will be returned.\n         *\n         * @param nameOrPoint The name of a Connector or a Point.\n         * @returns {Connector}\n         */\n        getConnector(nameOrPoint) {\n            let i, ctr;\n            if (isString$1(nameOrPoint)) {\n                nameOrPoint = nameOrPoint.toLocaleLowerCase();\n                for (i = 0; i < this.connectors.length; i++) {\n                    ctr = this.connectors[i];\n                    if (ctr.options.name.toLocaleLowerCase() === nameOrPoint) {\n                        return ctr;\n                    }\n                }\n            }\n            else if (nameOrPoint instanceof Point) {\n                return closestConnector(nameOrPoint, this.connectors);\n            }\n            else {\n                return this.connectors.length ? this.connectors[0] : null;\n            }\n        }\n        getPosition(side) {\n            const b = this.bounds(), fnName = side.charAt(0).toLowerCase() + side.slice(1);\n            if (isFunction$1(b[fnName])) {\n                return this._transformPoint(b[fnName]());\n            }\n            return b.center();\n        }\n        redraw(options) {\n            if (options) {\n                let shapeOptions = this.options;\n                let boundsChange;\n                this.shapeVisual.redraw(this._visualOptions(options));\n                if (this._diffNumericOptions(options, [WIDTH, HEIGHT, X, Y])) {\n                    this.bounds(new Rect(shapeOptions.x, shapeOptions.y, shapeOptions.width, shapeOptions.height));\n                    boundsChange = true;\n                }\n                if (options.connectors) {\n                    shapeOptions.connectors = options.connectors;\n                    this._updateConnectors();\n                }\n                shapeOptions = deepExtend(shapeOptions, options);\n                if (options.rotation || boundsChange) {\n                    this._rotate();\n                }\n                if (shapeOptions.content) {\n                    this.content(shapeOptions.content);\n                }\n            }\n        }\n        _updateConnectors() {\n            const connections = this.connections();\n            this.connectors = [];\n            this._createConnectors();\n            let connection;\n            let source;\n            let target;\n            for (let idx = 0; idx < connections.length; idx++) {\n                connection = connections[idx];\n                source = connection.source();\n                target = connection.target();\n                if (source.shape && source.shape === this) {\n                    connection.source(this.getConnector(source.options.name) || null);\n                }\n                else if (target.shape && target.shape === this) {\n                    connection.target(this.getConnector(target.options.name) || null);\n                }\n                connection.updateModel();\n            }\n        }\n        _diffNumericOptions(options, fields) {\n            return diffNumericOptions.call(this, options, fields);\n        }\n        _visualOptions(options) {\n            return {\n                data: options.path,\n                source: options.source,\n                hover: options.hover,\n                fill: options.fill,\n                stroke: options.stroke\n            };\n        }\n        _triggerBoundsChange() {\n            if (this.diagram) {\n                this.diagram.trigger(ITEMBOUNDSCHANGE, { item: this, bounds: this._bounds.clone() }); // the trigger modifies the arguments internally.\n            }\n        }\n        _transformPoint(point) {\n            const rotate = this.rotate(), bounds = this.bounds(), tl = bounds.topLeft();\n            if (rotate.angle) {\n                point.rotate(rotate.angle, rotate.center().plus(tl));\n            }\n            return point;\n        }\n        _transformedBounds() {\n            const bounds = this.bounds(), tl = bounds.topLeft(), br = bounds.bottomRight();\n            return Rect.fromPoints(this.diagram.modelToView(tl), this.diagram.modelToView(br));\n        }\n        _rotatedBounds() {\n            const bounds = this.bounds().rotatedBounds(this.rotate().angle), tl = bounds.topLeft(), br = bounds.bottomRight();\n            return Rect.fromPoints(tl, br);\n        }\n        _rotate() {\n            const rotation = this.options.rotation;\n            if (rotation && rotation.angle) {\n                this.rotate(rotation.angle);\n            }\n            this._rotationOffset = new Point();\n        }\n        _hover(value) {\n            const options = this.options, hover = options.hover;\n            let stroke = options.stroke, fill = options.fill;\n            if (value && isDefined(hover.stroke)) {\n                stroke = deepExtend({}, stroke, hover.stroke);\n            }\n            if (value && isDefined(hover.fill)) {\n                fill = hover.fill;\n            }\n            this.shapeVisual.redraw({\n                stroke: stroke,\n                fill: fill\n            });\n            if (options.editable && options.editable.connect) {\n                this.diagram._showConnectors(this, value);\n            }\n        }\n        _hitTest(value) {\n            if (this.visible()) {\n                const bounds = this.bounds(), angle = this.rotate().angle;\n                let rotatedPoint;\n                if (value.isEmpty && !value.isEmpty()) { // rect selection\n                    return Intersect.rects(value, bounds, angle ? angle : 0);\n                }\n                else { // point\n                    rotatedPoint = value.clone().rotate(angle, bounds.center()); // cloning is important because rotate modifies the point inline.\n                    if (bounds.contains(rotatedPoint)) {\n                        return this;\n                    }\n                }\n            }\n        }\n        toJSON() {\n            return {\n                shapeId: this.options.id\n            };\n        }\n        createShapeVisual() {\n            const options = this.options;\n            const visualOptions = this._visualOptions(options);\n            const visualTemplate = options.visual;\n            const type = (options.type + '').toLocaleLowerCase();\n            let shapeVisual;\n            visualOptions.width = options.width;\n            visualOptions.height = options.height;\n            if (isFunction$1(visualTemplate)) { // custom template\n                shapeVisual = visualTemplate.call(this, options);\n            }\n            else if (visualOptions.data) {\n                shapeVisual = new Path(visualOptions);\n                translateToOrigin(shapeVisual);\n            }\n            else if (type === 'rectangle') {\n                shapeVisual = new Rectangle(visualOptions);\n            }\n            else if (type === 'circle') {\n                shapeVisual = new Circle(visualOptions);\n            }\n            else if (type === 'text') {\n                shapeVisual = new TextBlock(visualOptions);\n            }\n            else if (type === 'image') {\n                shapeVisual = new Image(visualOptions);\n            }\n            else {\n                shapeVisual = new Path(visualOptions);\n            }\n            this.shapeVisual = shapeVisual;\n            this.visual.append(this.shapeVisual);\n        }\n    }\n\n    class ConnectionEditAdorner extends AdornerBase {\n        constructor(connection, options) {\n            options = deepExtend({ handles: {} }, options);\n            super(connection.diagram, options);\n            this.connection = connection;\n            const diagram = this.connection.diagram;\n            this._ts = diagram.toolService;\n            const sp = this.connection.sourcePoint();\n            const tp = this.connection.targetPoint();\n            this.spVisual = new Circle(deepExtend(this.options.handles, { center: sp }));\n            this.epVisual = new Circle(deepExtend(this.options.handles, { center: tp }));\n            this.visual.append(this.spVisual);\n            this.visual.append(this.epVisual);\n        }\n        _getCursor() {\n            return Cursors.move;\n        }\n        start(p) {\n            this.handle = this._hitTest(p);\n            this.startPoint = p;\n            this._initialSource = this.connection.source();\n            this._initialTarget = this.connection.target();\n            switch (this.handle) {\n                case -1:\n                    if (this.connection.targetConnector) {\n                        this._ts._connectionManipulation(this.connection, this.connection.targetConnector.shape);\n                    }\n                    break;\n                case 1:\n                    if (this.connection.sourceConnector) {\n                        this._ts._connectionManipulation(this.connection, this.connection.sourceConnector.shape);\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n        move(handle, p) {\n            switch (handle) {\n                case -1:\n                    this.connection.source(p);\n                    break;\n                case 1:\n                    this.connection.target(p);\n                    break;\n                default: {\n                    const delta = p.minus(this.startPoint);\n                    this.startPoint = p;\n                    if (!this.connection.sourceConnector) {\n                        this.connection.source(this.connection.sourcePoint().plus(delta));\n                    }\n                    if (!this.connection.targetConnector) {\n                        this.connection.target(this.connection.targetPoint().plus(delta));\n                    }\n                    break;\n                }\n            }\n            this.refresh();\n            return true;\n        }\n        stop(p) {\n            const ts = this.diagram.toolService, item = ts.hoveredItem;\n            let target;\n            if (ts._hoveredConnector) {\n                target = ts._hoveredConnector._c;\n            }\n            else if (item && item instanceof Shape) {\n                target = item.getConnector(AUTO) || item.getConnector(p);\n            }\n            else {\n                target = p;\n            }\n            if (this.handle === -1) {\n                this.connection.source(target);\n            }\n            else if (this.handle === 1) {\n                this.connection.target(target);\n            }\n            this.handle = undefined;\n            this._ts._connectionManipulation();\n            return new ConnectionEditUndoUnit(this.connection, this._initialSource, this._initialTarget);\n        }\n        _hitTest(point) {\n            const sourcePoint = this.connection.sourcePoint();\n            const targetPoint = this.connection.targetPoint();\n            const radiusX = this.options.handles.width / 2 + HIT_TEST_DISTANCE;\n            const radiusY = this.options.handles.height / 2 + HIT_TEST_DISTANCE;\n            const sourcePointDistance = sourcePoint.distanceTo(point);\n            const targetPointDistance = targetPoint.distanceTo(point);\n            const sourceHandle = new Rect(sourcePoint.x, sourcePoint.y).inflate(radiusX, radiusY).contains(point);\n            const targetHandle = new Rect(targetPoint.x, targetPoint.y).inflate(radiusX, radiusY).contains(point);\n            let handle = 0;\n            if (sourceHandle && (!targetHandle || sourcePointDistance < targetPointDistance)) {\n                handle = -1;\n            }\n            else if (targetHandle && (!sourceHandle || targetPointDistance < sourcePointDistance)) {\n                handle = 1;\n            }\n            return handle;\n        }\n        refresh() {\n            this.spVisual.redraw({ center: this.diagram.modelToLayer(this.connection.sourcePoint()) });\n            this.epVisual.redraw({ center: this.diagram.modelToLayer(this.connection.targetPoint()) });\n        }\n    }\n\n    class ConnectorVisual {\n        constructor(connector) {\n            this.options = deepExtend({}, connector.options);\n            this._c = connector;\n            this.visual = new Circle(this.options);\n            this.refresh();\n        }\n        _hover(value) {\n            const options = this.options, hover = options.hover;\n            let stroke = options.stroke, fill = options.fill;\n            if (value && isDefined(hover.stroke)) {\n                stroke = deepExtend({}, stroke, hover.stroke);\n            }\n            if (value && isDefined(hover.fill)) {\n                fill = hover.fill;\n            }\n            this.visual.redraw({\n                stroke: stroke,\n                fill: fill\n            });\n        }\n        refresh() {\n            const p = this._c.shape.diagram.modelToView(this._c.position()), relative = p.minus(this._c.shape.bounds('transformed').topLeft()), value = new Rect(p.x, p.y, 0, 0);\n            value.inflate(this.options.width / 2, this.options.height / 2);\n            this._visualBounds = value;\n            this.visual.redraw({ center: new Point(relative.x, relative.y) });\n        }\n        _hitTest(p) {\n            const tp = this._c.shape.diagram.modelToView(p);\n            return this._visualBounds.contains(tp);\n        }\n    }\n\n    class ConnectorsAdorner extends AdornerBase {\n        constructor(diagram, options) {\n            super(diagram, options);\n            this._refreshHandler = (e) => {\n                if (e.item === this.shape) {\n                    this.refresh();\n                }\n            };\n        }\n        show(shape) {\n            this._visible = true;\n            this.shape = shape;\n            this.diagram.bind(ITEMBOUNDSCHANGE, this._refreshHandler);\n            this.connectors = [];\n            this._clearVisual();\n            const len = shape.connectors.length;\n            for (let i = 0; i < len; i++) {\n                const ctr = new ConnectorVisual(shape.connectors[i]);\n                this.connectors.push(ctr);\n                this.visual.append(ctr.visual);\n            }\n            this.visual.visible(true);\n            this.refresh();\n        }\n        _clearVisual() {\n            if (this.diagram._cachedTouchTarget) {\n                this._keepCachedTouchTarget();\n            }\n            else {\n                this.visual.clear();\n            }\n        }\n        _keepCachedTouchTarget() {\n            const visualChildren = this.visual.children;\n            const childrenCount = visualChildren.length;\n            const index = inArray(this.diagram._cachedTouchTarget, visualChildren);\n            for (let i = childrenCount - 1; i >= 0; i--) {\n                if (i === index) {\n                    continue;\n                }\n                this.visual.remove(visualChildren[i]);\n            }\n        }\n        destroy() {\n            this.diagram.unbind(ITEMBOUNDSCHANGE, this._refreshHandler);\n            this.shape = undefined;\n            this._visible = undefined;\n            this.visual.visible(false);\n        }\n        _hitTest(p) {\n            let ctr, i;\n            for (i = 0; i < this.connectors.length; i++) {\n                ctr = this.connectors[i];\n                if (ctr._hitTest(p)) {\n                    ctr._hover(true);\n                    this.diagram.toolService._hoveredConnector = ctr;\n                    break;\n                }\n            }\n        }\n        refresh() {\n            if (this.shape) {\n                let bounds = this.shape.bounds();\n                bounds = this.diagram.modelToLayer(bounds);\n                this.visual.position(bounds.topLeft());\n                this.connectors.forEach(function (ctr) {\n                    ctr.refresh();\n                });\n            }\n        }\n    }\n\n    function canDrag(element) {\n        const editable = element.options.editable;\n        return editable && editable.drag !== false;\n    }\n\n    /**\n     * Holds the undoredo state when performing a rotation, translation or scaling. The adorner is optional.\n     *\n     * @type {*}\n     */\n    class TransformUnit {\n        constructor(shapes, undoStates, adorner) {\n            this.shapes = shapes;\n            this.undoStates = undoStates;\n            this.title = 'Transformation';\n            this.redoStates = [];\n            this.adorner = adorner;\n            for (let i = 0; i < this.shapes.length; i++) {\n                const shape = this.shapes[i];\n                this.redoStates.push(shape.bounds());\n            }\n        }\n        undo() {\n            for (let i = 0; i < this.shapes.length; i++) {\n                const shape = this.shapes[i];\n                shape.bounds(this.undoStates[i]);\n                if ('layout' in shape) {\n                    shape.layout(shape, this.redoStates[i], this.undoStates[i]);\n                }\n                shape.updateModel();\n            }\n            if (this.adorner) {\n                this.adorner.refreshBounds();\n                this.adorner.refresh();\n            }\n        }\n        redo() {\n            for (let i = 0; i < this.shapes.length; i++) {\n                const shape = this.shapes[i];\n                shape.bounds(this.redoStates[i]);\n                // the 'layout' property, if implemented, lets the shape itself work out what to do with the new bounds\n                if ('layout' in shape) {\n                    shape.layout(shape, this.undoStates[i], this.redoStates[i]);\n                }\n                shape.updateModel();\n            }\n            if (this.adorner) {\n                this.adorner.refreshBounds();\n                this.adorner.refresh();\n            }\n        }\n    }\n\n    function hitToOppositeSide(hit, bounds) {\n        let result;\n        if (hit.x === -1 && hit.y === -1) {\n            result = bounds.bottomRight();\n        }\n        else if (hit.x === 1 && hit.y === 1) {\n            result = bounds.topLeft();\n        }\n        else if (hit.x === -1 && hit.y === 1) {\n            result = bounds.topRight();\n        }\n        else if (hit.x === 1 && hit.y === -1) {\n            result = bounds.bottomLeft();\n        }\n        else if (hit.x === 0 && hit.y === -1) {\n            result = bounds.bottom();\n        }\n        else if (hit.x === 0 && hit.y === 1) {\n            result = bounds.top();\n        }\n        else if (hit.x === 1 && hit.y === 0) {\n            result = bounds.left();\n        }\n        else if (hit.x === -1 && hit.y === 0) {\n            result = bounds.right();\n        }\n        return result;\n    }\n    const defaultOptions$3 = {\n        handles: {\n            fill: {\n                color: '#fff'\n            },\n            stroke: {\n                color: '#282828'\n            },\n            height: 7,\n            width: 7,\n            hover: {\n                fill: {\n                    color: '#282828'\n                },\n                stroke: {\n                    color: '#282828'\n                }\n            }\n        },\n        selectable: {\n            stroke: {\n                color: '#778899',\n                width: 1,\n                dashType: 'dash'\n            },\n            fill: {\n                color: TRANSPARENT\n            }\n        },\n        offset: 10\n    };\n    class ResizingAdorner extends AdornerBase {\n        constructor(diagram, options) {\n            options = deepExtend({}, defaultOptions$3, options);\n            super(diagram, options);\n            this._manipulating = false;\n            this.map = [];\n            this.shapes = [];\n            this._initSelection();\n            this._createHandles();\n            this.redraw();\n            this.diagram.bind('select', () => {\n                this._initialize();\n            });\n            this._refreshHandler = () => {\n                if (!this._internalChange) {\n                    this.refreshBounds();\n                    this.refresh();\n                }\n            };\n            this._rotatedHandler = () => {\n                if (this.shapes.length === 1) {\n                    this._angle = this.shapes[0].rotate().angle;\n                }\n                this._refreshHandler();\n            };\n            this.diagram.bind(ITEMBOUNDSCHANGE, this._refreshHandler).bind(ITEMROTATE, this._rotatedHandler);\n            this.refreshBounds();\n            this.refresh();\n        }\n        _initSelection() {\n            const diagram = this.diagram;\n            const selectable = diagram.options.selectable;\n            const options = deepExtend({}, this.options.selectable, selectable);\n            this.rect = new Rectangle(options);\n            this.visual.append(this.rect);\n        }\n        _resizable() {\n            return this.options.editable && this.options.editable.resize !== false;\n        }\n        _handleOptions() {\n            return (this.options.editable.resize || {}).handles || this.options.handles;\n        }\n        _createHandles() {\n            let handles, item, y, x;\n            if (this._resizable()) {\n                handles = this._handleOptions();\n                for (x = -1; x <= 1; x++) {\n                    for (y = -1; y <= 1; y++) {\n                        if ((x !== 0) || (y !== 0)) { // (0, 0) element, (-1, -1) top-left, (+1, +1) bottom-right\n                            item = new Rectangle(handles);\n                            item.drawingElement._hover = this._hover.bind(this);\n                            this.map.push({ x: x, y: y, visual: item });\n                            this.visual.append(item);\n                        }\n                    }\n                }\n            }\n        }\n        bounds(value) {\n            if (value) {\n                this._innerBounds = value.clone();\n                this._bounds = this.diagram.modelToLayer(value).inflate(this.options.offset, this.options.offset);\n            }\n            else {\n                return this._bounds;\n            }\n        }\n        _hitTest(p) {\n            const handlesCount = this.map.length;\n            let tp = this.diagram.modelToLayer(p), i, hit, handleBounds, handle;\n            if (this._angle) {\n                tp = tp.clone().rotate(this._angle, this._bounds.center());\n            }\n            if (this._resizable()) {\n                for (i = 0; i < handlesCount; i++) {\n                    handle = this.map[i];\n                    hit = new Point(handle.x, handle.y);\n                    handleBounds = this._getHandleBounds(hit); // local coordinates\n                    handleBounds.offset(this._bounds.x, this._bounds.y);\n                    if (handleBounds.contains(tp)) {\n                        return hit;\n                    }\n                }\n            }\n            if (this._bounds.contains(tp)) {\n                return new Point(0, 0);\n            }\n        }\n        _getHandleBounds(p) {\n            if (this._resizable()) {\n                const handles = this._handleOptions(), w = handles.width, h = handles.height, r = new Rect(0, 0, w, h);\n                if (p.x < 0) {\n                    r.x = -w / 2;\n                }\n                else if (p.x === 0) {\n                    r.x = Math.floor(this._bounds.width / 2) - w / 2;\n                }\n                else if (p.x > 0) {\n                    r.x = this._bounds.width + 1.0 - w / 2;\n                }\n                if (p.y < 0) {\n                    r.y = -h / 2;\n                }\n                else if (p.y === 0) {\n                    r.y = Math.floor(this._bounds.height / 2) - h / 2;\n                }\n                else if (p.y > 0) {\n                    r.y = this._bounds.height + 1.0 - h / 2;\n                }\n                return r;\n            }\n        }\n        _getCursor(point) {\n            let hit = this._hitTest(point);\n            if (hit && (hit.x >= -1) && (hit.x <= 1) && (hit.y >= -1) && (hit.y <= 1) && this._resizable()) {\n                const angle = this._angle;\n                if (angle) {\n                    hit.rotate(angle, new Point(0, 0));\n                    hit = new Point(Math.round(hit.x), Math.round(hit.y));\n                }\n                if (hit.x === -1 && hit.y === -1) {\n                    return 'nw-resize';\n                }\n                if (hit.x === 1 && hit.y === 1) {\n                    return 'se-resize';\n                }\n                if (hit.x === -1 && hit.y === 1) {\n                    return 'sw-resize';\n                }\n                if (hit.x === 1 && hit.y === -1) {\n                    return 'ne-resize';\n                }\n                if (hit.x === 0 && hit.y === -1) {\n                    return 'n-resize';\n                }\n                if (hit.x === 0 && hit.y === 1) {\n                    return 's-resize';\n                }\n                if (hit.x === 1 && hit.y === 0) {\n                    return 'e-resize';\n                }\n                if (hit.x === -1 && hit.y === 0) {\n                    return 'w-resize';\n                }\n            }\n            return this._manipulating ? Cursors.move : Cursors.select;\n        }\n        _initialize() {\n            let i, item;\n            const items = this.diagram.select();\n            this.shapes = [];\n            for (i = 0; i < items.length; i++) {\n                item = items[i];\n                if (item instanceof Shape) {\n                    this.shapes.push(item);\n                    item._rotationOffset = new Point();\n                }\n            }\n            this._angle = this.shapes.length === 1 ? this.shapes[0].rotate().angle : 0;\n            this._startAngle = this._angle;\n            this._rotates();\n            this._positions();\n            this.refreshBounds();\n            this.refresh();\n            this.redraw();\n        }\n        _rotates() {\n            let i, shape;\n            this.initialRotates = [];\n            for (i = 0; i < this.shapes.length; i++) {\n                shape = this.shapes[i];\n                this.initialRotates.push(shape.rotate().angle);\n            }\n        }\n        _positions() {\n            let i, shape;\n            this.initialStates = [];\n            for (i = 0; i < this.shapes.length; i++) {\n                shape = this.shapes[i];\n                this.initialStates.push(shape.bounds());\n            }\n        }\n        _hover(value, element) {\n            if (this._resizable()) {\n                const handleOptions = this._handleOptions(), hover = handleOptions.hover;\n                let stroke = handleOptions.stroke, fill = handleOptions.fill;\n                if (value && isDefined(hover.stroke)) {\n                    stroke = deepExtend({}, stroke, hover.stroke);\n                }\n                if (value && isDefined(hover.fill)) {\n                    fill = hover.fill;\n                }\n                element.stroke(stroke.color, stroke.width, stroke.opacity);\n                element.fill(fill.color, fill.opacity);\n            }\n        }\n        start(p) {\n            this._sp = p;\n            this._cp = p;\n            this._lp = p;\n            this._manipulating = true;\n            this._internalChange = true;\n            this.shapeStates = [];\n            for (let i = 0; i < this.shapes.length; i++) {\n                const shape = this.shapes[i];\n                this.shapeStates.push(shape.bounds());\n            }\n        }\n        redraw() {\n            let i, handle;\n            const visibleHandles = this._resizable();\n            for (i = 0; i < this.map.length; i++) {\n                handle = this.map[i];\n                handle.visual.visible(visibleHandles);\n            }\n        }\n        angle(value) {\n            if (defined(value)) {\n                this._angle = value;\n            }\n            return this._angle;\n        }\n        rotate() {\n            const center = this._innerBounds.center();\n            let currentAngle = this.angle();\n            this._internalChange = true;\n            for (let i = 0; i < this.shapes.length; i++) {\n                const shape = this.shapes[i];\n                currentAngle = (currentAngle + this.initialRotates[i] - this._startAngle) % 360;\n                shape.rotate(currentAngle, center);\n            }\n            this.refresh();\n        }\n        move(handle, p) {\n            let delta, dragging, dtl = new Point(), dbr = new Point(), bounds, center, shape, i, angle, newBounds, changed = 0, staticPoint, scaleX, scaleY;\n            if (handle.y === -2 && handle.x === -1) {\n                center = this._innerBounds.center();\n                this._angle = this._truncateAngle(findAngle(center, p));\n                for (i = 0; i < this.shapes.length; i++) {\n                    shape = this.shapes[i];\n                    angle = (this._angle + this.initialRotates[i] - this._startAngle) % 360;\n                    shape.rotate(angle, center);\n                    if (Object.prototype.hasOwnProperty.call(shape, 'layout')) {\n                        shape.layout(shape);\n                    }\n                    this._rotating = true;\n                }\n                this.refresh();\n            }\n            else {\n                if (this.shouldSnap()) {\n                    const thr = this._truncateDistance(p.minus(this._lp));\n                    // threshold\n                    if (thr.x === 0 && thr.y === 0) {\n                        this._cp = p;\n                        return;\n                    }\n                    delta = thr;\n                    this._lp = new Point(this._lp.x + thr.x, this._lp.y + thr.y);\n                }\n                else {\n                    delta = p.minus(this._cp);\n                }\n                if (this.isDragHandle(handle)) {\n                    dbr = dtl = delta; // dragging\n                    dragging = true;\n                }\n                else {\n                    if (this._angle) { // adjust the delta so this resizers resize in the correct direction after rotation.\n                        delta.rotate(this._angle, new Point(0, 0));\n                    }\n                    if (handle.x === -1) {\n                        dtl.x = delta.x;\n                    }\n                    else if (handle.x === 1) {\n                        dbr.x = delta.x;\n                    }\n                    if (handle.y === -1) {\n                        dtl.y = delta.y;\n                    }\n                    else if (handle.y === 1) {\n                        dbr.y = delta.y;\n                    }\n                }\n                if (!dragging) {\n                    staticPoint = hitToOppositeSide(handle, this._innerBounds);\n                    scaleX = (this._innerBounds.width + delta.x * handle.x) / this._innerBounds.width;\n                    scaleY = (this._innerBounds.height + delta.y * handle.y) / this._innerBounds.height;\n                }\n                for (i = 0; i < this.shapes.length; i++) {\n                    shape = this.shapes[i];\n                    bounds = shape.bounds();\n                    if (dragging) {\n                        if (!canDrag(shape)) {\n                            continue;\n                        }\n                        newBounds = this._displaceBounds(bounds, dtl, dbr, dragging);\n                    }\n                    else {\n                        newBounds = bounds.clone();\n                        newBounds.scale(scaleX, scaleY, staticPoint, this._innerBounds.center(), shape.rotate().angle);\n                        const newCenter = newBounds.center(); // fixes the new rotation center.\n                        newCenter.rotate(-this._angle, bounds.center());\n                        newBounds = new Rect(newCenter.x - newBounds.width / 2, newCenter.y - newBounds.height / 2, newBounds.width, newBounds.height);\n                    }\n                    if (newBounds.width >= shape.options.minWidth && newBounds.height >= shape.options.minHeight) { // if we up-size very small shape\n                        const oldBounds = bounds;\n                        shape.bounds(newBounds);\n                        if (Object.prototype.hasOwnProperty.call(shape, 'layout')) {\n                            shape.layout(shape, oldBounds, newBounds);\n                        }\n                        if (oldBounds.width !== newBounds.width || oldBounds.height !== newBounds.height) {\n                            shape.rotate(shape.rotate().angle); // forces the rotation to update it's rotation center\n                        }\n                        changed += 1;\n                    }\n                }\n                if (changed) {\n                    if (changed === i) {\n                        newBounds = this._displaceBounds(this._innerBounds, dtl, dbr, dragging);\n                        this.bounds(newBounds);\n                    }\n                    else {\n                        this.refreshBounds();\n                    }\n                    this.refresh();\n                }\n                this._positions();\n            }\n            this._cp = p;\n        }\n        isDragHandle(handle) {\n            return handle.x === 0 && handle.y === 0;\n        }\n        cancel() {\n            const shapes = this.shapes;\n            const states = this.shapeStates;\n            for (let idx = 0; idx < shapes.length; idx++) {\n                shapes[idx].bounds(states[idx]);\n            }\n            this.refreshBounds();\n            this.refresh();\n            this._manipulating = undefined;\n            this._internalChange = undefined;\n            this._rotating = undefined;\n        }\n        _truncatePositionToGuides(bounds) {\n            if (this.diagram.ruler) {\n                return this.diagram.ruler.truncatePositionToGuides(bounds);\n            }\n            return bounds;\n        }\n        _truncateSizeToGuides(bounds) {\n            if (this.diagram.ruler) {\n                return this.diagram.ruler.truncateSizeToGuides(bounds);\n            }\n            return bounds;\n        }\n        _truncateAngle(a) {\n            const snap = this.snapOptions();\n            const snapAngle = Math.max(snap.angle || DEFAULT_SNAP_ANGLE, MIN_SNAP_ANGLE);\n            return snap ? Math.floor((a % 360) / snapAngle) * snapAngle : (a % 360);\n        }\n        _truncateDistance(d) {\n            if (d instanceof Point) {\n                return new Point(this._truncateDistance(d.x), this._truncateDistance(d.y));\n            }\n            else {\n                const snap = this.snapOptions() || {};\n                const snapSize = Math.max(snap.size || DEFAULT_SNAP_SIZE, MIN_SNAP_SIZE);\n                return snap ? Math.floor(d / snapSize) * snapSize : d;\n            }\n        }\n        snapOptions() {\n            const editable = this.diagram.options.editable;\n            const snap = ((editable || {}).drag || {}).snap || {};\n            return snap;\n        }\n        shouldSnap() {\n            const editable = this.diagram.options.editable;\n            const drag = (editable || {}).drag;\n            const snap = (drag || {}).snap;\n            return editable !== false && drag !== false && snap !== false;\n        }\n        _displaceBounds(bounds, dtl, dbr, dragging) {\n            const tl = bounds.topLeft().plus(dtl), br = bounds.bottomRight().plus(dbr);\n            let newBounds = Rect.fromPoints(tl, br), newCenter;\n            if (!dragging) {\n                newCenter = newBounds.center();\n                newCenter.rotate(-this._angle, bounds.center());\n                newBounds = new Rect(newCenter.x - newBounds.width / 2, newCenter.y - newBounds.height / 2, newBounds.width, newBounds.height);\n            }\n            return newBounds;\n        }\n        stop() {\n            let unit, i, shape;\n            if (this._cp !== this._sp) {\n                if (this._rotating) {\n                    unit = new RotateUnit(this, this.shapes, this.initialRotates);\n                    this._rotating = false;\n                }\n                else if (this._diffStates()) {\n                    if (this.diagram.ruler) {\n                        for (i = 0; i < this.shapes.length; i++) {\n                            shape = this.shapes[i];\n                            let bounds = shape.bounds();\n                            bounds = this._truncateSizeToGuides(this._truncatePositionToGuides(bounds));\n                            shape.bounds(bounds);\n                            this.refreshBounds();\n                            this.refresh();\n                        }\n                    }\n                    for (i = 0; i < this.shapes.length; i++) {\n                        shape = this.shapes[i];\n                        shape.updateModel();\n                    }\n                    unit = new TransformUnit(this.shapes, this.shapeStates, this);\n                    this.diagram._syncShapeChanges();\n                }\n            }\n            this._manipulating = undefined;\n            this._internalChange = undefined;\n            this._rotating = undefined;\n            return unit;\n        }\n        _diffStates() {\n            const shapes = this.shapes;\n            const states = this.shapeStates;\n            for (let idx = 0; idx < shapes.length; idx++) {\n                if (!shapes[idx].bounds().equals(states[idx])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        refreshBounds() {\n            const bounds = this.shapes.length === 1 ?\n                this.shapes[0].bounds().clone() :\n                this.diagram.boundingBox(this.shapes, true);\n            this.bounds(bounds);\n        }\n        refresh() {\n            let b, bounds;\n            if (this.shapes.length > 0) {\n                bounds = this.bounds();\n                this.visual.visible(true);\n                this.visual.position(bounds.topLeft());\n                this.map.forEach((m) => {\n                    b = this._getHandleBounds(new Point(m.x, m.y));\n                    m.visual.position(b.topLeft());\n                });\n                this.visual.position(bounds.topLeft());\n                const center = new Point(bounds.width / 2, bounds.height / 2);\n                this.visual.rotate(this._angle, center);\n                this.rect.redraw({ width: bounds.width, height: bounds.height });\n                if (this.rotationThumb) {\n                    const thumb = this.options.editable.rotate.thumb;\n                    this._rotationThumbBounds = new Rect(bounds.center().x, bounds.y + thumb.y, 0, 0).inflate(thumb.width);\n                    this.rotationThumb.redraw({ x: bounds.width / 2 - thumb.width / 2 });\n                }\n            }\n            else {\n                this.visual.visible(false);\n            }\n        }\n    }\n\n    const defaultOptions$2 = {\n        stroke: {\n            color: '#778899',\n            width: 1,\n            dashType: 'dash'\n        },\n        fill: {\n            color: TRANSPARENT\n        }\n    };\n    class Selector {\n        constructor(diagram) {\n            const selectable = diagram.options.selectable;\n            this.options = deepExtend({}, defaultOptions$2, selectable);\n            this.visual = new Rectangle(this.options);\n            this.diagram = diagram;\n        }\n        start(p) {\n            this._sp = this._ep = p;\n            this.refresh();\n            this.diagram._adorn(this, true);\n        }\n        end() {\n            this._sp = this._ep = undefined;\n            this.diagram._adorn(this, false);\n        }\n        bounds(value) {\n            if (value) {\n                this._bounds = value;\n            }\n            return this._bounds;\n        }\n        move(p) {\n            this._ep = p;\n            this.refresh();\n        }\n        refresh() {\n            if (this._sp) {\n                const visualBounds = Rect.fromPoints(this.diagram.modelToLayer(this._sp), this.diagram.modelToLayer(this._ep));\n                this.bounds(Rect.fromPoints(this._sp, this._ep));\n                this.visual.position(visualBounds.topLeft());\n                this.visual.redraw({ height: visualBounds.height + 1, width: visualBounds.width + 1 });\n            }\n        }\n    }\n\n    /**\n     * Base class for connection routers.\n     */\n    class ConnectionRouterBase {\n        constructor() { }\n    }\n\n    /**\n     * Base class for polyline and cascading routing.\n     */\n    class LinearConnectionRouter extends ConnectionRouterBase {\n        constructor(connection) {\n            super();\n            this.connection = connection;\n        }\n        /**\n         * Hit testing for polyline paths.\n         */\n        hitTest(p) {\n            const rec = this.getBounds().inflate(HIT_TEST_DISTANCE);\n            if (!rec.contains(p)) {\n                return false;\n            }\n            return Geometry.distanceToPolyline(p, this.connection.allPoints()) < HIT_TEST_DISTANCE;\n        }\n        /**\n         * Bounds of a polyline.\n         *\n         * @returns {kendo.dataviz.diagram.Rect}\n         */\n        getBounds() {\n            const points = this.connection.allPoints(), s = points[0], e = points[points.length - 1];\n            let right = Math.max(s.x, e.x), left = Math.min(s.x, e.x), top = Math.min(s.y, e.y), bottom = Math.max(s.y, e.y);\n            for (let i = 1; i < points.length - 1; ++i) {\n                right = Math.max(right, points[i].x);\n                left = Math.min(left, points[i].x);\n                top = Math.min(top, points[i].y);\n                bottom = Math.max(bottom, points[i].y);\n            }\n            return new Rect(left, top, right - left, bottom - top);\n        }\n    }\n\n    const topLeft = 'topLeft';\n    const bottomRight = 'bottomRight';\n    class CascadingRouter extends LinearConnectionRouter {\n        constructor(connection) {\n            super(connection);\n            this.SAME_SIDE_DISTANCE_RATIO = 5;\n            this._connectorSides = [{\n                    name: TOP,\n                    axis: Y,\n                    boundsPoint: topLeft,\n                    secondarySign: 1\n                }, {\n                    name: LEFT,\n                    axis: X,\n                    boundsPoint: topLeft,\n                    secondarySign: 1\n                }, {\n                    name: BOTTOM,\n                    axis: Y,\n                    boundsPoint: bottomRight,\n                    secondarySign: -1\n                }, {\n                    name: RIGHT,\n                    axis: X,\n                    boundsPoint: bottomRight,\n                    secondarySign: -1\n                }];\n            this.connection = connection;\n        }\n        routePoints(start, end, sourceConnector, targetConnector) {\n            let result;\n            if (sourceConnector && targetConnector) {\n                result = this._connectorPoints(start, end, sourceConnector, targetConnector);\n            }\n            else {\n                result = this._floatingPoints(start, end, sourceConnector);\n            }\n            return result;\n        }\n        route() {\n            const sourceConnector = this.connection._resolvedSourceConnector;\n            const targetConnector = this.connection._resolvedTargetConnector;\n            const start = this.connection.sourcePoint();\n            const end = this.connection.targetPoint();\n            const points = this.routePoints(start, end, sourceConnector, targetConnector);\n            this.connection.points(points);\n        }\n        _connectorSide(connector, targetPoint) {\n            const position = connector.position();\n            const shapeBounds = connector.shape.bounds(ROTATED);\n            const bounds = {\n                topLeft: shapeBounds.topLeft(),\n                bottomRight: shapeBounds.bottomRight()\n            };\n            const sides = this._connectorSides;\n            let min = Number.MAX_VALUE;\n            let sideDistance;\n            let minSide;\n            let axis;\n            let side;\n            for (let idx = 0; idx < sides.length; idx++) {\n                side = sides[idx];\n                axis = side.axis;\n                sideDistance = Math.round(Math.abs(position[axis] - bounds[side.boundsPoint][axis]));\n                if (sideDistance < min) {\n                    min = sideDistance;\n                    minSide = side;\n                }\n                else if (sideDistance === min &&\n                    (position[axis] - targetPoint[axis]) * side.secondarySign > (position[minSide.axis] - targetPoint[minSide.axis]) * minSide.secondarySign) {\n                    minSide = side;\n                }\n            }\n            return minSide.name;\n        }\n        _sameSideDistance(connector) {\n            const bounds = connector.shape.bounds(ROTATED);\n            return Math.min(bounds.width, bounds.height) / this.SAME_SIDE_DISTANCE_RATIO;\n        }\n        _connectorPoints(start, end, sourceConnector, targetConnector) {\n            const sourceConnectorSide = this._connectorSide(sourceConnector, end);\n            const targetConnectorSide = this._connectorSide(targetConnector, start);\n            const deltaX = end.x - start.x;\n            const deltaY = end.y - start.y;\n            const sameSideDistance = this._sameSideDistance(sourceConnector);\n            let result = [];\n            let pointX, pointY;\n            if (sourceConnectorSide === TOP || sourceConnectorSide === BOTTOM) {\n                if (targetConnectorSide === TOP || targetConnectorSide === BOTTOM) {\n                    if (sourceConnectorSide === targetConnectorSide) {\n                        if (sourceConnectorSide === TOP) {\n                            pointY = Math.min(start.y, end.y) - sameSideDistance;\n                        }\n                        else {\n                            pointY = Math.max(start.y, end.y) + sameSideDistance;\n                        }\n                        result = [new Point(start.x, pointY), new Point(end.x, pointY)];\n                    }\n                    else {\n                        result = [new Point(start.x, start.y + deltaY / 2), new Point(end.x, start.y + deltaY / 2)];\n                    }\n                }\n                else {\n                    result = [new Point(start.x, end.y)];\n                }\n            }\n            else {\n                if (targetConnectorSide === LEFT || targetConnectorSide === RIGHT) {\n                    if (sourceConnectorSide === targetConnectorSide) {\n                        if (sourceConnectorSide === LEFT) {\n                            pointX = Math.min(start.x, end.x) - sameSideDistance;\n                        }\n                        else {\n                            pointX = Math.max(start.x, end.x) + sameSideDistance;\n                        }\n                        result = [new Point(pointX, start.y), new Point(pointX, end.y)];\n                    }\n                    else {\n                        result = [new Point(start.x + deltaX / 2, start.y), new Point(start.x + deltaX / 2, start.y + deltaY)];\n                    }\n                }\n                else {\n                    result = [new Point(end.x, start.y)];\n                }\n            }\n            return result;\n        }\n        _floatingPoints(start, end, sourceConnector) {\n            const sourceConnectorSide = sourceConnector ? this._connectorSide(sourceConnector, end) : null;\n            const cascadeStartHorizontal = this._startHorizontal(start, end, sourceConnectorSide);\n            const points = [start, start, end, end];\n            const deltaX = end.x - start.x;\n            const deltaY = end.y - start.y;\n            const length = points.length;\n            let idx = 1;\n            let shiftX;\n            let shiftY;\n            // note that this is more generic than needed for only two intermediate points.\n            for (; idx < length - 1; ++idx) {\n                if (cascadeStartHorizontal) {\n                    if (idx % 2 !== 0) {\n                        shiftX = deltaX / (length / 2);\n                        shiftY = 0;\n                    }\n                    else {\n                        shiftX = 0;\n                        shiftY = deltaY / ((length - 1) / 2);\n                    }\n                }\n                else {\n                    if (idx % 2 !== 0) {\n                        shiftX = 0;\n                        shiftY = deltaY / (length / 2);\n                    }\n                    else {\n                        shiftX = deltaX / ((length - 1) / 2);\n                        shiftY = 0;\n                    }\n                }\n                points[idx] = new Point(points[idx - 1].x + shiftX, points[idx - 1].y + shiftY);\n            }\n            // need to fix the wrong 1.5 factor of the last intermediate point\n            idx--;\n            if ((cascadeStartHorizontal && (idx % 2 !== 0)) || (!cascadeStartHorizontal && (idx % 2 === 0))) {\n                points[length - 2] = new Point(points[length - 1].x, points[length - 2].y);\n            }\n            else {\n                points[length - 2] = new Point(points[length - 2].x, points[length - 1].y);\n            }\n            return [points[1], points[2]];\n        }\n        _startHorizontal(start, end, sourceSide) {\n            let horizontal;\n            if (sourceSide !== null && (sourceSide === RIGHT || sourceSide === LEFT)) {\n                horizontal = true;\n            }\n            else {\n                horizontal = Math.abs(start.x - end.x) > Math.abs(start.y - end.y);\n            }\n            return horizontal;\n        }\n    }\n\n    /**\n     * A simple poly-linear routing which does not alter the intermediate points.\n     * Does hold the underlying hit, bounds....logic.\n     *\n     * @type {*|Object|void|extend|Zepto.extend|b.extend}\n     */\n    class PolylineRouter extends LinearConnectionRouter {\n        constructor(connection) {\n            super(connection);\n            this.connection = connection;\n        }\n        route() {\n            // just keep the points as is\n        }\n    }\n\n    class ConnectionEditTool {\n        constructor(toolService) {\n            this.toolService = toolService;\n            this.type = 'ConnectionTool';\n        }\n        tryActivate(_p, meta) {\n            const toolService = this.toolService, diagram = toolService.diagram, selectable = diagram.options.selectable, item = toolService.hoveredItem, isActive = selectable !== false &&\n                item && item.path && !(item.isSelected && meta.ctrlKey);\n            if (isActive) {\n                this._c = item;\n            }\n            return isActive;\n        }\n        start(p, meta) {\n            const toolService = this.toolService;\n            const connection = this._c;\n            toolService.selectSingle(connection, meta);\n            const adorner = connection.adorner;\n            let handle, name;\n            if (adorner) {\n                handle = adorner._hitTest(p);\n                name = HANDLE_NAMES[handle];\n            }\n            if (canDrag(connection) && adorner && !toolService.diagram.trigger(DRAG_START, { shapes: [], connections: [connection], connectionHandle: name })) {\n                this.handle = handle;\n                this.handleName = name;\n                adorner.start(p);\n            }\n            else {\n                toolService.startPoint = p;\n                toolService.end(p);\n            }\n        }\n        move(p) {\n            const adorner = this._c.adorner;\n            if (canDrag(this._c) && adorner) {\n                adorner.move(this.handle, p);\n                this.toolService.diagram.trigger(DRAG, { shapes: [], connections: [this._c], connectionHandle: this.handleName });\n                return true;\n            }\n        }\n        end(p) {\n            const connection = this._c;\n            const adorner = connection.adorner;\n            const toolService = this.toolService;\n            const diagram = toolService.diagram;\n            if (adorner) {\n                if (canDrag(connection)) {\n                    const unit = adorner.stop(p);\n                    if (!diagram.trigger(DRAG_END, { shapes: [], connections: [connection], connectionHandle: this.handleName })) {\n                        diagram.undoRedoService.add(unit, false);\n                        connection.updateModel();\n                        diagram._syncConnectionChanges();\n                    }\n                    else {\n                        unit.undo();\n                    }\n                }\n            }\n        }\n        getCursor() {\n            return Cursors.move;\n        }\n    }\n\n    class ConnectionTool {\n        constructor(toolService) {\n            this.toolService = toolService;\n            this.type = 'ConnectionTool';\n        }\n        tryActivate() {\n            return this.toolService._hoveredConnector;\n        }\n        start(p, meta) {\n            const toolService = this.toolService, diagram = toolService.diagram, connector = toolService._hoveredConnector, connection = diagram._createConnection({}, connector._c, p);\n            if (canDrag(connection) && !diagram.trigger(DRAG_START, { shapes: [], connections: [connection], connectionHandle: TARGET }) && diagram._addConnection(connection)) {\n                toolService._connectionManipulation(connection, connector._c.shape, true);\n                toolService._removeHover();\n                toolService.selectSingle(toolService.activeConnection, meta);\n                if (meta.type === 'touchmove') {\n                    diagram._cachedTouchTarget = connector.visual;\n                }\n            }\n            else {\n                connection.source(null);\n                toolService.end(p);\n            }\n        }\n        move(p) {\n            const toolService = this.toolService;\n            const connection = toolService.activeConnection;\n            connection.target(p);\n            toolService.diagram.trigger(DRAG, { shapes: [], connections: [connection], connectionHandle: TARGET });\n            return true;\n        }\n        end(p) {\n            const toolService = this.toolService, diagram = toolService.diagram, connection = toolService.activeConnection, hoveredItem = toolService.hoveredItem, connector = toolService._hoveredConnector, cachedTouchTarget = diagram._cachedTouchTarget;\n            let target;\n            if (!connection) {\n                return;\n            }\n            if (connector && connector._c !== connection.sourceConnector) {\n                target = connector._c;\n            }\n            else if (hoveredItem && hoveredItem instanceof Shape) {\n                target = hoveredItem.getConnector(AUTO) || hoveredItem.getConnector(p);\n            }\n            else {\n                target = p;\n            }\n            connection.target(target);\n            if (!diagram.trigger(DRAG_END, { shapes: [], connections: [connection], connectionHandle: TARGET })) {\n                connection.updateModel();\n                diagram._syncConnectionChanges();\n            }\n            else {\n                diagram.remove(connection, false);\n                diagram.undoRedoService.pop();\n            }\n            toolService._connectionManipulation();\n            if (cachedTouchTarget) {\n                diagram._connectorsAdorner.visual.remove(cachedTouchTarget);\n                diagram._cachedTouchTarget = null;\n            }\n        }\n        getCursor() {\n            return Cursors.arrow;\n        }\n    }\n\n    class EmptyTool {\n        constructor(toolService) {\n            this.toolService = toolService;\n        }\n        start() {\n        }\n        move() {\n        }\n        end() {\n        }\n        tryActivate() {\n            return false;\n        }\n        getCursor() {\n            return Cursors.arrow;\n        }\n    }\n\n    function noMeta(meta) {\n        return meta.ctrlKey === false && meta.altKey === false && meta.shiftKey === false;\n    }\n\n    /**\n     * The tool handling the transformations via the adorner.\n     *\n     * @type {*}\n     */\n    class PointerTool {\n        constructor(toolService) {\n            this.toolService = toolService;\n        }\n        tryActivate() {\n            return true; // the pointer tool is last and handles all others requests.\n        }\n        start(p, meta) {\n            const toolService = this.toolService, diagram = toolService.diagram, hoveredItem = toolService.hoveredItem;\n            if (hoveredItem) {\n                toolService.selectSingle(hoveredItem, meta);\n                if (hoveredItem.adorner) { // connection\n                    this.adorner = hoveredItem.adorner;\n                    this.handle = this.adorner._hitTest(p);\n                }\n            }\n            if (!this.handle) {\n                this.handle = diagram._resizingAdorner._hitTest(p);\n                if (this.handle) {\n                    this.adorner = diagram._resizingAdorner;\n                }\n            }\n            if (this.adorner) {\n                if (!this.adorner.isDragHandle(this.handle) || !diagram.trigger(DRAG_START, { shapes: this.adorner.shapes, connections: [] })) {\n                    this.adorner.start(p);\n                }\n                else {\n                    toolService.startPoint = p;\n                    toolService.end(p);\n                }\n            }\n        }\n        move(p) {\n            if (this.adorner) {\n                this.adorner.move(this.handle, p);\n                if (this.adorner.isDragHandle(this.handle)) {\n                    this.toolService.diagram.trigger(DRAG, { shapes: this.adorner.shapes, connections: [] });\n                }\n            }\n        }\n        end() {\n            const diagram = this.toolService.diagram, adorner = this.adorner;\n            let unit;\n            if (adorner) {\n                if (!adorner.isDragHandle(this.handle) || !diagram.trigger(DRAG_END, { shapes: adorner.shapes, connections: [] })) {\n                    unit = adorner.stop();\n                    if (unit) {\n                        diagram.undoRedoService.add(unit, false);\n                    }\n                }\n                else {\n                    adorner.cancel();\n                }\n            }\n            this.adorner = undefined;\n            this.handle = undefined;\n        }\n        getCursor(p) {\n            return this.toolService.hoveredItem ? this.toolService.hoveredItem._getCursor(p) : Cursors.arrow;\n        }\n    }\n\n    const eventMap = {\n        down: 'pointerdown',\n        move: 'pointermove',\n        up: 'pointerup',\n        cancel: 'pointercancel pointerleave'\n    };\n    function queryEventMap(e) {\n        return eventMap[e] || e;\n    }\n    const applyEventMap = (events) => {\n        const eventRegEx = /([^ ]+)/g;\n        const appliedEvents = events.replace(eventRegEx, queryEventMap);\n        return appliedEvents;\n    };\n\n    function getSupportedFeatures() {\n        const os = detectOS(navigator.userAgent);\n        const support = {};\n        support.mobileOS = os;\n        return support;\n    }\n    function detectOS(ua) {\n        let os = false;\n        const agentRxs = {\n            wp: /(Windows Phone(?: OS)?)\\s(\\d+)\\.(\\d+(\\.\\d+)?)/,\n            fire: /(Silk)\\/(\\d+)\\.(\\d+(\\.\\d+)?)/,\n            android: /(Android|Android.*(?:Opera|Firefox).*?\\/)\\s*(\\d+)\\.?(\\d+(\\.\\d+)?)?/,\n            iphone: /(iPhone|iPod).*OS\\s+(\\d+)[._]([\\d._]+)/,\n            ipad: /(iPad).*OS\\s+(\\d+)[._]([\\d_]+)/,\n            playbook: /(PlayBook).*?Tablet\\s*OS\\s*(\\d+)\\.(\\d+(\\.\\d+)?)/,\n            windows: /(MSIE)\\s+(\\d+)\\.(\\d+(\\.\\d+)?)/,\n            tizen: /(tizen).*?Version\\/(\\d+)\\.(\\d+(\\.\\d+)?)/i,\n            sailfish: /(sailfish).*rv:(\\d+)\\.(\\d+(\\.\\d+)?).*firefox/i\n        }, osRxs = {\n            ios: /^i(phone|pad|pod)$/i,\n            android: /^android|fire$/i,\n            windows: /windows/,\n            wp: /wp/,\n            flat: /sailfish|ffos|tizen/i\n        };\n        for (const agent in agentRxs) {\n            if (!Object.prototype.hasOwnProperty.call(agentRxs, agent)) {\n                continue;\n            }\n            const match = ua.match(agentRxs[agent]);\n            if (match) {\n                if (agent === 'windows' && 'plugins' in navigator) {\n                    return false;\n                } // Break if not Metro/Mobile Windows\n                os = {};\n                os.device = agent;\n                os.name = testRegex(agent, osRxs);\n                os[os.name] = true;\n                break;\n            }\n        }\n        return os;\n    }\n    function testRegex(agent, regexes, dflt) {\n        for (const regex in regexes) {\n            if (regexes[regex].test(agent)) {\n                return regex;\n            }\n        }\n        return dflt !== undefined ? dflt : agent;\n    }\n\n    const extend$1 = Object.assign;\n    const now = () => {\n        return new Date().getTime();\n    };\n    const addClass = (element, className) => {\n        element.classList.add(className);\n    };\n    const convertToHtml = (html) => {\n        const div = document.createElement('div');\n        div.innerHTML = html;\n        return div.firstChild;\n    };\n    const appendHtml = (html, element) => {\n        const div = document.createElement('div');\n        div.innerHTML = html;\n        // use childNodes instead of children\n        // to cover text nodes as well\n        while (div.childNodes.length > 0) {\n            element.appendChild(div.childNodes[0]);\n        }\n    };\n    const removeChildren = (element) => {\n        while (element.firstChild) {\n            element.removeChild(element.firstChild);\n        }\n    };\n    const prepend = (element, originElement) => {\n        originElement.insertBefore(element, originElement.firstChild);\n    };\n    const wrapInner = (parent, wrapper) => {\n        parent.appendChild(wrapper);\n        while (parent.firstChild !== wrapper) {\n            wrapper.appendChild(parent.firstChild);\n        }\n    };\n    const toHyphens = (str) => {\n        const result = str.replace(/([a-z][A-Z])/g, function (g) {\n            return g.charAt(0) + '-' + g.charAt(1).toLowerCase();\n        });\n        return result;\n    };\n    const toPixels = (value) => {\n        let result;\n        if (value && String(value).endsWith('px')) {\n            result = value;\n        }\n        else {\n            result = String(value) + 'px';\n        }\n        return result;\n    };\n    const hasNativeScrolling = () => {\n        const { mobileOS } = getSupportedFeatures();\n        return mobileOS.ios || mobileOS.android;\n    };\n    const wheelDeltaY = (e) => {\n        const deltaY = e.wheelDeltaY;\n        let delta;\n        if (e.wheelDelta) { // Webkit and IE\n            if (deltaY === undefined || deltaY) { // IE does not have deltaY, thus always scroll (horizontal scrolling is treated as vertical)\n                delta = e.wheelDelta;\n            }\n        }\n        else if (e.detail && e.axis === e.VERTICAL_AXIS) { // Firefox and Opera\n            delta = (-e.detail) * 10;\n        }\n        return delta;\n    };\n    const renderPos = (pos) => {\n        const result = [];\n        if (pos) {\n            const parts = toHyphens(pos).split('-');\n            for (let i = 0; i < parts.length; i++) {\n                result.push('k-pos-' + parts[i]);\n            }\n        }\n        return result.join(' ');\n    };\n\n    const elementOffset$1 = kendo_drawing_cmn_chunk_js.w;\n    const translate = function (x, y, scale) {\n        return 'translate3d(' + x + 'px,' + y + 'px,0) scale(' + scale + ')';\n    };\n    class TapCapture extends Observable {\n        constructor(element, options) {\n            super();\n            const domElement = element[0] || element;\n            this.element = domElement;\n            this.capture = false;\n            this._pressHandler = this._press.bind(this);\n            this._releaseHandler = this._release.bind(this);\n            eventMap.down.split(' ').forEach((event) => {\n                domElement.addEventListener(event, this._pressHandler, true);\n            });\n            eventMap.up.split(' ').forEach((event) => {\n                domElement.addEventListener(event, this._releaseHandler, true);\n            });\n            this.bind([\n                'press',\n                'release'\n            ], options || {});\n        }\n        captureNext() {\n            this.capture = true;\n        }\n        cancelCapture() {\n            this.capture = false;\n        }\n        _press(e) {\n            this.trigger('press');\n            if (this.capture) {\n                e.preventDefault();\n            }\n        }\n        _release(e) {\n            this.trigger('release');\n            if (this.capture) {\n                e.preventDefault();\n                this.cancelCapture();\n            }\n        }\n        destroy() {\n            const domElement = this.element;\n            eventMap.down.split(' ').forEach((event) => {\n                domElement.removeEventListener(event, this._pressHandler, true);\n            });\n            eventMap.up.split(' ').forEach((event) => {\n                domElement.removeEventListener(event, this._releaseHandler, true);\n            });\n        }\n    }\n    class PaneDimension extends Observable {\n        constructor(options) {\n            super();\n            this.forcedEnabled = false;\n            extend$1(this, options);\n            this.scale = 1;\n            if (this.horizontal) {\n                this.measure = 'offsetWidth';\n                this.scrollSize = 'scrollWidth';\n                this.axis = 'x';\n            }\n            else {\n                this.measure = 'offsetHeight';\n                this.scrollSize = 'scrollHeight';\n                this.axis = 'y';\n            }\n        }\n        makeVirtual() {\n            extend$1(this, {\n                virtual: true,\n                forcedEnabled: true,\n                _virtualMin: 0,\n                _virtualMax: 0\n            });\n        }\n        virtualSize(min, max) {\n            if (this._virtualMin !== min || this._virtualMax !== max) {\n                this._virtualMin = min;\n                this._virtualMax = max;\n                this.update();\n            }\n        }\n        outOfBounds(offset) {\n            return offset > this.max || offset < this.min;\n        }\n        forceEnabled() {\n            this.forcedEnabled = true;\n        }\n        getSize() {\n            return this.container[this.measure];\n        }\n        getTotal() {\n            return this.element[this.scrollSize];\n        }\n        rescale(scale) {\n            this.scale = scale;\n        }\n        update(silent) {\n            const total = this.virtual ? this._virtualMax : this.getTotal(), scaledTotal = total * this.scale, size = this.getSize();\n            if (total === 0 && !this.forcedEnabled) {\n                return;\n            }\n            this.max = this.virtual ? -this._virtualMin : 0;\n            this.size = size;\n            this.total = scaledTotal;\n            this.min = Math.min(this.max, size - scaledTotal);\n            this.minScale = size / total;\n            this.centerOffset = (scaledTotal - size) / 2;\n            this.enabled = this.forcedEnabled || scaledTotal > size;\n            if (!silent) {\n                this.trigger(CHANGE$1, this);\n            }\n        }\n    }\n    class PaneDimensions extends Observable {\n        constructor(options) {\n            super();\n            this.x = new PaneDimension(extend$1({\n                horizontal: true\n            }, options));\n            this.y = new PaneDimension(extend$1({\n                horizontal: false\n            }, options));\n            this.container = options.container;\n            this.forcedMinScale = options.minScale;\n            this.maxScale = options.maxScale || 100;\n            this.bind(CHANGE$1, options);\n        }\n        rescale(newScale) {\n            this.x.rescale(newScale);\n            this.y.rescale(newScale);\n            this.refresh();\n        }\n        centerCoordinates() {\n            return {\n                x: Math.min(0, -this.x.centerOffset),\n                y: Math.min(0, -this.y.centerOffset)\n            };\n        }\n        refresh() {\n            this.x.update();\n            this.y.update();\n            this.enabled = this.x.enabled || this.y.enabled;\n            this.minScale = this.forcedMinScale || Math.min(this.x.minScale, this.y.minScale);\n            this.fitScale = Math.max(this.x.minScale, this.y.minScale);\n            this.trigger(CHANGE$1);\n        }\n    }\n    class PaneAxis extends Observable {\n        constructor(options) {\n            super();\n            extend$1(this, options);\n        }\n        outOfBounds() {\n            return this.dimension.outOfBounds(this.movable[this.axis]);\n        }\n        dragMove(delta) {\n            const dimension = this.dimension, axis = this.axis, movable = this.movable, position = movable[axis] + delta;\n            if (!dimension.enabled) {\n                return;\n            }\n            let dragDelta = delta;\n            if (position < dimension.min && delta < 0 || position > dimension.max && delta > 0) {\n                dragDelta *= this.resistance;\n            }\n            movable.translateAxis(axis, dragDelta);\n            this.trigger(CHANGE$1, this);\n        }\n    }\n    class Pane {\n        constructor(options) {\n            let x, y;\n            extend$1(this, {\n                elastic: true\n            }, options);\n            const resistance = this.elastic ? 0.5 : 0;\n            const movable = this.movable;\n            this.x = x = new PaneAxis({\n                axis: 'x',\n                dimension: this.dimensions.x,\n                resistance: resistance,\n                movable: movable\n            });\n            this.y = y = new PaneAxis({\n                axis: 'y',\n                dimension: this.dimensions.y,\n                resistance: resistance,\n                movable: movable\n            });\n            this.userEvents.bind([\n                'press',\n                'move',\n                'end',\n                'gesturestart',\n                'gesturechange'\n            ], {\n                gesturestart(e) {\n                    this.gesture = e;\n                    this.offset = elementOffset$1(this.dimensions.container);\n                },\n                press(e) {\n                    const closestAnchor = e.event.target.closest('a');\n                    if (closestAnchor && closestAnchor.matches('[data-navigate-on-press=true]')) {\n                        e.sender.cancel();\n                    }\n                },\n                gesturechange(e) {\n                    const previousGesture = this.gesture, previousCenter = previousGesture.center, center = e.center, minScale = this.dimensions.minScale, maxScale = this.dimensions.maxScale;\n                    let scaleDelta = e.distance / previousGesture.distance;\n                    if (movable.scale <= minScale && scaleDelta < 1) {\n                        scaleDelta += (1 - scaleDelta) * 0.8;\n                    }\n                    if (movable.scale * scaleDelta >= maxScale) {\n                        scaleDelta = maxScale / movable.scale;\n                    }\n                    const offsetX = movable.x + this.offset.left, offsetY = movable.y + this.offset.top;\n                    const coordinates = {\n                        x: (offsetX - previousCenter.x) * scaleDelta + center.x - offsetX,\n                        y: (offsetY - previousCenter.y) * scaleDelta + center.y - offsetY\n                    };\n                    movable.scaleWith(scaleDelta);\n                    x.dragMove(coordinates.x);\n                    y.dragMove(coordinates.y);\n                    this.dimensions.rescale(movable.scale);\n                    this.gesture = e;\n                    e.preventDefault();\n                },\n                move(e) {\n                    if (e.event.target.tagName.match(/textarea|input/i)) {\n                        return;\n                    }\n                    if (x.dimension.enabled || y.dimension.enabled) {\n                        x.dragMove(e.x.delta);\n                        y.dragMove(e.y.delta);\n                        e.preventDefault();\n                    }\n                    else {\n                        e.touch.skip();\n                    }\n                },\n                end(e) {\n                    e.preventDefault();\n                }\n            });\n        }\n    }\n    class Movable extends Observable {\n        constructor(element) {\n            super();\n            this.element = element;\n            this.element.style.transformOrigin = 'left top';\n            this.x = 0;\n            this.y = 0;\n            this.scale = 1;\n            const coordinates = translate(this.x, this.y, this.scale);\n            this.element.style.transform = coordinates;\n            this._saveCoordinates(coordinates);\n        }\n        translateAxis(axis, by) {\n            this[axis] += by;\n            this.refresh();\n        }\n        scaleTo(scale) {\n            this.scale = scale;\n            this.refresh();\n        }\n        scaleWith(scaleDelta) {\n            this.scale *= scaleDelta;\n            this.refresh();\n        }\n        translate(coordinates) {\n            this.x += coordinates.x;\n            this.y += coordinates.y;\n            this.refresh();\n        }\n        moveAxis(axis, value) {\n            this[axis] = value;\n            this.refresh();\n        }\n        moveTo(coordinates) {\n            extend$1(this, coordinates);\n            this.refresh();\n        }\n        refresh() {\n            let x = this.x, y = this.y;\n            if (this.round) {\n                x = Math.round(x);\n                y = Math.round(y);\n            }\n            const newCoordinates = translate(x, y, this.scale);\n            if (newCoordinates !== this.coordinates) {\n                this.element.style.transform = newCoordinates;\n                this._saveCoordinates(newCoordinates);\n                this.trigger(CHANGE$1);\n            }\n        }\n        _saveCoordinates(coordinates) {\n            this.coordinates = coordinates;\n        }\n    }\n\n    function animationFrame(callback) {\n        window.requestAnimationFrame(callback);\n    }\n    class Animation {\n        constructor() {\n            this._tickProxy = () => this._tick();\n            this._started = false;\n        }\n        tick() { }\n        done() { return false; }\n        onEnd() { }\n        onCancel() { }\n        start() {\n            if (!this.enabled()) {\n                return;\n            }\n            if (!this.done()) {\n                this._started = true;\n                animationFrame(this._tickProxy);\n            }\n            else {\n                this.onEnd();\n            }\n        }\n        enabled() {\n            return true;\n        }\n        cancel() {\n            this._started = false;\n            this.onCancel();\n        }\n        _tick() {\n            if (!this._started) {\n                return;\n            }\n            this.tick();\n            if (!this.done()) {\n                animationFrame(this._tickProxy);\n            }\n            else {\n                this._started = false;\n                this.onEnd();\n            }\n        }\n    }\n    class Transition extends Animation {\n        constructor(options) {\n            super();\n            extend$1(this, options);\n        }\n        done() {\n            return this.timePassed() >= this.duration;\n        }\n        timePassed() {\n            return Math.min(this.duration, now() - this.startDate);\n        }\n        moveTo(options) {\n            const movable = this.movable;\n            this.initial = movable[this.axis];\n            this.delta = options.location - this.initial;\n            this.duration = typeof options.duration === 'number' ? options.duration : 300;\n            this.tick = this._easeProxy(options.ease);\n            this.startDate = now();\n            this.start();\n        }\n        _easeProxy(ease) {\n            return function () {\n                this.movable.moveAxis(this.axis, ease(this.timePassed(), this.initial, this.delta, this.duration));\n            };\n        }\n        static easeOutExpo(t, b, c, d) {\n            return t === d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;\n        }\n    }\n\n    function guid() {\n        let id = '';\n        let i;\n        let random;\n        for (i = 0; i < 32; i++) {\n            random = Math.floor(Math.random() * 16);\n            if (i === 8 || i === 12 || i === 16 || i === 20) {\n                id += '-';\n            }\n            id += (i === 12 ? 4 : (i === 16 ? ((random % 4) + 8) : random)).toString(16);\n        }\n        return id;\n    }\n\n    const elementEventHandlers = new WeakMap();\n    const ID = Symbol('id');\n    function on(element, events, filter, handler, useCapture) {\n        addEventListeners(element, events, filter, handler, useCapture);\n    }\n    function off(element, events, handler, useCapture) {\n        removeEventListeners(element, events, handler, useCapture);\n    }\n    function isString(value) {\n        return typeof (value) === 'string';\n    }\n    function addEventListeners(element, events, filter, handler, useCapture) {\n        const eventNames = Array.isArray(events) ? events : (events || '').split(' ');\n        eventNames.forEach(function (eventName) {\n            addEventListener(element, eventName, filter, handler, useCapture);\n        });\n    }\n    function addEventListener(element, event, filter, handler, useCapture) {\n        let eventHandler = handler;\n        let eventFilter;\n        if (filter && isFunction$1(filter) && !handler) {\n            eventHandler = filter;\n        }\n        else if (filter && isString(filter) && isFunction$1(eventHandler)) {\n            eventFilter = filter;\n        }\n        const attachedHandler = function (e) {\n            const closestMatchingTarget = e.target ? e.target.closest(eventFilter) : null;\n            if (!eventFilter ||\n                (eventFilter && e.target && closestMatchingTarget)) {\n                const currentTarget = eventFilter ? closestMatchingTarget : e.currentTarget;\n                // reassign the property as it is a getters only\n                Object.defineProperty(e, 'currentTarget', { value: currentTarget });\n                // keep a reference to the top-level target\n                Object.defineProperty(e, 'delegateTarget', { value: element });\n                eventHandler(e);\n            }\n        };\n        if (!eventHandler[ID]) {\n            eventHandler[ID] = guid();\n        }\n        let eventHandlers = elementEventHandlers.get(element);\n        if (!eventHandlers) {\n            eventHandlers = new Map();\n            elementEventHandlers.set(element, eventHandlers);\n        }\n        eventHandlers.set(event + eventHandler[ID], attachedHandler);\n        element.addEventListener(event, attachedHandler, Boolean(useCapture));\n    }\n    function removeEventListeners(element, events, handler, useCapture) {\n        const eventNames = Array.isArray(events) ? events : (events || '').split(' ');\n        eventNames.forEach(function (eventName) {\n            removeEventListener(element, eventName, handler, useCapture);\n        });\n    }\n    function removeEventListener(element, event, handler, useCapture) {\n        const eventHandlers = elementEventHandlers.get(element);\n        if (eventHandlers && handler && handler[ID]) {\n            const handlerId = event + handler[ID];\n            const attachedHandler = eventHandlers.get(handlerId);\n            eventHandlers.delete(handlerId);\n            if (attachedHandler) {\n                element.removeEventListener(event, attachedHandler, Boolean(useCapture));\n            }\n        }\n    }\n\n    function grep(array, callback) {\n        const length = array.length;\n        const result = [];\n        for (let idx = 0; idx < length; idx++) {\n            if (callback(array[idx])) {\n                result.push(array[idx]);\n            }\n        }\n        return result;\n    }\n\n    const preventDefault$1 = (e) => {\n        e.preventDefault();\n    };\n    const noop = () => { };\n    const CLICK_DELAY = 300, PRESS = 'press', HOLD = 'hold', SELECT = 'select', START = 'start', MOVE = 'move', END = 'end', CANCEL = 'cancel', TAP = 'tap', DOUBLETAP = 'doubleTap', RELEASE = 'release', GESTURESTART = 'gesturestart', GESTURECHANGE = 'gesturechange', GESTUREEND = 'gestureend', GESTURETAP = 'gesturetap';\n    const THRESHOLD = {\n        'api': 0,\n        'touch': 0,\n        'mouse': 9,\n        'pointer': 9\n    };\n    let DEFAULT_MIN_HOLD = 800, DEFAULT_THRESHOLD = 0;\n    function touchDelta(touch1, touch2) {\n        const x1 = touch1.x.location, y1 = touch1.y.location, x2 = touch2.x.location, y2 = touch2.y.location, dx = x1 - x2, dy = y1 - y2;\n        return {\n            center: {\n                x: (x1 + x2) / 2,\n                y: (y1 + y2) / 2\n            },\n            distance: Math.sqrt(dx * dx + dy * dy)\n        };\n    }\n    function getTouches(e) {\n        const touches = [], originalEvent = e.originalEvent || e, currentTarget = e.currentTarget;\n        if (e.api) {\n            touches.push({\n                id: 2, // hardcoded ID for API call\n                event: e,\n                target: e.target,\n                currentTarget: e.target,\n                location: e,\n                type: 'api'\n            });\n        }\n        else {\n            touches.push({\n                location: originalEvent,\n                event: e,\n                target: e.target,\n                currentTarget: currentTarget,\n                id: originalEvent.pointerId,\n                type: 'pointer'\n            });\n        }\n        return touches;\n    }\n    class TouchAxis {\n        constructor(axis, location) {\n            this.support = getSupportedFeatures();\n            this.invalidZeroEvents = this.support.mobileOS && this.support.mobileOS.android;\n            this.axis = axis;\n            this._updateLocationData(location);\n            this.startLocation = this.location;\n            this.velocity = this.delta = 0;\n            this.timeStamp = now();\n        }\n        move(location) {\n            const offset = location['page' + this.axis], timeStamp = now(), timeDelta = timeStamp - this.timeStamp || 1;\n            if (!offset && this.invalidZeroEvents) {\n                return;\n            }\n            this.delta = offset - this.location;\n            this._updateLocationData(location);\n            this.initialDelta = offset - this.startLocation;\n            this.velocity = this.delta / timeDelta;\n            this.timeStamp = timeStamp;\n        }\n        _updateLocationData(location) {\n            const axis = this.axis;\n            this.location = location['page' + axis];\n            this.client = location['client' + axis];\n            this.screen = location['screen' + axis];\n        }\n    }\n    class Touch {\n        constructor(userEvents, target, touchInfo) {\n            extend$1(this, {\n                x: new TouchAxis('X', touchInfo.location),\n                y: new TouchAxis('Y', touchInfo.location),\n                type: touchInfo.type,\n                threshold: userEvents.threshold || THRESHOLD[touchInfo.type],\n                userEvents: userEvents,\n                target: target,\n                currentTarget: touchInfo.currentTarget,\n                initialTouch: touchInfo.target,\n                id: touchInfo.id,\n                pressEvent: touchInfo,\n                _clicks: userEvents._clicks,\n                supportDoubleTap: userEvents.supportDoubleTap,\n                _moved: false,\n                _finished: false\n            });\n        }\n        press() {\n            this._holdTimeout = setTimeout(() => this._hold(), this.userEvents.minHold);\n            this._trigger(PRESS, this.pressEvent);\n        }\n        _tap(touchInfo) {\n            this.userEvents._clicks++;\n            if (this.userEvents._clicks === 1) {\n                this._clickTimeout = setTimeout(() => {\n                    if (this.userEvents._clicks === 1) {\n                        this._trigger(TAP, touchInfo);\n                    }\n                    else {\n                        this._trigger(DOUBLETAP, touchInfo);\n                    }\n                    this.userEvents._clicks = 0;\n                }, CLICK_DELAY);\n            }\n        }\n        _hold() {\n            this._trigger(HOLD, this.pressEvent);\n        }\n        move(touchInfo) {\n            const preventMove = touchInfo.type !== 'api' && this.userEvents._shouldNotMove;\n            if (this._finished || preventMove) {\n                return;\n            }\n            this.x.move(touchInfo.location);\n            this.y.move(touchInfo.location);\n            if (!this._moved) {\n                if (this._withinIgnoreThreshold()) {\n                    return;\n                }\n                if (!UserEvents.current || UserEvents.current === this.userEvents) {\n                    this._start(touchInfo);\n                }\n                else {\n                    return this.dispose();\n                }\n            }\n            if (!this._finished) {\n                this._trigger(MOVE, touchInfo);\n            }\n        }\n        end(touchInfo) {\n            this.endTime = now();\n            if (this._finished) {\n                return;\n            }\n            this._finished = true;\n            this._trigger(RELEASE, touchInfo);\n            if (this._moved) {\n                this._trigger(END, touchInfo);\n            }\n            else {\n                if (this.supportDoubleTap) {\n                    this._tap(touchInfo);\n                }\n                else {\n                    this._trigger(TAP, touchInfo);\n                }\n            }\n            clearTimeout(this._holdTimeout);\n            this.dispose();\n        }\n        dispose() {\n            const userEvents = this.userEvents, activeTouches = userEvents.touches || [];\n            this._finished = true;\n            this.pressEvent = null;\n            clearTimeout(this._holdTimeout);\n            // activeTouches.splice($.inArray(this, activeTouches), 1);\n            const activeTouchIndex = activeTouches.indexOf(this);\n            activeTouches.splice(activeTouchIndex, 1);\n        }\n        skip() {\n            this.dispose();\n        }\n        cancel() {\n            this.dispose();\n        }\n        isMoved() {\n            return this._moved;\n        }\n        _start(touchInfo) {\n            clearTimeout(this._holdTimeout);\n            this.startTime = now();\n            this._moved = true;\n            this._trigger(START, touchInfo);\n        }\n        _trigger(name, touchInfo) {\n            const e = touchInfo.event;\n            const data = {\n                touch: this,\n                x: this.x,\n                y: this.y,\n                target: this.target,\n                event: e\n            };\n            if (this.userEvents.notify(name, data)) {\n                e.preventDefault();\n            }\n        }\n        _withinIgnoreThreshold() {\n            const xDelta = this.x.initialDelta, yDelta = this.y.initialDelta;\n            return Math.sqrt(xDelta * xDelta + yDelta * yDelta) <= this.threshold;\n        }\n    }\n    function withEachUpEvent(callback) {\n        const downEvents = eventMap.up.split(' '), length = downEvents.length;\n        for (let idx = 0; idx < length; idx++) {\n            callback(downEvents[idx]);\n        }\n    }\n    class UserEvents extends Observable {\n        constructor(element, options) {\n            super();\n            const support = getSupportedFeatures();\n            this.support = support;\n            options = options || {};\n            this.options = options;\n            const filter = this.filter = options.filter;\n            this.threshold = options.threshold || DEFAULT_THRESHOLD;\n            this.minHold = options.minHold || DEFAULT_MIN_HOLD;\n            this.touches = [];\n            this._maxTouches = options.multiTouch ? 2 : 1;\n            this.allowSelection = options.allowSelection;\n            this.captureUpIfMoved = options.captureUpIfMoved;\n            this._clicks = 0;\n            this.supportDoubleTap = options.supportDoubleTap;\n            extend$1(this, {\n                element: element,\n                surface: options.surface || element,\n                stopPropagation: options.stopPropagation,\n                pressed: false\n            });\n            this._surfaceMoveHandler = this._move.bind(this);\n            on(this.surface, applyEventMap('move'), this._surfaceMoveHandler);\n            this._surfaceEndHandler = this._end.bind(this);\n            on(this.surface, applyEventMap('up cancel'), this._surfaceEndHandler);\n            this._elementStartHandler = this._start.bind(this);\n            on(element, applyEventMap('down'), filter, this._elementStartHandler);\n            element.style['touch-action'] = options.touchAction || 'none';\n            if (options.preventDragEvent) {\n                this._elementDragStartHandler = preventDefault$1;\n                on(element, applyEventMap('dragstart'), this._elementDragStartHandler);\n            }\n            // element.on(kendo.applyEventMap('mousedown'), filter, {\n            //     root: element\n            // } '_select');\n            // todo: use root\n            this._elementSelectHandler = this._select.bind(this);\n            on(element, applyEventMap('mousedown'), filter, this._elementSelectHandler);\n            if (this.captureUpIfMoved) {\n                const surfaceElement = this.surface;\n                this.preventIfMovingProxy = this.preventIfMoving.bind(this);\n                withEachUpEvent((eventName) => {\n                    surfaceElement.addEventListener(eventName, this.preventIfMovingProxy, true);\n                });\n            }\n            this.bind([\n                PRESS,\n                HOLD,\n                TAP,\n                DOUBLETAP,\n                START,\n                MOVE,\n                END,\n                RELEASE,\n                CANCEL,\n                GESTURESTART,\n                GESTURECHANGE,\n                GESTUREEND,\n                GESTURETAP,\n                SELECT\n            ], options);\n        }\n        preventIfMoving(e) {\n            if (this._isMoved()) {\n                e.preventDefault();\n            }\n        }\n        destroy() {\n            const options = this.options;\n            const element = this.element;\n            if (this._destroyed) {\n                return;\n            }\n            this._destroyed = true;\n            if (this.captureUpIfMoved) {\n                const surfaceElement = this.surface;\n                withEachUpEvent((eventName) => {\n                    surfaceElement.removeEventListener(eventName, this.preventIfMovingProxy, true);\n                });\n            }\n            off(this.surface, applyEventMap('move'), this._surfaceMoveHandler);\n            off(this.surface, applyEventMap('up cancel'), this._surfaceEndHandler);\n            off(element, applyEventMap('down'), this._elementStartHandler);\n            if (options.preventDragEvent) {\n                off(element, applyEventMap('dragstart'), this._elementDragStartHandler);\n            }\n            off(element, applyEventMap('mousedown'), this._elementSelectHandler);\n            this._disposeAll();\n            this.unbind();\n            delete this.surface;\n            delete this.element;\n            delete this.currentTarget;\n        }\n        capture() {\n            UserEvents.current = this;\n        }\n        cancel() {\n            this._disposeAll();\n            this.trigger(CANCEL);\n        }\n        notify(event, data) {\n            const touches = this.touches;\n            let eventName = event;\n            if (this._isMultiTouch()) {\n                switch (eventName) {\n                    case MOVE:\n                        eventName = GESTURECHANGE;\n                        break;\n                    case END:\n                        eventName = GESTUREEND;\n                        break;\n                    case TAP:\n                        eventName = GESTURETAP;\n                        break;\n                    default:\n                        break;\n                }\n                extend$1(data, {\n                    touches: touches\n                }, touchDelta(touches[0], touches[1]));\n            }\n            return this.trigger(eventName, extend$1(data, {\n                type: eventName\n            }));\n        }\n        press(x, y, target) {\n            this._apiCall('_start', x, y, target);\n        }\n        move(x, y) {\n            this._apiCall('_move', x, y);\n        }\n        end(x, y) {\n            this._apiCall('_end', x, y);\n        }\n        _isMultiTouch() {\n            return this.touches.length > 1;\n        }\n        _maxTouchesReached() {\n            return this.touches.length >= this._maxTouches;\n        }\n        _disposeAll() {\n            const touches = this.touches;\n            while (touches.length > 0) {\n                touches.pop().dispose();\n            }\n        }\n        _isMoved() {\n            return grep(this.touches, function (touch) {\n                return touch.isMoved();\n            }).length;\n        }\n        _select(e) {\n            if (!this.allowSelection || this.trigger(SELECT, { event: e })) {\n                e.preventDefault();\n            }\n        }\n        _start(e) {\n            if (e.which && e.which > 1 || this._maxTouchesReached()) {\n                return;\n            }\n            UserEvents.current = null;\n            this.currentTarget = e.currentTarget;\n            if (this.stopPropagation) {\n                e.stopPropagation();\n            }\n            let target;\n            const eventTouches = getTouches(e);\n            for (let idx = 0; idx < eventTouches.length; idx++) {\n                if (this._maxTouchesReached()) {\n                    break;\n                }\n                const eventTouch = eventTouches[idx];\n                if (this.filter) {\n                    target = eventTouch.currentTarget;\n                }\n                else {\n                    target = this.element;\n                }\n                if (target && target.length === 0) {\n                    continue;\n                }\n                const touch = new Touch(this, target, eventTouch);\n                this.touches.push(touch);\n                touch.press();\n                if (this._isMultiTouch()) {\n                    this.notify('gesturestart', {});\n                }\n            }\n        }\n        _move(e) {\n            this._eachTouch('move', e);\n        }\n        _end(e) {\n            this._eachTouch('end', e);\n        }\n        _eachTouch(methodName, e) {\n            const dict = {}, touches = getTouches(e), activeTouches = this.touches;\n            let idx, touch, touchInfo, matchingTouch;\n            for (idx = 0; idx < activeTouches.length; idx++) {\n                touch = activeTouches[idx];\n                dict[touch.id] = touch;\n            }\n            for (idx = 0; idx < touches.length; idx++) {\n                touchInfo = touches[idx];\n                matchingTouch = dict[touchInfo.id];\n                if (matchingTouch) {\n                    const shouldCapture = methodName === 'move' && touchInfo.type === 'pointer' && !this.surface.hasPointerCapture(touchInfo.id);\n                    if (shouldCapture) {\n                        this.surface.setPointerCapture(touchInfo.id);\n                    }\n                    matchingTouch[methodName](touchInfo);\n                }\n            }\n        }\n        _apiCall(type, x, y, target) {\n            this[type]({\n                api: true,\n                pageX: x,\n                pageY: y,\n                clientX: x,\n                clientY: y,\n                target: target || this.element,\n                stopPropagation: noop,\n                preventDefault: noop\n            });\n        }\n        static defaultThreshold(value) {\n            DEFAULT_THRESHOLD = value;\n        }\n        static minHold(value) {\n            DEFAULT_MIN_HOLD = value;\n        }\n    }\n\n    const extend = Object.assign, abs = Math.abs, SNAPBACK_DURATION = 500, SCROLLBAR_OPACITY = 0.7, FRICTION = 0.96, VELOCITY_MULTIPLIER = 10, MAX_VELOCITY = 55, OUT_OF_BOUNDS_FRICTION = 0.5, ANIMATED_SCROLLER_PRECISION = 5, \n    // SCROLLER_RELEASE_CLASS = 'km-scroller-release',\n    // SCROLLER_REFRESH_CLASS = 'km-scroller-refresh',\n    PULL = 'pull', CHANGE = 'change', RESIZE = 'resize', SCROLL = 'scroll', MOUSE_WHEEL_ID = 2;\n    class ZoomSnapBack extends Animation {\n        constructor(options) {\n            super();\n            extend(this, options);\n            this.userEvents.bind('gestureend', this.start.bind(this));\n            this.tapCapture.bind('press', this.cancel.bind(this));\n        }\n        enabled() {\n            return this.movable.scale < this.dimensions.minScale;\n        }\n        done() {\n            return this.dimensions.minScale - this.movable.scale < 0.01;\n        }\n        tick() {\n            const movable = this.movable;\n            movable.scaleWith(1.1);\n            this.dimensions.rescale(movable.scale);\n        }\n        onEnd() {\n            const movable = this.movable;\n            movable.scaleTo(this.dimensions.minScale);\n            this.dimensions.rescale(movable.scale);\n        }\n    }\n    class DragInertia extends Animation {\n        constructor(options) {\n            super();\n            extend(this, options, {\n                transition: new Transition({\n                    axis: options.axis,\n                    movable: options.movable,\n                    onEnd: () => {\n                        this._end();\n                    }\n                })\n            });\n            this.tapCapture.bind('press', () => {\n                this.cancel();\n            });\n            this.userEvents.bind('end', () => this.start());\n            this.userEvents.bind('gestureend', () => this.start());\n            this.userEvents.bind('tap', () => this.onEnd());\n        }\n        onCancel() {\n            this.transition.cancel();\n        }\n        freeze(location) {\n            this.cancel();\n            this._moveTo(location);\n        }\n        onEnd() {\n            if (this.paneAxis.outOfBounds()) {\n                this._snapBack();\n            }\n            else {\n                this._end();\n            }\n        }\n        done() {\n            return abs(this.velocity) < 1;\n        }\n        start(e) {\n            let velocity;\n            if (!this.dimension.enabled) {\n                return;\n            }\n            if (this.paneAxis.outOfBounds()) {\n                if (this.transition._started) {\n                    this.transition.cancel();\n                    this.velocity = Math.min(e.touch[this.axis].velocity * this.velocityMultiplier, MAX_VELOCITY);\n                    super.start();\n                }\n                else {\n                    this._snapBack();\n                }\n            }\n            else {\n                velocity = e ? (e.touch.id === MOUSE_WHEEL_ID ? 0 : e.touch[this.axis].velocity) : 0;\n                this.velocity = Math.max(Math.min(velocity * this.velocityMultiplier, MAX_VELOCITY), -MAX_VELOCITY);\n                this.tapCapture.captureNext();\n                super.start();\n            }\n        }\n        tick() {\n            const dimension = this.dimension, friction = this.paneAxis.outOfBounds() ? OUT_OF_BOUNDS_FRICTION : this.friction, delta = this.velocity *= friction;\n            let location = this.movable[this.axis] + delta;\n            if (!this.elastic && dimension.outOfBounds(location)) {\n                location = Math.max(Math.min(location, dimension.max), dimension.min);\n                this.velocity = 0;\n            }\n            this.movable.moveAxis(this.axis, location);\n        }\n        _end() {\n            this.tapCapture.cancelCapture();\n            this.end();\n        }\n        end() { }\n        _snapBack() {\n            const dimension = this.dimension, snapBack = this.movable[this.axis] > dimension.max ? dimension.max : dimension.min;\n            this._moveTo(snapBack);\n        }\n        _moveTo(location) {\n            this.transition.moveTo({\n                location: location,\n                duration: SNAPBACK_DURATION,\n                ease: (...args) => {\n                    Transition.easeOutExpo.apply(null, args);\n                }\n            });\n        }\n    }\n    class AnimatedScroller extends Animation {\n        constructor(options) {\n            super();\n            extend(this, options, {\n                origin: {},\n                destination: {},\n                offset: {}\n            });\n        }\n        moveTo(_to) { }\n        tick() {\n            this._updateCoordinates();\n            this.moveTo(this.origin);\n        }\n        done() {\n            return abs(this.offset.y) < ANIMATED_SCROLLER_PRECISION && abs(this.offset.x) < ANIMATED_SCROLLER_PRECISION;\n        }\n        onEnd() {\n            this.moveTo(this.destination);\n            if (this.callback) {\n                this.callback.call();\n            }\n        }\n        setCoordinates(from, to) {\n            this.offset = {};\n            this.origin = from;\n            this.destination = to;\n        }\n        setCallback(callback) {\n            if (callback && isFunction$1(callback)) {\n                this.callback = callback;\n            }\n            else {\n                callback = undefined;\n            }\n        }\n        _updateCoordinates() {\n            this.offset = {\n                x: (this.destination.x - this.origin.x) / 4,\n                y: (this.destination.y - this.origin.y) / 4\n            };\n            this.origin = {\n                y: this.origin.y + this.offset.y,\n                x: this.origin.x + this.offset.x\n            };\n        }\n    }\n    class ScrollBar {\n        constructor(options) {\n            const horizontal = options.axis === 'x';\n            const orientation = (horizontal ? 'horizontal' : 'vertical');\n            const element = convertToHtml('<div class=\"km-touch-scrollbar km-' + orientation + '-scrollbar\" />');\n            extend(this, options, {\n                element: element,\n                elementSize: 0,\n                movable: new Movable(element),\n                scrollMovable: options.movable,\n                alwaysVisible: options.alwaysVisible,\n                size: horizontal ? 'width' : 'height'\n            });\n            this.scrollMovable.bind(CHANGE, this.refresh.bind(this));\n            this.container.appendChild(element);\n            if (options.alwaysVisible) {\n                this.show();\n            }\n        }\n        refresh() {\n            const axis = this.axis, dimension = this.dimension, paneSize = dimension.size, scrollMovable = this.scrollMovable, sizeRatio = paneSize / dimension.total;\n            let size = Math.round(paneSize * sizeRatio), position = Math.round(-scrollMovable[axis] * sizeRatio);\n            if (sizeRatio >= 1) {\n                this.element.style.display = 'none';\n            }\n            else {\n                this.element.style.display = '';\n            }\n            if (position + size > paneSize) {\n                size = paneSize - position;\n            }\n            else if (position < 0) {\n                size += position;\n                position = 0;\n            }\n            if (this.elementSize !== size) {\n                this.element.style[this.size] = size + 'px';\n                this.elementSize = size;\n            }\n            this.movable.moveAxis(axis, position);\n        }\n        show() {\n            this.element.style.opacity = SCROLLBAR_OPACITY;\n            this.element.style.visibility = 'visible';\n        }\n        hide() {\n            if (!this.alwaysVisible) {\n                this.element.style.opacity = 0;\n            }\n        }\n    }\n    const defaultScrollerOptions = {\n        name: 'Scroller',\n        zoom: false,\n        pullOffset: 140,\n        visibleScrollHints: false,\n        elastic: true,\n        useNative: false,\n        mousewheelScrolling: true,\n        avoidScrolling: () => false,\n        pullToRefresh: false,\n        messages: {\n            pullTemplate: 'Pull to refresh',\n            releaseTemplate: 'Release to refresh',\n            refreshTemplate: 'Refreshing'\n        }\n    };\n    // export class Scroller extends Class {\n    class Scroller extends Observable {\n        constructor(element, options) {\n            super();\n            this.element = element = element[0] || element;\n            this._initOptions(options);\n            this.events.push(PULL, SCROLL, RESIZE);\n            const hasScrolling = hasNativeScrolling();\n            this._native = this.options.useNative && hasScrolling;\n            const scrollHeader = convertToHtml('<div class=\"km-scroll-header\"/>');\n            if (this._native) {\n                addClass(element, 'km-native-scroller');\n                prepend(scrollHeader, element);\n                extend(this, {\n                    scrollElement: element,\n                    fixedContainer: element.children[0]\n                });\n                return;\n            }\n            element.style.overflow = 'hidden';\n            addClass(element, 'km-scroll-wrapper');\n            const scrollContainer = convertToHtml('<div class=\"km-scroll-container\"/>');\n            wrapInner(element, scrollContainer);\n            prepend(scrollHeader, element);\n            const inner = element.children[1], tapCapture = new TapCapture(element), movable = new Movable(inner), dimensions = new PaneDimensions({\n                element: inner,\n                container: element,\n                forcedEnabled: this.options.zoom\n            }), avoidScrolling = this.options.avoidScrolling, userEvents = new UserEvents(element, {\n                touchAction: 'none',\n                allowSelection: true,\n                preventDragEvent: true,\n                captureUpIfMoved: true,\n                multiTouch: this.options.zoom,\n                supportDoubleTap: this.options.supportDoubleTap,\n                start: (e) => {\n                    dimensions.refresh();\n                    const velocityX = abs(e.x.velocity), velocityY = abs(e.y.velocity), horizontalSwipe = velocityX * 2 >= velocityY, originatedFromFixedContainer = this.fixedContainer.contains(e.event.target), verticalSwipe = velocityY * 2 >= velocityX;\n                    if (!originatedFromFixedContainer && !avoidScrolling(e) && this.enabled && (dimensions.x.enabled && horizontalSwipe || dimensions.y.enabled && verticalSwipe)) {\n                        userEvents.capture();\n                    }\n                    else {\n                        userEvents.cancel();\n                    }\n                }\n            }), pane = new Pane({\n                movable: movable,\n                dimensions: dimensions,\n                userEvents: userEvents,\n                elastic: this.options.elastic\n            }), zoomSnapBack = new ZoomSnapBack({\n                movable: movable,\n                dimensions: dimensions,\n                userEvents: userEvents,\n                tapCapture: tapCapture\n            }), animatedScroller = new AnimatedScroller({\n                moveTo: (coordinates) => {\n                    this.scrollTo(coordinates.x, coordinates.y);\n                }\n            });\n            movable.bind(CHANGE, () => {\n                this.scrollTop = -movable.y;\n                this.scrollLeft = -movable.x;\n                this.trigger(SCROLL, {\n                    scrollTop: this.scrollTop,\n                    scrollLeft: this.scrollLeft\n                });\n            });\n            if (this.options.mousewheelScrolling) {\n                this._wheelScrollHandler = this._wheelScroll.bind(this);\n                on(element, 'wheel', this._wheelScrollHandler);\n            }\n            extend(this, {\n                movable: movable,\n                dimensions: dimensions,\n                zoomSnapBack: zoomSnapBack,\n                animatedScroller: animatedScroller,\n                userEvents: userEvents,\n                pane: pane,\n                tapCapture: tapCapture,\n                pulled: false,\n                enabled: true,\n                scrollElement: inner,\n                scrollTop: 0,\n                scrollLeft: 0,\n                fixedContainer: element.children[0]\n            });\n            this._initAxis('x');\n            this._initAxis('y');\n            this._wheelEnd = () => {\n                this._wheel = false;\n                this.userEvents.end(0, this._wheelY);\n            };\n            dimensions.refresh();\n            if (this.options.pullToRefresh) {\n                this._initPullToRefresh();\n            }\n            this.bind(this.events, this.options);\n        }\n        _initOptions(options) {\n            this.options = deepExtend({}, this.options, defaultScrollerOptions, options);\n        }\n        _wheelScroll(e) {\n            if (e.ctrlKey) {\n                return;\n            }\n            if (!this._wheel) {\n                this._wheel = true;\n                this._wheelY = 0;\n                this.userEvents.press(0, this._wheelY);\n            }\n            clearTimeout(this._wheelTimeout);\n            this._wheelTimeout = setTimeout(() => this._wheelEnd(), 50);\n            const delta = wheelDeltaY(e);\n            if (delta) {\n                this._wheelY += delta;\n                this.userEvents.move(0, this._wheelY);\n            }\n            e.preventDefault();\n        }\n        makeVirtual() {\n            this.dimensions.y.makeVirtual();\n        }\n        virtualSize(min, max) {\n            this.dimensions.y.virtualSize(min, max);\n        }\n        height() {\n            return this.dimensions.y.size;\n        }\n        scrollHeight() {\n            return this.scrollElement.scrollHeight;\n        }\n        scrollWidth() {\n            return this.scrollElement.scrollWidth;\n        }\n        _resize() {\n            if (!this._native) {\n                this.contentResized();\n            }\n        }\n        setOptions(options) {\n            this._initOptions(options);\n            if (options.pullToRefresh) {\n                this._initPullToRefresh();\n            }\n        }\n        reset() {\n            if (this._native) {\n                this.scrollElement.scrollTop(0);\n            }\n            else {\n                this.movable.moveTo({\n                    x: 0,\n                    y: 0\n                });\n                this._scale(1);\n            }\n        }\n        contentResized() {\n            this.dimensions.refresh();\n            if (this.pane.x.outOfBounds()) {\n                this.movable.moveAxis('x', this.dimensions.x.min);\n            }\n            if (this.pane.y.outOfBounds()) {\n                this.movable.moveAxis('y', this.dimensions.y.min);\n            }\n        }\n        zoomOut() {\n            const dimensions = this.dimensions;\n            dimensions.refresh();\n            this._scale(dimensions.fitScale);\n            this.movable.moveTo(dimensions.centerCoordinates());\n        }\n        enable() {\n            this.enabled = true;\n        }\n        disable() {\n            this.enabled = false;\n        }\n        scrollTo(x, y) {\n            if (this._native) {\n                this.scrollElement.scrollLeft(abs(x));\n                this.scrollElement.scrollTop(abs(y));\n            }\n            else {\n                this.dimensions.refresh();\n                this.movable.moveTo({\n                    x: x,\n                    y: y\n                });\n            }\n        }\n        animatedScrollTo(x, y, callback) {\n            let from, to;\n            if (this._native) {\n                this.scrollTo(x, y);\n            }\n            else {\n                from = {\n                    x: this.movable.x,\n                    y: this.movable.y\n                };\n                to = {\n                    x: x,\n                    y: y\n                };\n                this.animatedScroller.setCoordinates(from, to);\n                this.animatedScroller.setCallback(callback);\n                this.animatedScroller.start();\n            }\n        }\n        // kept for API compatibility, not used\n        pullHandled() {\n            // let this = this;\n            // removeClass(this.refreshHint, SCROLLER_REFRESH_CLASS);\n            // this.hintContainer.innerHTML = this.pullTemplate({}));\n            // this.yinertia.onEnd();\n            // this.xinertia.onEnd();\n            // this.userEvents.cancel();\n        }\n        destroy() {\n            const element = this.element;\n            off(element, 'wheel', this._wheelScrollHandler);\n            if (this.userEvents) {\n                this.userEvents.destroy();\n            }\n            if (this.tapCapture) {\n                this.tapCapture.destroy();\n            }\n        }\n        _scale(scale) {\n            this.dimensions.rescale(scale);\n            this.movable.scaleTo(scale);\n        }\n        _initPullToRefresh() {\n        }\n        // kept for API compatibility, not used\n        _dragEnd() {\n            // let this = this;\n            // if (!this.pulled) {\n            //     return;\n            // }\n            // this.pulled = false;\n            // removeClass(this.refreshHint, SCROLLER_RELEASE_CLASS);\n            // addClass(this.refreshHint, SCROLLER_REFRESH_CLASS);\n            // this.hintContainer.innerHTML = this.refreshTemplate({});\n            // this.yinertia.freeze(this.options.pullOffset / 2);\n            // this.trigger('pull');\n        }\n        // kept for API compatibility, not used\n        _paneChange() {\n            // let this = this;\n            // if (this.movable.y / OUT_OF_BOUNDS_FRICTION > this.options.pullOffset) {\n            //     if (!this.pulled) {\n            //         this.pulled = true;\n            //         this.refreshHint.removeClass(SCROLLER_REFRESH_CLASS).addClass(SCROLLER_RELEASE_CLASS);\n            //         this.hintContainer.html(this.releaseTemplate({}));\n            //         this.hintContainer.html(this.releaseTemplate({}));\n            //     }\n            // } else if (this.pulled) {\n            //     this.pulled = false;\n            //     this.refreshHint.removeClass(SCROLLER_RELEASE_CLASS);\n            //     this.hintContainer.html(this.pullTemplate({}));\n            // }\n        }\n        _initAxis(axis) {\n            const movable = this.movable, dimension = this.dimensions[axis], tapCapture = this.tapCapture, paneAxis = this.pane[axis], scrollBar = new ScrollBar({\n                axis: axis,\n                movable: movable,\n                dimension: dimension,\n                container: this.element,\n                alwaysVisible: this.options.visibleScrollHints\n            });\n            dimension.bind(CHANGE, () => {\n                scrollBar.refresh();\n            });\n            paneAxis.bind(CHANGE, () => {\n                scrollBar.show();\n            });\n            this[axis + 'inertia'] = new DragInertia({\n                axis: axis,\n                paneAxis: paneAxis,\n                movable: movable,\n                tapCapture: tapCapture,\n                userEvents: this.userEvents,\n                dimension: dimension,\n                elastic: this.options.elastic,\n                friction: this.options.friction || FRICTION,\n                velocityMultiplier: this.options.velocityMultiplier || VELOCITY_MULTIPLIER,\n                end: () => {\n                    scrollBar.hide();\n                    this.trigger('scrollEnd', {\n                        axis: axis,\n                        scrollTop: this.scrollTop,\n                        scrollLeft: this.scrollLeft\n                    });\n                }\n            });\n        }\n    }\n\n    class ScrollerTool extends EmptyTool {\n        constructor(toolService) {\n            super(toolService);\n            const diagram = this.toolService.diagram, canvas = diagram.canvas;\n            const friction = diagram._mobileOS() ? FRICTION_MOBILE : FRICTION$1;\n            const scroller = diagram.scroller = this.scroller = new Scroller(diagram.scrollable, {\n                friction: friction,\n                velocityMultiplier: VELOCITY_MULTIPLIER$1,\n                mousewheelScrolling: false,\n                zoom: false,\n                scroll: this._move.bind(this)\n            });\n            if (canvas.translate) {\n                this.movableCanvas = new Movable(canvas.element);\n            }\n            const virtualScroll = function (dimension, min, max) {\n                dimension.makeVirtual();\n                dimension.virtualSize(min || SCROLL_MIN, max || SCROLL_MAX);\n            };\n            virtualScroll(scroller.dimensions.x);\n            virtualScroll(scroller.dimensions.y);\n            scroller.disable();\n        }\n        tryActivate(_p, meta) {\n            const toolService = this.toolService;\n            const options = toolService.diagram.options.pannable;\n            let enabled = meta.ctrlKey;\n            if (defined(options.key)) {\n                if (!options.key || options.key === 'none') {\n                    enabled = noMeta(meta) && !defined(toolService.hoveredItem);\n                }\n                else {\n                    enabled = meta[options.key + 'Key'];\n                }\n            }\n            return options !== false && enabled && !defined(toolService.hoveredAdorner) && !defined(toolService._hoveredConnector);\n        }\n        start() {\n            this.scroller.enable();\n        }\n        move() {\n        } // the tool itself should not handle the scrolling. Let kendo scroller take care of this part. Check _move\n        _move(args) {\n            const diagram = this.toolService.diagram, canvas = diagram.canvas;\n            let scrollPos = new Point(args.scrollLeft, args.scrollTop);\n            if (canvas.translate) {\n                diagram._storePan(scrollPos.times(-1));\n                this.movableCanvas.moveTo(scrollPos);\n                canvas.translate(scrollPos.x, scrollPos.y);\n            }\n            else {\n                scrollPos = scrollPos.plus(diagram._pan.times(-1));\n            }\n            diagram.trigger(PAN, { pan: scrollPos });\n        }\n        end() {\n            this.scroller.disable();\n        }\n        getCursor() {\n            return Cursors.move;\n        }\n    }\n\n    class SelectionTool {\n        constructor(toolService) {\n            this.toolService = toolService;\n        }\n        tryActivate(_p, meta) {\n            const toolService = this.toolService;\n            const selectable = toolService.diagram.options.selectable;\n            let enabled = selectable && selectable.multiple !== false;\n            if (enabled) {\n                if (selectable.key && selectable.key !== 'none') {\n                    enabled = meta[selectable.key + 'Key'];\n                }\n                else {\n                    enabled = noMeta(meta);\n                }\n            }\n            return enabled && !defined(toolService.hoveredItem) && !defined(toolService.hoveredAdorner);\n        }\n        start(p) {\n            const diagram = this.toolService.diagram;\n            diagram.deselect();\n            diagram.selector.start(p);\n        }\n        move(p) {\n            const diagram = this.toolService.diagram;\n            diagram.selector.move(p);\n        }\n        end(_p, meta) {\n            const diagram = this.toolService.diagram, hoveredItem = this.toolService.hoveredItem;\n            const rect = diagram.selector.bounds();\n            if ((!hoveredItem || !hoveredItem.isSelected) && !meta.ctrlKey) {\n                diagram.deselect();\n            }\n            if (!rect.isEmpty()) {\n                diagram.selectArea(rect);\n            }\n            diagram.selector.end();\n        }\n        getCursor() {\n            return Cursors.arrow;\n        }\n    }\n\n    function testKey(key, str) {\n        return str.charCodeAt(0) === key || str.toUpperCase().charCodeAt(0) === key;\n    }\n\n    class ConnectionEditUnit {\n        constructor(item, redoSource, redoTarget) {\n            this.item = item;\n            this._redoSource = redoSource;\n            this._redoTarget = redoTarget;\n            if (defined(redoSource)) {\n                this._undoSource = item.source();\n            }\n            if (defined(redoTarget)) {\n                this._undoTarget = item.target();\n            }\n            this.title = ConnectionEditing;\n        }\n        undo() {\n            if (this._undoSource !== undefined) {\n                this.item._updateConnector(this._undoSource, SOURCE);\n            }\n            if (this._undoTarget !== undefined) {\n                this.item._updateConnector(this._undoTarget, TARGET);\n            }\n            this.item.updateModel();\n        }\n        redo() {\n            if (this._redoSource !== undefined) {\n                this.item._updateConnector(this._redoSource, SOURCE);\n            }\n            if (this._redoTarget !== undefined) {\n                this.item._updateConnector(this._redoTarget, TARGET);\n            }\n            this.item.updateModel();\n        }\n    }\n\n    const defaultOptions$1 = {\n        hover: {\n            stroke: {}\n        },\n        startCap: NONE,\n        endCap: NONE,\n        points: [],\n        selectable: true,\n        fromConnector: AUTO,\n        toConnector: AUTO\n    };\n    /**\n     * The visual link between two Shapes through the intermediate of Connectors.\n     */\n    class Connection extends DiagramElement {\n        constructor(from, to, options) {\n            options = deepExtend({}, defaultOptions$1, options);\n            super(options);\n            this.updateOptionsFromModel();\n            this._initRouter();\n            this.path = new Polyline(this.options);\n            this.path.fill(TRANSPARENT);\n            this.visual.append(this.path);\n            this._sourcePoint = this._targetPoint = new Point();\n            this._setSource(from);\n            this._setTarget(to);\n            this.content(this.options.content);\n            this.definers = [];\n            if (defined(options) && options.points) {\n                this.points(options.points);\n            }\n        }\n        _setOptionsFromModel(model) {\n            this.updateOptionsFromModel(model || this.dataItem);\n        }\n        updateOptionsFromModel(model) {\n            if (this.diagram && this.diagram._isEditable) {\n                const dataMap = this.diagram._dataMap;\n                const options = filterConnectionDataItem(model || this.dataItem);\n                if (model) {\n                    if (defined(options.from)) {\n                        let from = dataMap[options.from];\n                        if (from && defined(options.fromConnector)) {\n                            from = from.getConnector(options.fromConnector);\n                        }\n                        this.source(from);\n                    }\n                    else if (defined(options.fromX) && defined(options.fromY)) {\n                        this.source(new Point(options.fromX, options.fromY));\n                    }\n                    if (defined(options.to)) {\n                        let to = dataMap[options.to];\n                        if (to && defined(options.toConnector)) {\n                            to = to.getConnector(options.toConnector);\n                        }\n                        this.target(to);\n                    }\n                    else if (defined(options.toX) && defined(options.toY)) {\n                        this.target(new Point(options.toX, options.toY));\n                    }\n                    if (defined(options.type) && this.type() !== options.type) {\n                        this.points([]);\n                        this.type(options.type);\n                    }\n                    this.dataItem = model;\n                    this._template();\n                    this.redraw(this.options);\n                }\n                else {\n                    this.options = deepExtend({}, options, this.options);\n                }\n            }\n        }\n        updateModel(syncChanges) {\n            if (this.diagram && this.diagram._isEditable) {\n                this.diagram.updateConnectionModel(this, syncChanges);\n            }\n        }\n        /**\n         * Gets the Point where the source of the connection resides.\n         * If the endpoint in Auto-connector the location of the resolved connector will be returned.\n         * If the endpoint is floating the location of the endpoint is returned.\n         */\n        sourcePoint() {\n            return this._resolvedSourceConnector ? this._resolvedSourceConnector.position() : this._sourcePoint;\n        }\n        _setSource(source) {\n            const shapeSource = source instanceof Shape;\n            const defaultConnector = this.options.fromConnector || AUTO;\n            let dataItem;\n            if (shapeSource && !source.getConnector(defaultConnector)) {\n                return;\n            }\n            if (source !== undefined) {\n                this.from = source;\n            }\n            this._removeFromSourceConnector();\n            if (source === null) { // detach\n                if (this.sourceConnector) {\n                    this._sourcePoint = (this._resolvedSourceConnector || this.sourceConnector).position();\n                    this._clearSourceConnector();\n                    this._setFromOptions(null, this._sourcePoint);\n                }\n            }\n            else if (source instanceof Connector) {\n                dataItem = source.shape.dataItem;\n                if (dataItem) {\n                    this._setFromOptions(dataItem.id);\n                }\n                this.sourceConnector = source;\n                this.sourceConnector.connections.push(this);\n            }\n            else if (source instanceof Point) {\n                this._setFromOptions(null, source);\n                this._sourcePoint = source;\n                if (this.sourceConnector) {\n                    this._clearSourceConnector();\n                }\n            }\n            else if (shapeSource) {\n                dataItem = source.dataItem;\n                if (dataItem) {\n                    this._setFromOptions(dataItem.id);\n                }\n                this.sourceConnector = source.getConnector(defaultConnector);\n                this.sourceConnector.connections.push(this);\n            }\n        }\n        source(source, undoable) {\n            if (isDefined(source)) {\n                if (undoable && this.diagram) {\n                    this.diagram.undoRedoService.addCompositeItem(new ConnectionEditUnit(this, source));\n                }\n                this._setSource(source);\n                this.refresh();\n            }\n            return this.sourceConnector ? this.sourceConnector : this._sourcePoint;\n        }\n        _setFromOptions(from, fromPoint) {\n            this.options.from = from;\n            if (fromPoint) {\n                this.options.fromX = fromPoint.x;\n                this.options.fromY = fromPoint.y;\n            }\n            else {\n                this.options.fromX = null;\n                this.options.fromY = null;\n            }\n        }\n        /**\n         * Gets or sets the PathDefiner of the sourcePoint.\n         * The left part of this definer is always null since it defines the source tangent.\n         *\n         * @param value\n         * @returns {*}\n         */\n        sourceDefiner(value) {\n            if (value) {\n                if (value instanceof PathDefiner) {\n                    value.left = null;\n                    this._sourceDefiner = value;\n                    this.source(value.point); // refresh implicit here\n                }\n                else {\n                    throw new Error('The sourceDefiner needs to be a PathDefiner.');\n                }\n            }\n            else {\n                if (!this._sourceDefiner) {\n                    this._sourceDefiner = new PathDefiner(this.sourcePoint(), null, null);\n                }\n                return this._sourceDefiner;\n            }\n        }\n        /**\n         * Gets  the Point where the target of the connection resides.\n         */\n        targetPoint() {\n            return this._resolvedTargetConnector ? this._resolvedTargetConnector.position() : this._targetPoint;\n        }\n        _setTarget(target) {\n            const shapeTarget = target instanceof Shape;\n            const defaultConnector = this.options.toConnector || AUTO;\n            let dataItem;\n            if (shapeTarget && !target.getConnector(defaultConnector)) {\n                return;\n            }\n            if (target !== undefined) {\n                this.to = target;\n            }\n            this._removeFromTargetConnector();\n            if (target === null) { // detach\n                if (this.targetConnector) {\n                    this._targetPoint = (this._resolvedTargetConnector || this.targetConnector).position();\n                    this._clearTargetConnector();\n                    this._setToOptions(null, this._targetPoint);\n                }\n            }\n            else if (target instanceof Connector) {\n                dataItem = target.shape.dataItem;\n                if (dataItem) {\n                    this._setToOptions(dataItem.id);\n                }\n                this.targetConnector = target;\n                this.targetConnector.connections.push(this);\n            }\n            else if (target instanceof Point) {\n                this._setToOptions(null, target);\n                this._targetPoint = target;\n                if (this.targetConnector) {\n                    this._clearTargetConnector();\n                }\n            }\n            else if (shapeTarget) {\n                dataItem = target.dataItem;\n                if (dataItem) {\n                    this._setToOptions(dataItem.id);\n                }\n                this.targetConnector = target.getConnector(defaultConnector);\n                this.targetConnector.connections.push(this);\n            }\n        }\n        target(target, undoable) {\n            if (isDefined(target)) {\n                if (undoable && this.diagram) {\n                    this.diagram.undoRedoService.addCompositeItem(new ConnectionEditUnit(this, undefined, target));\n                }\n                this._setTarget(target);\n                this.refresh();\n            }\n            return this.targetConnector ? this.targetConnector : this._targetPoint;\n        }\n        _setToOptions(to, toPoint) {\n            this.options.to = to;\n            if (toPoint) {\n                this.options.toX = toPoint.x;\n                this.options.toY = toPoint.y;\n            }\n            else {\n                this.options.toX = null;\n                this.options.toY = null;\n            }\n        }\n        /**\n         * Gets or sets the PathDefiner of the targetPoint.\n         * The right part of this definer is always null since it defines the target tangent.\n         *\n         * @param value\n         * @returns {*}\n         */\n        targetDefiner(value) {\n            if (value) {\n                if (value instanceof PathDefiner) {\n                    value.right = null;\n                    this._targetDefiner = value;\n                    this.target(value.point); // refresh implicit here\n                }\n                else {\n                    throw new Error('The sourceDefiner needs to be a PathDefiner.');\n                }\n            }\n            else {\n                if (!this._targetDefiner) {\n                    this._targetDefiner = new PathDefiner(this.targetPoint(), null, null);\n                }\n                return this._targetDefiner;\n            }\n        }\n        _updateConnectors() {\n            this._updateConnector(this.source(), 'source');\n            this._updateConnector(this.target(), 'target');\n        }\n        _updateConnector(instance, name) {\n            const diagram = this.diagram;\n            if (instance instanceof Connector && !diagram.getShapeById(instance.shape.id)) {\n                const dataItem = instance.shape.dataItem;\n                const connectorName = instance.options.name;\n                const setNewTarget = () => {\n                    const shape = diagram._dataMap[dataItem.id];\n                    instance = shape.getConnector(connectorName);\n                    this[name](instance, false);\n                    this.updateModel();\n                };\n                if (diagram._dataMap[dataItem.id]) {\n                    setNewTarget();\n                }\n                else {\n                    const inactiveItem = diagram._inactiveShapeItems.getByUid(dataItem.uid);\n                    if (inactiveItem) {\n                        diagram._deferredConnectionUpdates.push(inactiveItem.onActivate(setNewTarget));\n                    }\n                }\n            }\n            else {\n                this[name](instance, false);\n            }\n        }\n        content(content) {\n            const result = this._content(content);\n            if (defined(content)) {\n                this._alignContent();\n            }\n            return result;\n        }\n        _createContentVisual(options) {\n            let visual;\n            if (isFunction$1(options.visual)) {\n                visual = options.visual.call(this, options);\n            }\n            else if (options.text) {\n                visual = new TextBlock(options);\n            }\n            if (visual) {\n                this._contentVisual = visual;\n                visual._includeInBBox = false;\n                this.visual.append(visual);\n            }\n            return visual;\n        }\n        _updateContentVisual(options) {\n            if (isFunction$1(options.visual)) {\n                this.visual.remove(this._contentVisual);\n                this._createContentVisual(options);\n            }\n            else {\n                this._contentVisual.redraw(options);\n            }\n        }\n        _alignContent() {\n            if (this._contentVisual) {\n                let offset = CONNECTION_CONTENT_OFFSET;\n                const points = this.allPoints();\n                let endIdx = Math.floor(points.length / 2);\n                let startIdx = endIdx - 1;\n                while (startIdx > 0 && points[startIdx].equals(points[endIdx])) {\n                    startIdx--;\n                    endIdx++;\n                }\n                let endPoint = points[endIdx];\n                let startPoint = points[startIdx];\n                const boundingBox = this._contentVisual._measure();\n                const width = boundingBox.width;\n                const height = boundingBox.height;\n                let alignToPath = points.length % 2 === 0;\n                const distance = startPoint.distanceTo(endPoint);\n                if (alignToPath && points.length > 2 && distance > 0 &&\n                    ((startPoint.y === endPoint.y && distance < width) || (startPoint.x === endPoint.x && distance < height))) {\n                    alignToPath = false;\n                    offset = 0;\n                }\n                let point;\n                if (alignToPath) {\n                    const angle = kendo_drawing_cmn_chunk_js.v(Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x));\n                    point = new Point((endPoint.x - startPoint.x) / 2 + startPoint.x, (endPoint.y - startPoint.y) / 2 + startPoint.y);\n                    if (Math.abs(angle) === 90) {\n                        point.x += offset;\n                        point.y -= height / 2;\n                    }\n                    else if (angle % 180 === 0) {\n                        point.x -= width / 2;\n                        point.y -= height + offset;\n                    }\n                    else if (angle < -90 || (0 < angle && angle < 90)) {\n                        point.y -= height;\n                    }\n                    else if (angle < 0 || angle > 90) {\n                        point.x -= width;\n                        point.y -= height;\n                    }\n                }\n                else {\n                    const midIdx = Math.floor(points.length / 2);\n                    point = points[midIdx].clone();\n                    startPoint = points[midIdx - 1];\n                    endPoint = points[midIdx + 1];\n                    const offsetX = startPoint.x <= point.x && endPoint.x <= point.x ? offset : -boundingBox.width - offset;\n                    const offsetY = startPoint.y <= point.y && endPoint.y <= point.y ? offset : -boundingBox.height - offset;\n                    point.x += offsetX;\n                    point.y += offsetY;\n                }\n                this._contentVisual.position(point);\n            }\n        }\n        /**\n         * Selects or unselects this connections.\n         *\n         * @param value True to select, false to unselect.\n         */\n        select(value) {\n            const diagram = this.diagram;\n            let selected, deselected;\n            if (this._canSelect()) {\n                if (this.isSelected !== value) {\n                    this.isSelected = value;\n                    selected = [];\n                    deselected = [];\n                    if (this.isSelected) {\n                        this.adorner = new ConnectionEditAdorner(this, this.options.selection);\n                        diagram._adorn(this.adorner, true);\n                        diagram._selectedItems.push(this);\n                        selected.push(this);\n                    }\n                    else {\n                        if (this.adorner) {\n                            diagram._adorn(this.adorner, false);\n                            remove(diagram._selectedItems, this);\n                            this.adorner = undefined;\n                            deselected.push(this);\n                        }\n                    }\n                    if (this.adorner) {\n                        this.adorner.refresh();\n                    }\n                    if (!diagram._internalSelection) {\n                        diagram._selectionChanged(selected, deselected);\n                    }\n                    return true;\n                }\n            }\n        }\n        /**\n         * Gets or sets the bounds of this connection.\n         *\n         * @param value A Rect object.\n         * @remark This is automatically set in the refresh().\n         * @returns {Rect}\n         */\n        bounds(value) {\n            if (value && !isString$1(value)) {\n                this._bounds = value;\n            }\n            else {\n                return this._bounds;\n            }\n        }\n        /**\n         * Gets or sets the connection type (see ConnectionType enumeration).\n         *\n         * @param value A ConnectionType value.\n         * @returns {ConnectionType}\n         */\n        type(value) {\n            const options = this.options;\n            if (value) {\n                if (value !== options.type) {\n                    options.type = value;\n                    this._initRouter();\n                    this.refresh();\n                }\n            }\n            else {\n                return options.type;\n            }\n        }\n        _initRouter() {\n            const type = (this.options.type || '').toLowerCase();\n            if (type === CASCADING) {\n                this._router = new CascadingRouter(this);\n            }\n            else {\n                this._router = new PolylineRouter(this);\n            }\n        }\n        /**\n         * Gets or sets the collection of *intermediate* points.\n         * The 'allPoints()' property will return all the points.\n         * The 'definers' property returns the definers of the intermediate points.\n         * The 'sourceDefiner' and 'targetDefiner' return the definers of the endpoints.\n         *\n         * @param value\n         */\n        points(value) {\n            if (value) {\n                this.definers = [];\n                for (let i = 0; i < value.length; i++) {\n                    const definition = value[i];\n                    if (definition instanceof Point) {\n                        this.definers.push(new PathDefiner(definition));\n                    }\n                    else if (Object.prototype.hasOwnProperty.call(definition, 'x') && Object.prototype.hasOwnProperty.call(definition, 'y')) { // e.g. Clipboard does not preserve the Point definition and turned into an Object\n                        this.definers.push(new PathDefiner(new Point(definition.x, definition.y)));\n                    }\n                    else {\n                        throw new Error('A Connection point needs to be a Point or an object with x and y properties.');\n                    }\n                }\n            }\n            else {\n                const pts = [];\n                if (isDefined(this.definers)) {\n                    for (let k = 0; k < this.definers.length; k++) {\n                        pts.push(this.definers[k].point);\n                    }\n                }\n                return pts;\n            }\n        }\n        /**\n         * Gets all the points of this connection. This is the combination of the sourcePoint, the points and the targetPoint.\n         *\n         * @returns {Array}\n         */\n        allPoints() {\n            const pts = [this.sourcePoint()];\n            if (this.definers) {\n                for (let k = 0; k < this.definers.length; k++) {\n                    pts.push(this.definers[k].point);\n                }\n            }\n            pts.push(this.targetPoint());\n            return pts;\n        }\n        refresh() {\n            this._resolveConnectors();\n            this._refreshPath();\n            this._alignContent();\n            if (this.adorner) {\n                this.adorner.refresh();\n            }\n        }\n        _resolveConnectors() {\n            let sourcePoint, targetPoint, sourceConnectors, targetConnectors;\n            const source = this.source(), target = this.target();\n            if (source instanceof Point) {\n                sourcePoint = source;\n            }\n            else if (source instanceof Connector) {\n                if (isAutoConnector(source)) {\n                    sourceConnectors = source.shape.connectors;\n                }\n                else {\n                    sourceConnectors = [source];\n                }\n            }\n            if (target instanceof Point) {\n                targetPoint = target;\n            }\n            else if (target instanceof Connector) {\n                if (isAutoConnector(target)) {\n                    targetConnectors = target.shape.connectors;\n                }\n                else {\n                    targetConnectors = [target];\n                }\n            }\n            if (sourcePoint) {\n                if (targetConnectors) {\n                    this._resolvedTargetConnector = closestConnector(sourcePoint, targetConnectors);\n                }\n            }\n            else if (sourceConnectors) {\n                if (targetPoint) {\n                    this._resolvedSourceConnector = closestConnector(targetPoint, sourceConnectors);\n                }\n                else if (targetConnectors) {\n                    this._resolveAutoConnectors(sourceConnectors, targetConnectors);\n                }\n            }\n        }\n        _resolveAutoConnectors(sourceConnectors, targetConnectors) {\n            let minNonConflict = MAXINT;\n            let minDist = MAXINT;\n            let minNonConflictSource, minNonConflictTarget;\n            let sourcePoint, targetPoint;\n            let minSource, minTarget;\n            let sourceConnector, targetConnector;\n            let sourceIdx, targetIdx;\n            let dist;\n            for (sourceIdx = 0; sourceIdx < sourceConnectors.length; sourceIdx++) {\n                sourceConnector = sourceConnectors[sourceIdx];\n                if (!isAutoConnector(sourceConnector)) {\n                    sourcePoint = sourceConnector.position();\n                    for (targetIdx = 0; targetIdx < targetConnectors.length; targetIdx++) {\n                        targetConnector = targetConnectors[targetIdx];\n                        if (!isAutoConnector(targetConnector)) {\n                            targetPoint = targetConnector.position();\n                            dist = Math.round(sourcePoint.distanceTo(targetPoint));\n                            if (dist < minNonConflict && this.diagram && this._testRoutePoints(sourcePoint, targetPoint, sourceConnector, targetConnector)) {\n                                minNonConflict = dist;\n                                minNonConflictSource = sourceConnector;\n                                minNonConflictTarget = targetConnector;\n                            }\n                            if (dist < minDist) {\n                                minSource = sourceConnector;\n                                minTarget = targetConnector;\n                                minDist = dist;\n                            }\n                        }\n                    }\n                }\n            }\n            if (minNonConflictSource) {\n                minSource = minNonConflictSource;\n                minTarget = minNonConflictTarget;\n            }\n            this._resolvedSourceConnector = minSource;\n            this._resolvedTargetConnector = minTarget;\n        }\n        _testRoutePoints(sourcePoint, targetPoint, sourceConnector, targetConnector) {\n            const router = this._router;\n            let passRoute = true;\n            if (router instanceof CascadingRouter) {\n                const points = router.routePoints(sourcePoint, targetPoint, sourceConnector, targetConnector), exclude = this._getRouteExclude(sourcePoint, targetPoint, sourceConnector.shape, targetConnector.shape);\n                let start, end, rect;\n                points.unshift(sourcePoint);\n                points.push(targetPoint);\n                for (let idx = 1; idx < points.length; idx++) {\n                    start = points[idx - 1];\n                    end = points[idx];\n                    rect = new Rect(Math.min(start.x, end.x), Math.min(start.y, end.y), Math.abs(start.x - end.x), Math.abs(start.y - end.y));\n                    if (rect.width > 0) {\n                        rect.x++;\n                        rect.width -= 2;\n                    }\n                    if (rect.height > 0) {\n                        rect.y++;\n                        rect.height -= 2;\n                    }\n                    if (!rect.isEmpty() && this.diagram._shapesQuadTree.hitTestRect(rect, exclude)) {\n                        passRoute = false;\n                        break;\n                    }\n                }\n            }\n            return passRoute;\n        }\n        _getRouteExclude(sourcePoint, targetPoint, sourceShape, targetShape) {\n            const exclude = [];\n            if (this._isPointInsideShape(sourcePoint, sourceShape)) {\n                exclude.push(sourceShape);\n            }\n            if (this._isPointInsideShape(targetPoint, targetShape)) {\n                exclude.push(targetShape);\n            }\n            return exclude;\n        }\n        _isPointInsideShape(point, shape) {\n            const bounds = shape.bounds(), angle = shape.rotate().angle, boundsX = bounds.x, boundsY = bounds.y;\n            const rotatedPoint = point.clone().rotate(angle, bounds.center());\n            const pointX = rotatedPoint.x;\n            const pointY = rotatedPoint.y;\n            return pointX > boundsX && pointX < (boundsX + bounds.width) && pointY > boundsY && pointY < (boundsY + bounds.height);\n        }\n        redraw(options) {\n            if (options) {\n                this.options = deepExtend({}, this.options, options);\n                const points = this.options.points;\n                if (defined(points) && points.length > 0) {\n                    this.points(points);\n                    this._refreshPath();\n                }\n                if ((options && options.content) || options.text) {\n                    this.content(options.content);\n                }\n                this.path.redraw({\n                    fill: options.fill,\n                    stroke: options.stroke,\n                    startCap: options.startCap,\n                    endCap: options.endCap\n                });\n            }\n        }\n        /**\n         * Returns a clone of this connection.\n         *\n         * @returns {Connection}\n         */\n        clone() {\n            const json = this.serialize();\n            if (this.diagram && this.diagram._isEditable && defined(this.dataItem)) {\n                json.options.dataItem = this.diagram.options.cloneDataItem(this.dataItem);\n            }\n            return new Connection(this.from, this.to, json.options);\n        }\n        /**\n         * Returns a serialized connection in json format. Consist of the options and the dataItem.\n         *\n         * @returns {Connection}\n         */\n        serialize() {\n            const from = this.from.toJSON ? this.from.toJSON : this.from.toString(), to = this.to.toJSON ? this.to.toJSON : this.to.toString();\n            const json = deepExtend({}, {\n                options: this.options,\n                from: from,\n                to: to\n            });\n            if (defined(this.dataItem)) {\n                json.dataItem = this.dataItem.toString();\n            }\n            json.options.points = this.points();\n            return json;\n        }\n        /**\n         * Returns whether the given Point or Rect hits this connection.\n         *\n         * @param value\n         * @returns {Connection}\n         * @private\n         */\n        _hitTest(value) {\n            if (this.visible()) {\n                const p = new Point(value.x, value.y), from = this.sourcePoint(), to = this.targetPoint();\n                if (value.isEmpty && !value.isEmpty() && value.contains(from) && value.contains(to)) {\n                    return this;\n                }\n                if (this._router.hitTest(p)) {\n                    return this;\n                }\n            }\n        }\n        _hover(value) {\n            let color = (this.options.stroke || {}).color;\n            if (value && isDefined(this.options.hover.stroke.color)) {\n                color = this.options.hover.stroke.color;\n            }\n            this.path.redraw({\n                stroke: {\n                    color: color\n                }\n            });\n        }\n        _refreshPath() {\n            if (!defined(this.path)) {\n                return;\n            }\n            this._drawPath();\n            this.bounds(this._router.getBounds());\n        }\n        _drawPath() {\n            if (this._router) {\n                this._router.route(); // sets the intermediate points\n            }\n            const source = this.sourcePoint();\n            const target = this.targetPoint();\n            const points = this.points();\n            this.path.redraw({\n                points: [source].concat(points, [target])\n            });\n        }\n        _clearSourceConnector() {\n            this.sourceConnector = undefined;\n            this._resolvedSourceConnector = undefined;\n        }\n        _clearTargetConnector() {\n            this.targetConnector = undefined;\n            this._resolvedTargetConnector = undefined;\n        }\n        _removeFromSourceConnector() {\n            if (this.sourceConnector) {\n                remove(this.sourceConnector.connections, this);\n            }\n        }\n        _removeFromTargetConnector() {\n            if (this.targetConnector) {\n                remove(this.targetConnector.connections, this);\n            }\n        }\n        toJSON() {\n            let from, to, point;\n            if (this.from && this.from.toJSON) {\n                from = this.from.toJSON();\n            }\n            else {\n                point = this._sourcePoint;\n                from = {\n                    x: point.x,\n                    y: point.y\n                };\n            }\n            if (this.to && this.to.toJSON) {\n                to = this.to.toJSON();\n            }\n            else {\n                point = this._targetPoint;\n                to = {\n                    x: point.x,\n                    y: point.y\n                };\n            }\n            return {\n                from: from,\n                to: to\n            };\n        }\n    }\n\n    const round = kendo_drawing_cmn_chunk_js.r;\n    function hitTestShapeConnectors(shape, point) {\n        let connector, position, rect;\n        for (let idx = 0; idx < shape.connectors.length; idx++) {\n            connector = shape.connectors[idx];\n            position = connector.position();\n            rect = new Rect(position.x, position.y);\n            rect.inflate(HIT_TEST_DISTANCE, HIT_TEST_DISTANCE);\n            if (rect.contains(point)) {\n                return connector;\n            }\n        }\n    }\n    /**\n     * The service managing the tools.\n     *\n     * @type {*}\n     */\n    class ToolService {\n        constructor(diagram) {\n            this.diagram = diagram;\n            this.tools = [\n                new ScrollerTool(this),\n                new ConnectionEditTool(this),\n                new ConnectionTool(this),\n                new SelectionTool(this),\n                new PointerTool(this)\n            ]; // the order matters.\n            this.activeTool = undefined;\n        }\n        start(p, meta) {\n            meta = deepExtend({}, meta);\n            if (this.activeTool) {\n                this.activeTool.end(p, meta);\n            }\n            this._updateHoveredItem(p);\n            this._activateTool(p, meta);\n            this.activeTool.start(p, meta);\n            this._updateCursor(p);\n            this.diagram.focus();\n            this.diagram.canvas.surface.suspendTracking();\n            this.startPoint = p;\n            return true;\n        }\n        move(p, meta) {\n            meta = deepExtend({}, meta);\n            let updateHovered = true;\n            if (this.activeTool) {\n                updateHovered = this.activeTool.move(p, meta);\n            }\n            if (updateHovered) {\n                this._updateHoveredItem(p);\n            }\n            this._updateCursor(p);\n            return true;\n        }\n        end(p, meta) {\n            meta = deepExtend({}, meta);\n            if (this.activeTool) {\n                this.activeTool.end(p, meta);\n            }\n            this.diagram.canvas.surface.resumeTracking();\n            this.activeTool = undefined;\n            this._updateCursor(p);\n            return true;\n        }\n        keyDown(key, meta) {\n            const diagram = this.diagram;\n            meta = deepExtend({ ctrlKey: false, metaKey: false, altKey: false }, meta);\n            if ((meta.ctrlKey || meta.metaKey) && !meta.altKey) { // ctrl or option\n                if (testKey(key, 'a')) { // A: select all\n                    diagram.selectAll();\n                    diagram._destroyToolBar();\n                    return true;\n                }\n                else if (testKey(key, 'z')) { // Z: undo\n                    diagram.undo();\n                    diagram._destroyToolBar();\n                    return true;\n                }\n                else if (testKey(key, 'y')) { // y: redo\n                    diagram.redo();\n                    diagram._destroyToolBar();\n                    return true;\n                }\n                else if (testKey(key, 'c')) {\n                    diagram.copy();\n                    diagram._destroyToolBar();\n                }\n                else if (testKey(key, 'x')) {\n                    diagram.cut();\n                    diagram._destroyToolBar();\n                }\n                else if (testKey(key, 'v')) {\n                    diagram.paste();\n                    diagram._destroyToolBar();\n                }\n                else if (testKey(key, 'l')) {\n                    diagram.layout();\n                    diagram._destroyToolBar();\n                }\n                else if (testKey(key, 'd')) {\n                    diagram._destroyToolBar();\n                    diagram.copy();\n                    diagram.paste();\n                }\n            }\n            else if (key === 46 || key === 8) { // del: deletion\n                const toRemove = this.diagram._triggerRemove(diagram.select());\n                if (toRemove.length) {\n                    this.diagram.remove(toRemove, true);\n                    this.diagram._syncChanges();\n                    this.diagram._destroyToolBar();\n                }\n                return true;\n            }\n            else if (key === 27) { // ESC: stop any action\n                this._discardNewConnection();\n                diagram.deselect();\n                diagram._destroyToolBar();\n                return true;\n            }\n        }\n        wheel(p, meta) {\n            const diagram = this.diagram;\n            let z = diagram.zoom();\n            const delta = meta.delta, options = diagram.options, zoomRate = options.zoomRate, zoomOptions = { point: p, meta: meta, zoom: z };\n            if (diagram.trigger(ZOOM_START, zoomOptions)) {\n                return;\n            }\n            if (delta < 0) {\n                z += zoomRate;\n            }\n            else {\n                z -= zoomRate;\n            }\n            z = round(Math.max(options.zoomMin, Math.min(options.zoomMax, z)), 2);\n            zoomOptions.zoom = z;\n            diagram.zoom(z, zoomOptions);\n            diagram.trigger(ZOOM_END, zoomOptions);\n            return true;\n        }\n        setTool(tool, index) {\n            tool.toolService = this;\n            this.tools[index] = tool;\n        }\n        selectSingle(item, meta) {\n            const diagram = this.diagram;\n            const selectable = diagram.options.selectable;\n            if (selectable && !item.isSelected && item.options.selectable !== false) {\n                const addToSelection = meta.ctrlKey && selectable.multiple !== false;\n                diagram.select(item, { addToSelection: addToSelection });\n            }\n        }\n        _discardNewConnection() {\n            if (this.newConnection) {\n                this.diagram.remove(this.newConnection);\n                this.newConnection = undefined;\n            }\n        }\n        _activateTool(p, meta) {\n            for (let i = 0; i < this.tools.length; i++) {\n                const tool = this.tools[i];\n                if (tool.tryActivate(p, meta)) {\n                    this.activeTool = tool;\n                    break; // activating the first available tool in the loop.\n                }\n            }\n        }\n        _updateCursor(p) {\n            const element = this.diagram.element;\n            const cursor = this.activeTool ? this.activeTool.getCursor(p) : (this.hoveredAdorner ? this.hoveredAdorner._getCursor(p) : (this.hoveredItem ? this.hoveredItem._getCursor(p) : Cursors.arrow));\n            element.style.cursor = cursor;\n        }\n        _connectionManipulation(connection, disabledShape, isNew) {\n            this.activeConnection = connection;\n            this.disabledShape = disabledShape;\n            if (isNew) {\n                this.newConnection = this.activeConnection;\n            }\n            else {\n                this.newConnection = undefined;\n            }\n        }\n        _updateHoveredItem(p) {\n            const hit = this._hitTest(p);\n            const diagram = this.diagram;\n            if (hit !== this.hoveredItem && (!this.disabledShape || hit !== this.disabledShape)) {\n                if (this.hoveredItem) {\n                    diagram.trigger(MOUSE_LEAVE, { item: this.hoveredItem });\n                    this.hoveredItem._hover(false);\n                }\n                if (hit && hit.options.enable) {\n                    diagram.trigger(MOUSE_ENTER, { item: hit });\n                    this.hoveredItem = hit; // Shape, connection or connector\n                    this.hoveredItem._hover(true);\n                }\n                else {\n                    this.hoveredItem = undefined;\n                }\n            }\n        }\n        _removeHover() {\n            if (this.hoveredItem) {\n                this.hoveredItem._hover(false);\n                this.hoveredItem = undefined;\n            }\n        }\n        _hitTest(point) {\n            const d = this.diagram;\n            let hit, item, i;\n            // connectors\n            if (this._hoveredConnector) {\n                this._hoveredConnector._hover(false);\n                this._hoveredConnector = undefined;\n            }\n            if (d._connectorsAdorner._visible) {\n                hit = d._connectorsAdorner._hitTest(point);\n                if (hit) {\n                    return hit;\n                }\n            }\n            hit = this.diagram._resizingAdorner._hitTest(point);\n            if (hit) {\n                this.hoveredAdorner = d._resizingAdorner;\n                if (hit.x !== 0 || hit.y !== 0) { // hit testing for resizers or rotator, otherwise if (0,0) than pass through.\n                    return;\n                }\n                hit = undefined;\n            }\n            else {\n                this.hoveredAdorner = undefined;\n            }\n            if (!this.activeTool || this.activeTool.type !== 'ConnectionTool') {\n                const selectedConnections = []; // only the connections should have higher presence because the connection edit point is on top of connector.\n                // TODO: This should be reworked. The connection adorner should be one for all selected connections and should be hit tested prior the connections and shapes itself.\n                for (i = 0; i < d._selectedItems.length; i++) {\n                    item = d._selectedItems[i];\n                    if (item instanceof Connection) {\n                        selectedConnections.push(item);\n                    }\n                }\n                hit = this._hitTestItems(selectedConnections, point);\n            }\n            return hit || this._hitTestElements(point);\n        }\n        _hitTestElements(point) {\n            const diagram = this.diagram;\n            const shapeHit = this._hitTestItems(diagram.shapes, point);\n            const connectionHit = this._hitTestItems(diagram.connections, point);\n            let hit;\n            if ((!this.activeTool || this.activeTool.type !== 'ConnectionTool') && shapeHit && connectionHit && !hitTestShapeConnectors(shapeHit, point)) {\n                const mainLayer = diagram.mainLayer;\n                const shapeIdx = inArray(shapeHit.visual, mainLayer.children);\n                const connectionIdx = inArray(connectionHit.visual, mainLayer.children);\n                hit = shapeIdx > connectionIdx ? shapeHit : connectionHit;\n            }\n            return hit || shapeHit || connectionHit;\n        }\n        _hitTestItems(array, point) {\n            let i, item, hit;\n            for (i = array.length - 1; i >= 0; i--) {\n                item = array[i];\n                hit = item._hitTest(point);\n                if (hit) {\n                    return hit;\n                }\n            }\n        }\n    }\n\n    class AddConnectionUnit {\n        constructor(connection, diagram) {\n            this.connection = connection;\n            this.diagram = diagram;\n            this.title = 'New connection';\n        }\n        undo() {\n            this.diagram.remove(this.connection, false);\n        }\n        redo() {\n            this.diagram._addConnection(this.connection, false);\n        }\n    }\n\n    class AddShapeUnit {\n        constructor(shape, diagram) {\n            this.shape = shape;\n            this.diagram = diagram;\n            this.title = 'New shape';\n        }\n        undo() {\n            this.diagram.deselect();\n            this.diagram.remove(this.shape, false);\n        }\n        redo() {\n            this.diagram._addShape(this.shape, false);\n        }\n    }\n\n    class CompositeUnit {\n        constructor(unit) {\n            this.units = [];\n            this.title = 'Composite unit';\n            if (unit !== undefined) {\n                this.units.push(unit);\n            }\n        }\n        add(undoUnit) {\n            this.units.push(undoUnit);\n        }\n        undo() {\n            for (let i = 0; i < this.units.length; i++) {\n                this.units[i].undo();\n            }\n        }\n        redo() {\n            for (let i = 0; i < this.units.length; i++) {\n                this.units[i].redo();\n            }\n        }\n    }\n\n    class DeleteConnectionUnit {\n        constructor(connection) {\n            this.connection = connection;\n            this.diagram = connection.diagram;\n            this.targetConnector = connection.targetConnector;\n            this.title = 'Delete connection';\n        }\n        undo() {\n            this.diagram._addConnection(this.connection, false);\n        }\n        redo() {\n            this.diagram.remove(this.connection, false);\n        }\n    }\n\n    class DeleteShapeUnit {\n        constructor(shape) {\n            this.shape = shape;\n            this.diagram = shape.diagram;\n            this.title = 'Deletion';\n        }\n        undo() {\n            this.diagram._addShape(this.shape, false);\n            this.shape.select(false);\n        }\n        redo() {\n            this.shape.select(false);\n            this.diagram.remove(this.shape, false);\n        }\n    }\n\n    class PositionAdapter {\n        constructor(layoutState) {\n            this.layoutState = layoutState;\n            this.diagram = layoutState.diagram;\n        }\n        initState() {\n            this.froms = [];\n            this.tos = [];\n            this.subjects = [];\n            const pusher = (id, bounds) => {\n                const shape = this.diagram.getShapeById(id);\n                if (shape) {\n                    this.subjects.push(shape);\n                    this.froms.push(shape.bounds().topLeft());\n                    this.tos.push(bounds.topLeft());\n                }\n            };\n            this.layoutState.nodeMap.forEach(pusher, this);\n        }\n        update(tick) {\n            if (this.subjects.length <= 0) {\n                return;\n            }\n            for (let i = 0; i < this.subjects.length; i++) {\n                // todo: define a Lerp function instead\n                this.subjects[i].position(new Point(this.froms[i].x + (this.tos[i].x - this.froms[i].x) * tick, this.froms[i].y + (this.tos[i].y - this.froms[i].y) * tick));\n            }\n        }\n    }\n\n    class LayoutUndoUnit {\n        constructor(initialState, finalState, animate) {\n            if (isUndefined(animate)) {\n                this.animate = false;\n            }\n            else {\n                this.animate = Boolean(animate);\n            }\n            this._initialState = initialState;\n            this._finalState = finalState;\n            this.title = 'Diagram layout';\n        }\n        undo() {\n            this.setState(this._initialState);\n        }\n        redo() {\n            this.setState(this._finalState);\n        }\n        setState(state) {\n            const diagram = state.diagram;\n            if (this.animate) {\n                state.linkMap.forEach(function (id, points) {\n                    const conn = diagram.getShapeById(id);\n                    conn.visible(false);\n                    if (conn) {\n                        conn.points(points);\n                    }\n                });\n                const ticker = new Ticker();\n                ticker.addAdapter(new PositionAdapter(state));\n                ticker.onComplete(function () {\n                    state.linkMap.forEach(function (id) {\n                        const conn = diagram.getShapeById(id);\n                        conn.visible(true);\n                    });\n                });\n                ticker.play();\n            }\n            else {\n                state.nodeMap.forEach(function (id, bounds) {\n                    const shape = diagram.getShapeById(id);\n                    if (shape) {\n                        shape.position(bounds.topLeft());\n                    }\n                });\n                state.linkMap.forEach(function (id, points) {\n                    const conn = diagram.getShapeById(id);\n                    if (conn) {\n                        conn.points(points);\n                    }\n                });\n            }\n        }\n    }\n\n    class PanUndoUnit {\n        constructor(initialPosition, finalPosition, diagram) {\n            this.initial = initialPosition;\n            this.finalPos = finalPosition;\n            this.diagram = diagram;\n            this.title = 'Pan Unit';\n        }\n        undo() {\n            this.diagram.pan(this.initial);\n        }\n        redo() {\n            this.diagram.pan(this.finalPos);\n        }\n    }\n\n    class ToBackUnit {\n        constructor(diagram, items, initialIndices) {\n            this.diagram = diagram;\n            this.indices = initialIndices;\n            this.items = items;\n            this.title = 'Rotate Unit';\n        }\n        undo() {\n            this.diagram._toIndex(this.items, this.indices);\n        }\n        redo() {\n            this.diagram.toBack(this.items, false);\n        }\n    }\n\n    class ToFrontUnit {\n        constructor(diagram, items, initialIndices) {\n            this.diagram = diagram;\n            this.indices = initialIndices;\n            this.items = items;\n            this.title = 'Rotate Unit';\n        }\n        undo() {\n            this.diagram._toIndex(this.items, this.indices);\n        }\n        redo() {\n            this.diagram.toFront(this.items, false);\n        }\n    }\n\n    /**\n     * Undo-redo service.\n     */\n    class UndoRedoService extends Observable {\n        constructor(options = {}) {\n            super();\n            this.events = ['undone', 'redone'];\n            this.bind(this.events, options);\n            this.stack = [];\n            this.index = 0;\n            this.capacity = 100;\n        }\n        /**\n         * Starts the collection of units. Add those with\n         * the addCompositeItem method and call commit. Or cancel to forget about it.\n         */\n        begin() {\n            this.composite = new CompositeUnit();\n        }\n        /**\n         * Cancels the collection process of unit started with 'begin'.\n         */\n        cancel() {\n            this.composite = undefined;\n        }\n        /**\n         * Commits a batch of units.\n         */\n        commit(execute) {\n            if (this.composite.units.length > 0) {\n                this._restart(this.composite, execute);\n            }\n            this.composite = undefined;\n        }\n        /**\n         * Adds a unit as part of the begin-commit batch.\n         *\n         * @param undoUnit\n         */\n        addCompositeItem(undoUnit) {\n            if (this.composite) {\n                this.composite.add(undoUnit);\n            }\n            else {\n                this.add(undoUnit);\n            }\n        }\n        /**\n         * Standard addition of a unit. See also the batch version; begin-addCompositeUnit-commit methods.\n         *\n         * @param undoUnit The unit to be added.\n         * @param execute If false, the unit will be added but not executed.\n         */\n        add(undoUnit, execute) {\n            this._restart(undoUnit, execute);\n        }\n        /**\n         * Returns the number of undoable unit in the stack.\n         *\n         * @returns {Number}\n         */\n        pop() {\n            if (this.index > 0) {\n                this.stack.pop();\n                this.index--;\n            }\n        }\n        count() {\n            return this.stack.length;\n        }\n        /**\n         * Rollback of the unit on top of the stack.\n         */\n        undo() {\n            if (this.index > 0) {\n                this.index--;\n                this.stack[this.index].undo();\n                this.trigger('undone');\n            }\n        }\n        /**\n         * Redo of the last undone action.\n         */\n        redo() {\n            if (this.stack.length > 0 && this.index < this.stack.length) {\n                this.stack[this.index].redo();\n                this.index++;\n                this.trigger('redone');\n            }\n        }\n        _restart(composite, execute) {\n            // throw away anything beyond this point if this is a new branch\n            this.stack.splice(this.index, this.stack.length - this.index);\n            this.stack.push(composite);\n            if (execute !== false) {\n                this.redo();\n            }\n            else {\n                this.index++;\n            }\n            // check the capacity\n            if (this.stack.length > this.capacity) {\n                this.stack.splice(0, this.stack.length - this.capacity);\n                this.index = this.capacity; // points to the end of the stack\n            }\n        }\n        /**\n         * Clears the stack.\n         */\n        clear() {\n            this.stack = [];\n            this.index = 0;\n        }\n    }\n\n    class InactiveItem {\n        constructor(dataItem) {\n            this.dataItem = dataItem;\n            this.callbacks = [];\n        }\n        onActivate(callback) {\n            return new Promise((resolve) => {\n                this.callbacks.push({\n                    callback,\n                    resolve\n                });\n            });\n        }\n        activate() {\n            const callbacks = this.callbacks;\n            let item;\n            for (let idx = 0; idx < callbacks.length; idx++) {\n                item = this.callbacks[idx];\n                item.callback(this.dataItem);\n                item.resolve();\n            }\n            this.callbacks = [];\n        }\n    }\n    class InactiveItemsCollection {\n        constructor() {\n            this.items = {};\n        }\n        add(items) {\n            for (let idx = 0; idx < items.length; idx++) {\n                this.items[items[idx].uid] = new InactiveItem(items[idx]);\n            }\n        }\n        forEach(callback) {\n            for (const uid in this.items) {\n                if (Object.prototype.hasOwnProperty.call(this.items, uid)) {\n                    callback(this.items[uid]);\n                }\n            }\n        }\n        getByUid(uid) {\n            return this.items[uid];\n        }\n        remove(item) {\n            delete this.items[item.uid];\n        }\n        destroy() {\n            this.items = {};\n        }\n    }\n\n    class QuadRoot {\n        constructor() {\n            this.shapes = [];\n        }\n        _add(shape, bounds) {\n            this.shapes.push({\n                bounds: bounds,\n                shape: shape\n            });\n            shape._quadNode = this;\n        }\n        insert(shape, bounds) {\n            this._add(shape, bounds);\n        }\n        remove(shape) {\n            const shapes = this.shapes;\n            const length = shapes.length;\n            for (let idx = 0; idx < length; idx++) {\n                if (shapes[idx].shape === shape) {\n                    shapes.splice(idx, 1);\n                    break;\n                }\n            }\n        }\n        hitTestRect(rect, exclude) {\n            const shapes = this.shapes;\n            const length = shapes.length;\n            for (let i = 0; i < length; i++) {\n                if (this._testRect(shapes[i].shape, rect) && !contains(exclude, shapes[i].shape)) {\n                    return true;\n                }\n            }\n        }\n        _testRect(shape, rect) {\n            const angle = shape.rotate().angle;\n            const bounds = shape.bounds();\n            let hit;\n            if (!angle) {\n                hit = bounds.overlaps(rect);\n            }\n            else {\n                hit = Intersect.rects(rect, bounds, -angle);\n            }\n            return hit;\n        }\n    }\n\n    class QuadNode extends QuadRoot {\n        constructor(rect) {\n            super();\n            this.children = [];\n            this.rect = rect;\n        }\n        inBounds(rect) {\n            const nodeRect = this.rect;\n            const nodeBottomRight = nodeRect.bottomRight();\n            const bottomRight = rect.bottomRight();\n            const inBounds = nodeRect.x <= rect.x && nodeRect.y <= rect.y && bottomRight.x <= nodeBottomRight.x &&\n                bottomRight.y <= nodeBottomRight.y;\n            return inBounds;\n        }\n        overlapsBounds(rect) {\n            return this.rect.overlaps(rect);\n        }\n        insert(shape, bounds) {\n            let inserted = false;\n            const children = this.children;\n            const length = children.length;\n            if (this.inBounds(bounds)) {\n                if (!length && this.shapes.length < 4) {\n                    this._add(shape, bounds);\n                }\n                else {\n                    if (!length) {\n                        this._initChildren();\n                    }\n                    for (let idx = 0; idx < children.length; idx++) {\n                        if (children[idx].insert(shape, bounds)) {\n                            inserted = true;\n                            break;\n                        }\n                    }\n                    if (!inserted) {\n                        this._add(shape, bounds);\n                    }\n                }\n                inserted = true;\n            }\n            return inserted;\n        }\n        _initChildren() {\n            const rect = this.rect, children = this.children, shapes = this.shapes, center = rect.center(), halfWidth = rect.width / 2, halfHeight = rect.height / 2;\n            let childIdx, shapeIdx;\n            children.push(new QuadNode(new Rect(rect.x, rect.y, halfWidth, halfHeight)), new QuadNode(new Rect(center.x, rect.y, halfWidth, halfHeight)), new QuadNode(new Rect(rect.x, center.y, halfWidth, halfHeight)), new QuadNode(new Rect(center.x, center.y, halfWidth, halfHeight)));\n            for (shapeIdx = shapes.length - 1; shapeIdx >= 0; shapeIdx--) {\n                for (childIdx = 0; childIdx < children.length; childIdx++) {\n                    if (children[childIdx].insert(shapes[shapeIdx].shape, shapes[shapeIdx].bounds)) {\n                        shapes.splice(shapeIdx, 1);\n                        break;\n                    }\n                }\n            }\n        }\n        hitTestRect(rect, exclude) {\n            let idx;\n            const children = this.children;\n            const length = children.length;\n            let hit = false;\n            if (this.overlapsBounds(rect)) {\n                if (super.hitTestRect(rect, exclude)) {\n                    hit = true;\n                }\n                else {\n                    for (idx = 0; idx < length; idx++) {\n                        if (children[idx].hitTestRect(rect, exclude)) {\n                            hit = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            return hit;\n        }\n    }\n\n    class ShapesQuadTree {\n        constructor(diagram) {\n            this.ROOT_SIZE = 1000;\n            const boundsChangeHandler = this._boundsChange.bind(this);\n            diagram.bind(ITEMBOUNDSCHANGE, boundsChangeHandler);\n            diagram.bind(ITEMROTATE, boundsChangeHandler);\n            this.initRoots();\n        }\n        initRoots() {\n            this.rootMap = {};\n            this.root = new QuadRoot();\n        }\n        clear() {\n            this.initRoots();\n        }\n        _boundsChange(e) {\n            if (e.item._quadNode) {\n                e.item._quadNode.remove(e.item);\n            }\n            this.insert(e.item);\n        }\n        insert(shape) {\n            const bounds = shape.bounds(ROTATED);\n            const rootSize = this.ROOT_SIZE;\n            const sectors = this.getSectors(bounds);\n            const x = sectors[0][0];\n            const y = sectors[1][0];\n            if (this.inRoot(sectors)) {\n                this.root.insert(shape, bounds);\n            }\n            else {\n                if (!this.rootMap[x]) {\n                    this.rootMap[x] = {};\n                }\n                if (!this.rootMap[x][y]) {\n                    this.rootMap[x][y] = new QuadNode(new Rect(x * rootSize, y * rootSize, rootSize, rootSize));\n                }\n                this.rootMap[x][y].insert(shape, bounds);\n            }\n        }\n        remove(shape) {\n            if (shape._quadNode) {\n                shape._quadNode.remove(shape);\n            }\n        }\n        inRoot(sectors) {\n            return sectors[0].length > 1 || sectors[1].length > 1;\n        }\n        getSectors(rect) {\n            const rootSize = this.ROOT_SIZE;\n            const bottomRight = rect.bottomRight();\n            const bottomX = Math.floor(bottomRight.x / rootSize);\n            const bottomY = Math.floor(bottomRight.y / rootSize);\n            const sectors = [[], []];\n            for (let x = Math.floor(rect.x / rootSize); x <= bottomX; x++) {\n                sectors[0].push(x);\n            }\n            for (let y = Math.floor(rect.y / rootSize); y <= bottomY; y++) {\n                sectors[1].push(y);\n            }\n            return sectors;\n        }\n        hitTestRect(rect, exclude) {\n            const sectors = this.getSectors(rect);\n            let xIdx, yIdx, x, y;\n            let root;\n            if (this.root.hitTestRect(rect, exclude)) {\n                return true;\n            }\n            for (xIdx = 0; xIdx < sectors[0].length; xIdx++) {\n                x = sectors[0][xIdx];\n                for (yIdx = 0; yIdx < sectors[1].length; yIdx++) {\n                    y = sectors[1][yIdx];\n                    root = (this.rootMap[x] || {})[y];\n                    if (root && root.hitTestRect(rect, exclude)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n    }\n\n    function copyDefaultOptions(mainOptions, elementOptions, fields) {\n        let field;\n        for (let idx = 0; idx < fields.length; idx++) {\n            field = fields[idx];\n            if (elementOptions && !defined(elementOptions[field])) {\n                elementOptions[field] = mainOptions[field];\n            }\n        }\n    }\n    const defaultOptions = {\n        name: 'Diagram',\n        theme: 'sass',\n        layout: '',\n        zoomRate: 0.1,\n        zoom: 1,\n        zoomMin: 0,\n        zoomMax: 2,\n        dataSource: {},\n        draggable: true,\n        template: '',\n        autoBind: true,\n        editable: {\n            rotate: {},\n            resize: {},\n            text: true,\n            tools: [],\n            drag: {\n                snap: {\n                    size: 10,\n                    angle: 10\n                }\n            },\n            remove: true\n        },\n        pannable: {},\n        selectable: {\n            key: 'none'\n        },\n        tooltip: { enabled: true, format: '{0}' },\n        copy: {\n            enabled: true,\n            offsetX: 20,\n            offsetY: 20\n        },\n        shapeDefaults: shapeDefaults({ undoable: true }),\n        connectionDefaults: {\n            editable: {\n                tools: []\n            },\n            type: CASCADING\n        },\n        shapes: [],\n        connections: []\n    };\n    const events = [\n        ZOOM_END,\n        ZOOM_START,\n        PAN, SELECT$1,\n        ITEMROTATE,\n        ITEMBOUNDSCHANGE,\n        CHANGE$1,\n        CLICK,\n        MOUSE_ENTER,\n        MOUSE_LEAVE,\n        'toolBarClick',\n        'save',\n        'cancel',\n        'edit',\n        'remove',\n        'add',\n        'dataBound',\n        DRAG_START,\n        DRAG,\n        DRAG_END\n    ];\n    function splitDiagramElements(elements) {\n        const connections = [];\n        const shapes = [];\n        let element, idx;\n        for (idx = 0; idx < elements.length; idx++) {\n            element = elements[idx];\n            if (element instanceof Shape) {\n                shapes.push(element);\n            }\n            else {\n                connections.push(element);\n            }\n        }\n        return {\n            shapes: shapes,\n            connections: connections\n        };\n    }\n    function preventDefault(e) {\n        e.preventDefault();\n    }\n    function elementOffset(element) {\n        const rect = element.getBoundingClientRect();\n        const doc = element.ownerDocument;\n        const scrollLeft = doc.defaultView.scrollX || doc.documentElement.scrollLeft || 0;\n        const scrollTop = doc.defaultView.scrollY || doc.documentElement.scrollTop || 0;\n        return {\n            top: rect.top + scrollTop,\n            left: rect.left + scrollLeft\n        };\n    }\n    function outerWidth(element, includeMargins = false) {\n        let widthValue = element.offsetWidth; // Width of the element with padding and border\n        if (includeMargins) {\n            const style = getComputedStyle(element);\n            const marginLeft = parseFloat(style.marginLeft);\n            const marginRight = parseFloat(style.marginRight);\n            widthValue += marginLeft + marginRight;\n        }\n        return widthValue;\n    }\n    function outerHeight(element, includeMargins = false) {\n        let heightValue = element.offsetHeight;\n        if (includeMargins) {\n            const style = getComputedStyle(element);\n            const marginTop = parseFloat(style.marginTop);\n            const marginBottom = parseFloat(style.marginBottom);\n            heightValue += marginTop + marginBottom;\n        }\n        return heightValue;\n    }\n    function elementWidth(element) {\n        const style = getComputedStyle(element);\n        const widthValue = element.clientWidth; // Includes content + padding\n        const paddingLeft = parseFloat(style.paddingLeft);\n        const paddingRight = parseFloat(style.paddingRight);\n        return widthValue - paddingLeft - paddingRight; // Only content\n    }\n    function elementHeight(element) {\n        const style = getComputedStyle(element);\n        const heightValue = element.clientHeight;\n        const paddingTop = parseFloat(style.paddingTop);\n        const paddingBottom = parseFloat(style.paddingBottom);\n        return heightValue - paddingTop - paddingBottom;\n    }\n\n    class Diagram extends Observable {\n        constructor(element, userOptions, themeOptions) {\n            super();\n            this._clipboard = [];\n            this._connectionsDataMap = {};\n            this._dataMap = {};\n            this._inactiveShapeItems = new InactiveItemsCollection();\n            this._selectedItems = [];\n            this.shapes = [];\n            this.connections = [];\n            this._deferredConnectionUpdates = [];\n            this.element = element;\n            this.options = deepExtend({ createToolBar: noop$1, destroyToolBar: noop$1 }, defaultOptions, userOptions);\n            this.events = events;\n            this._initTheme(themeOptions);\n            this._initElements();\n            this._extendLayoutOptions(this.options);\n            this._initDefaults(userOptions);\n            this._interactionDefaults();\n            this._initCanvas();\n            this.mainLayer = new Group({\n                id: 'main-layer'\n            });\n            this.canvas.append(this.mainLayer);\n            this._shapesQuadTree = new ShapesQuadTree(this);\n            this._pan = new Point();\n            this._adorners = [];\n            this.adornerLayer = new Group({\n                id: 'adorner-layer'\n            });\n            this.canvas.append(this.adornerLayer);\n            this._createHandlers();\n            this._initialize();\n            this._resizingAdorner = new ResizingAdorner(this, { editable: this.options.editable });\n            this._connectorsAdorner = new ConnectorsAdorner(this);\n            this._adorn(this._resizingAdorner, true);\n            this._adorn(this._connectorsAdorner, true);\n            this.selector = new Selector(this);\n            // TODO: We may consider using real Clipboard API once is supported by the standard.\n            this._clipboard.length = 0;\n            this.pauseMouseHandlers = false;\n        }\n        _createShape(dataItem, options) {\n            options = deepExtend({}, this.options.shapeDefaults, options);\n            options.dataItem = dataItem;\n            const shape = new Shape(options, this);\n            return shape;\n        }\n        _createConnection(dataItem, source, target) {\n            const options = deepExtend({}, this.options.connectionDefaults);\n            options.dataItem = dataItem;\n            const connection = new Connection(source || new Point(), target || new Point(), options);\n            return connection;\n        }\n        _initElements() {\n            this.element.innerHTML = '';\n            this.element.style.position = 'relative';\n            this.element.setAttribute('tabindex', '0');\n            this.element.classList.add('k-widget', 'k-diagram');\n            this.scrollable = document.createElement('div');\n            this.element.appendChild(this.scrollable);\n            this.wrapper = this.element;\n        }\n        _initDefaults(userOptions) {\n            const options = this.options;\n            const editable = options.editable;\n            const shapeDefaults = options.shapeDefaults;\n            const connectionDefaults = options.connectionDefaults;\n            const userShapeDefaults = (userOptions || {}).shapeDefaults;\n            if (editable === false) {\n                shapeDefaults.editable = false;\n                connectionDefaults.editable = false;\n            }\n            else {\n                copyDefaultOptions(editable, shapeDefaults.editable, ['drag', 'remove', 'connect']);\n                copyDefaultOptions(editable, connectionDefaults.editable, ['drag', 'remove']);\n            }\n            if (userShapeDefaults && userShapeDefaults.connectors) {\n                options.shapeDefaults.connectors = userShapeDefaults.connectors;\n            }\n        }\n        _interactionDefaults() {\n            const options = this.options;\n            const selectable = options.selectable;\n            const pannable = options.pannable;\n            const mobile = this._mobileOS();\n            if (selectable && !defined(selectable.multiple)) {\n                options.selectable = deepExtend({\n                    multiple: mobile ? false : true\n                }, options.selectable);\n            }\n            if (pannable && !defined(pannable.key)) {\n                options.pannable = deepExtend({\n                    key: mobile ? 'none' : 'ctrl'\n                }, options.pannable);\n            }\n        }\n        _initCanvas() {\n            const canvasContainer = document.createElement('div');\n            canvasContainer.classList.add('k-layer');\n            this.scrollable.appendChild(canvasContainer);\n            const viewPort = this.viewport();\n            this.canvas = new (this.options.Canvas || Canvas$1)(canvasContainer, {\n                width: viewPort.width || DEFAULT_CANVAS_WIDTH,\n                height: viewPort.height || DEFAULT_CANVAS_HEIGHT\n            });\n        }\n        _createHandlers() {\n            const element = this.element;\n            this._wheelHandler = this._wheelHandler || this._wheel.bind(this);\n            this._keydownHandler = this._keydownHandler || this._keydown.bind(this);\n            if (this._mobileOS() && this._mobileOS().browser.mobilesafari) {\n                element.addEventListener('mousewheel', this._wheelHandler);\n            }\n            else {\n                element.addEventListener('wheel', this._wheelHandler);\n            }\n            element.addEventListener('keydown', this._keydownHandler);\n            this._userEvents = new UserEvents(this.scrollable, {\n                multiTouch: true,\n                fastTap: true,\n                tap: this._tap.bind(this),\n                start: this._dragStart.bind(this),\n                move: this._drag.bind(this),\n                end: this._dragEnd.bind(this),\n                gesturestart: this._gestureStart.bind(this),\n                gesturechange: this._gestureChange.bind(this),\n                gestureend: this._gestureEnd.bind(this),\n                doubleTap: this._doubleTap.bind(this),\n                supportDoubleTap: true\n            });\n            this.toolService = new ToolService(this);\n            this._mouseoverHandler = this._mouseoverHandler || this._mouseover.bind(this);\n            this._mouseoutHandler = this._mouseoutHandler || this._mouseout.bind(this);\n            this._mouseMoveHandler = this._mouseMoveHandler || this._mouseMove.bind(this);\n            this._mouseDownHandler = this._mouseDownHandler || this._mouseDown.bind(this);\n            this._mouseUpHandler = this._mouseUpHandler || this._mouseUp.bind(this);\n            this.scrollable.addEventListener('mouseover', this._mouseoverHandler);\n            this.scrollable.addEventListener('mouseout', this._mouseoutHandler);\n            this.scrollable.addEventListener('mousemove', this._mouseMoveHandler);\n            this.scrollable.addEventListener('mousedown', this._mouseDownHandler);\n            this.scrollable.addEventListener('mouseup', this._mouseUpHandler);\n            this._initResizeObserver();\n            this.bind(ZOOM_START, this._destroyToolBar.bind(this));\n            this.bind(PAN, this._destroyToolBar.bind(this));\n        }\n        _initResizeObserver() {\n            const observer = new ResizeObserver((entries) => {\n                entries.forEach(entry => {\n                    const { width, height } = entry.contentRect;\n                    if (entry.target !== this.element ||\n                        (this.size && this.size.width === width && this.size.height === height)) {\n                        return;\n                    }\n                    this.size = { width, height };\n                    this._resize();\n                    this.trigger('resize', this.size);\n                });\n            });\n            this._resizeObserver = observer;\n            observer.observe(this.element);\n        }\n        _destroyResizeObserver() {\n            if (this._resizeObserver) {\n                this._resizeObserver.disconnect();\n                this._resizeObserver = null;\n            }\n        }\n        _dragStart(e) {\n            this._pauseMouseHandlers = true;\n            const point = this._eventPositions(e, true);\n            if (this.toolService.start(point, this._meta(e))) {\n                this._destroyToolBar();\n                e.preventDefault();\n            }\n        }\n        _drag(e) {\n            const p = this._eventPositions(e);\n            if (this.toolService.move(p, this._meta(e))) {\n                e.preventDefault();\n            }\n        }\n        _dragEnd(e) {\n            this._pauseMouseHandlers = false;\n            const p = this._eventPositions(e);\n            if (this.toolService.end(p, this._meta(e))) {\n                this.options.createToolBar();\n                e.preventDefault();\n            }\n        }\n        _mouseMove(e) {\n            if (!this._pauseMouseHandlers) {\n                const p = this._eventPositions(e);\n                this.toolService._updateHoveredItem(p);\n                this.toolService._updateCursor(p);\n            }\n        }\n        _mouseDown() {\n            this._pauseMouseHandlers = true;\n        }\n        _mouseUp() {\n            this._pauseMouseHandlers = false;\n        }\n        _tap(e) {\n            const toolService = this.toolService;\n            const selectable = this.options.selectable;\n            const point = this._eventPositions(e);\n            const focused = this.focus();\n            toolService._updateHoveredItem(point);\n            if (toolService.hoveredItem) {\n                const item = toolService.hoveredItem;\n                this.trigger('click', {\n                    item: item,\n                    point: point,\n                    meta: this._meta(e)\n                });\n                if (selectable && item.options.selectable !== false) {\n                    const multiple = selectable.multiple !== false;\n                    const ctrlPressed = kendo_common_cmn_chunk_js.m || this._meta(e).ctrlKey;\n                    if (item.isSelected) {\n                        if (ctrlPressed) {\n                            this._destroyToolBar();\n                            item.select(false);\n                        }\n                        else {\n                            this.options.createToolBar(focused);\n                        }\n                    }\n                    else {\n                        this._destroyToolBar();\n                        this.select(item, {\n                            addToSelection: multiple && ctrlPressed\n                        });\n                        this.options.createToolBar(focused);\n                    }\n                }\n            }\n            else if (selectable) {\n                this._destroyToolBar();\n                this.deselect();\n            }\n        }\n        _keydown(e) {\n            if (this.toolService.keyDown(e.keyCode, this._meta(e))) {\n                e.preventDefault();\n            }\n        }\n        _wheel(e) {\n            const delta = mwDelta(e), p = this._eventPositions(e), meta = deepExtend(this._meta(e), { delta: delta });\n            if (this.toolService.wheel(p, meta)) {\n                e.preventDefault();\n            }\n        }\n        _meta(e) {\n            e = e.event || e;\n            return { ctrlKey: e.ctrlKey, metaKey: e.metaKey, altKey: e.altKey, shiftKey: e.shiftKey, type: e.type };\n        }\n        _eventPositions(e, start) {\n            let point;\n            if (e.touch) {\n                const field = start ? 'startLocation' : 'location';\n                point = new Point(e.x[field], e.y[field]);\n            }\n            else {\n                point = new Point(e.pageX, e.pageY);\n            }\n            return this.documentToModel(point);\n        }\n        _gestureStart(e) {\n            this._destroyToolBar();\n            this.scroller.disable();\n            const initialCenter = this.documentToModel(new Point(e.center.x, e.center.y));\n            const eventArgs = {\n                point: initialCenter,\n                zoom: this.zoom()\n            };\n            if (this.trigger(ZOOM_START, eventArgs)) {\n                return;\n            }\n            this._gesture = e;\n            this._initialCenter = initialCenter;\n        }\n        _gestureChange(e) {\n            const previousGesture = this._gesture;\n            const initialCenter = this._initialCenter;\n            const center = this.documentToView(new Point(e.center.x, e.center.y));\n            const scaleDelta = e.distance / previousGesture.distance;\n            let zoom = this._zoom;\n            let updateZoom = false;\n            if (Math.abs(scaleDelta - 1) >= MOBILE_ZOOM_RATE) {\n                this._zoom = zoom = this._getValidZoom(zoom * scaleDelta);\n                this.options.zoom = zoom;\n                this._gesture = e;\n                updateZoom = true;\n            }\n            const zoomedPoint = initialCenter.times(zoom);\n            const pan = center.minus(zoomedPoint);\n            if (updateZoom || this._pan.distanceTo(pan) >= MOBILE_PAN_DISTANCE) {\n                this._panTransform(pan);\n                this._updateAdorners();\n            }\n            e.preventDefault();\n        }\n        _doubleTap(e) {\n            const pointPosition = this._eventPositions(e);\n            const options = this.options;\n            const zoomRate = options.zoomRate;\n            let zoom = this.zoom() + zoomRate;\n            const meta = this._meta(e);\n            const zoomOptions = { point: pointPosition, meta: meta, zoom: zoom };\n            if (this.trigger(ZOOM_START, zoomOptions)) {\n                return;\n            }\n            zoom = kendo_drawing_cmn_chunk_js.r(Math.max(options.zoomMin, Math.min(options.zoomMax, zoom)), 2);\n            zoomOptions.zoom = zoom;\n            this.zoom(zoom, zoomOptions);\n            this.trigger(ZOOM_END, zoomOptions);\n        }\n        _gestureEnd() {\n            if (this.options.pannable !== false) {\n                this.scroller.enable();\n            }\n            this.trigger(ZOOM_END, {\n                point: this._initialCenter,\n                zoom: this.zoom()\n            });\n        }\n        _resize() {\n            const viewport = this.viewport();\n            if (this.canvas) {\n                this.canvas.size(viewport);\n            }\n            if (this.scrollable && this.toolBar) {\n                this.scrollable.style.height = viewport.height + 'px';\n            }\n        }\n        _mouseover(e) {\n            const node = e.target._kendoNode;\n            if (node && node.srcElement._hover) {\n                node.srcElement._hover(true, node.srcElement);\n            }\n        }\n        _mouseout(e) {\n            const node = e.target._kendoNode;\n            if (node && node.srcElement._hover) {\n                node.srcElement._hover(false, node.srcElement);\n            }\n        }\n        _initTheme(themeOptions) {\n            this.options = deepExtend({}, themeOptions, this.options);\n            if (this.options.editable === true) {\n                this.options.editable = (themeOptions || {}).editable;\n            }\n        }\n        _createOptionElements() {\n            const options = this.options;\n            const shapesLength = options.shapes.length;\n            if (shapesLength) {\n                this._createShapes();\n            }\n            if (options.connections.length) {\n                this._createConnections();\n            }\n            if (shapesLength && options.layout) {\n                this.layout(options.layout);\n            }\n        }\n        _createShapes() {\n            const options = this.options, shapes = options.shapes;\n            let shape, i;\n            for (i = 0; i < shapes.length; i++) {\n                shape = shapes[i];\n                this.addShape(shape);\n            }\n        }\n        _createConnections() {\n            const options = this.options, defaults = options.connectionDefaults, connections = options.connections;\n            let conn, source, target, i;\n            for (i = 0; i < connections.length; i++) {\n                conn = connections[i];\n                source = this._findConnectionTarget(conn.from);\n                target = this._findConnectionTarget(conn.to);\n                if (this.options.connect) {\n                    this.options.connect(source, target, deepExtend({}, defaults, conn));\n                }\n                else {\n                    this.connect(source, target, deepExtend({}, defaults, conn));\n                }\n            }\n        }\n        _findConnectionTarget(options) {\n            options = options || {};\n            const shapeId = isString$1(options) ? options : options.shapeId || options.id;\n            let target;\n            if (shapeId) {\n                target = this.getShapeById(shapeId);\n                if (options.connector) {\n                    target = target.getConnector(options.connector);\n                }\n            }\n            else {\n                target = new Point(options.x || 0, options.y || 0);\n            }\n            return target;\n        }\n        destroy() {\n            super.destroy();\n            this._destroyResizeObserver();\n            if (this._userEvents) {\n                this._userEvents.destroy();\n            }\n            this.clear();\n            this.element.removeEventListener('mousewheel', this._wheelHandler);\n            this.element.removeEventListener('wheel', this._wheelHandler);\n            this.element.removeEventListener('keydown', this._keydownHandler);\n            this.scrollable.removeEventListener('mouseover', this._mouseoverHandler);\n            this.scrollable.removeEventListener('mouseout', this._mouseoutHandler);\n            this.scrollable.removeEventListener('mousemove', this._mouseMoveHandler);\n            this.scrollable.removeEventListener('mousedown', this._mouseDownHandler);\n            this.scrollable.removeEventListener('mouseup', this._mouseUpHandler);\n            this.canvas.destroy(true);\n            this.canvas = undefined;\n            this.destroyScroller();\n            this._destroyGlobalToolBar();\n            this._destroyToolBar();\n            this._inactiveShapeItems.destroy();\n        }\n        destroyScroller() {\n            const scroller = this.scroller;\n            if (!scroller) {\n                return;\n            }\n            scroller.destroy();\n            scroller.element.remove();\n            this.scroller = null;\n        }\n        save() {\n            const json = {\n                shapes: [],\n                connections: []\n            };\n            let i, connection, shape;\n            for (i = 0; i < this.shapes.length; i++) {\n                shape = this.shapes[i];\n                if (shape.options.serializable) {\n                    json.shapes.push(shape.options);\n                }\n            }\n            for (i = 0; i < this.connections.length; i++) {\n                connection = this.connections[i];\n                json.connections.push(deepExtend({}, connection.options, connection.toJSON()));\n            }\n            return json;\n        }\n        focus() {\n            if (this.element !== this.element.ownerDocument.activeElement) {\n                const element = this.element, containers = [], offsets = [], documentElement = element.ownerDocument.documentElement;\n                let scrollContainer = element, i;\n                do {\n                    scrollContainer = scrollContainer.parentNode;\n                    if (scrollContainer.scrollHeight > scrollContainer.clientHeight) {\n                        containers.push(scrollContainer);\n                        offsets.push(scrollContainer.scrollTop);\n                    }\n                } while (scrollContainer !== documentElement);\n                element.focus({ preventScroll: true });\n                for (i = 0; i < containers.length; i++) {\n                    containers[i].scrollTop = offsets[i];\n                }\n                return true;\n            }\n        }\n        load(options) {\n            this.clear();\n            this.setOptions(options);\n            this._createShapes();\n            this._createConnections();\n        }\n        setOptions(options) {\n            deepExtend(this.options, options);\n        }\n        clear() {\n            this.select(false);\n            this.mainLayer.clear();\n            this._shapesQuadTree.clear();\n            this._initialize();\n        }\n        /**\n         * Determines whether the the two items are connected.\n         *\n         * @param source Shape, Connector, Point.\n         * @param target Shape, Connector, Point.\n         * @returns true if the two items are connected.\n         */\n        connected(source, target) {\n            for (let i = 0; i < this.connections.length; i++) {\n                const c = this.connections[i];\n                if (c.from === source && c.to === target) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        /**\n         * Adds connection to the diagram.\n         *\n         * @param connection Connection.\n         * @param undoable Boolean.\n         * @returns The newly created connection.\n         */\n        addConnection(connection, undoable) {\n            if (undoable !== false) {\n                this.undoRedoService.add(new AddConnectionUnit(connection, this), false);\n            }\n            connection.diagram = this;\n            connection._setOptionsFromModel();\n            connection.refresh();\n            this.mainLayer.append(connection.visual);\n            this.connections.push(connection);\n            this.trigger(CHANGE$1, {\n                added: [connection],\n                removed: []\n            });\n            return connection;\n        }\n        /**\n         * Adds shape to the diagram.\n         *\n         * @param item Shape, Point. If point is passed it will be created new Shape and positioned at that point.\n         * @param options. The options to be passed to the newly created Shape.\n         * @returns The newly created shape.\n         */\n        addShape(item, undoable) {\n            let shape, shapeDefaults = this.options.shapeDefaults;\n            if (item instanceof Shape) {\n                shape = item;\n                this._parseBounds(shape.bounds());\n            }\n            else if (!(item.prototype)) {\n                shapeDefaults = deepExtend({}, shapeDefaults, item || {});\n                shape = new Shape(shapeDefaults, this);\n                this._parseBounds(shape.bounds());\n            }\n            else {\n                return;\n            }\n            if (undoable !== false) {\n                this.undoRedoService.add(new AddShapeUnit(shape, this), false);\n            }\n            this.shapes.push(shape);\n            if (shape.diagram !== this) {\n                this._shapesQuadTree.insert(shape);\n                shape.diagram = this;\n            }\n            this.mainLayer.append(shape.visual);\n            this.trigger(CHANGE$1, {\n                added: [shape],\n                removed: []\n            });\n            return shape;\n        }\n        /**\n         * Removes items (or single item) from the diagram.\n         *\n         * @param items DiagramElement, Array of Items.\n         * @param undoable.\n         */\n        remove(items, undoable) {\n            items = Array.isArray(items) ? items.slice(0) : [items];\n            const elements = splitDiagramElements(items);\n            const shapes = elements.shapes;\n            const connections = elements.connections;\n            let i;\n            if (!defined(undoable)) {\n                undoable = true;\n            }\n            if (undoable) {\n                this.undoRedoService.begin();\n            }\n            this._suspendModelRefresh();\n            for (i = shapes.length - 1; i >= 0; i--) {\n                this._removeItem(shapes[i], undoable, connections);\n            }\n            for (i = connections.length - 1; i >= 0; i--) {\n                this._removeItem(connections[i], undoable);\n            }\n            this._resumeModelRefresh();\n            if (undoable) {\n                this.undoRedoService.commit(false);\n            }\n            this.trigger(CHANGE$1, {\n                added: [],\n                removed: items\n            });\n        }\n        _addConnection(connection, undoable) {\n            if (this.options._addConnection) {\n                return this.options._addConnection(connection, undoable);\n            }\n            else if (!this.trigger('add', { connection: connection })) {\n                this.addConnection(connection, undoable);\n                connection._updateConnectors();\n                return connection;\n            }\n        }\n        _addShape(shape, undoable) {\n            if (this.options._addShape) {\n                return this.options._addShape(shape, undoable);\n            }\n            else if (!this.trigger('add', { shape: shape })) {\n                return this.addShape(shape, undoable);\n            }\n        }\n        _parseBounds(bounds) {\n            bounds.x = typeof (bounds.x) == 'string' ? parseFloat(bounds.x) : bounds.x;\n            bounds.y = typeof (bounds.y) == 'string' ? parseFloat(bounds.y) : bounds.y;\n        }\n        _shouldRefresh() {\n            return !this._suspended;\n        }\n        _suspendModelRefresh() {\n            this._suspended = (this._suspended || 0) + 1;\n        }\n        _resumeModelRefresh() {\n            this._suspended = Math.max((this._suspended || 0) - 1, 0);\n        }\n        _triggerRemove(items) {\n            const toRemove = [];\n            let item, args, editable;\n            for (let idx = 0; idx < items.length; idx++) {\n                item = items[idx];\n                editable = item.options.editable;\n                if (item instanceof Shape) {\n                    args = { shape: item };\n                }\n                else {\n                    args = { connection: item };\n                }\n                if (editable && editable.remove !== false && !this.trigger('remove', args)) {\n                    toRemove.push(item);\n                }\n            }\n            return toRemove;\n        }\n        _addConnections(connections, undoable) {\n            const length = connections.length;\n            for (let i = 0; i < length; i++) {\n                const dataItem = connections[i];\n                this._addConnectionDataItem(dataItem, undoable);\n            }\n        }\n        _addConnectionDataItem(dataItem, undoable) {\n            if (!this._connectionsDataMap[dataItem.uid]) {\n                let from = this._validateConnector(dataItem.from);\n                if (!defined(from) || from === null) {\n                    from = new Point(dataItem.fromX, dataItem.fromY);\n                }\n                let to = this._validateConnector(dataItem.to);\n                if (!defined(to) || to === null) {\n                    to = new Point(dataItem.toX, dataItem.toY);\n                }\n                if (defined(from) && defined(to)) {\n                    const options = deepExtend({}, this.options.connectionDefaults);\n                    options.dataItem = dataItem;\n                    const connection = new Connection(from, to, options);\n                    this._connectionsDataMap[dataItem.uid] = connection;\n                    this.addConnection(connection, undoable);\n                }\n            }\n        }\n        _validateConnector(value) {\n            let connector;\n            if (defined(value) && value !== null) {\n                connector = this._dataMap[value];\n            }\n            return connector;\n        }\n        _addDataItems(items, parent) {\n            let item, idx, shape, parentShape;\n            for (idx = 0; idx < items.length; idx++) {\n                item = items[idx];\n                shape = this._addDataItemByUid(item);\n                parentShape = this._addDataItemByUid(parent);\n                if (parentShape && !this.connected(parentShape, shape)) { // check if connected to not duplicate connections.\n                    this.connect(parentShape, shape);\n                }\n            }\n        }\n        connect(source, target, options) {\n            const resolvedOptions = deepExtend({}, this.options.connectionDefaults, options);\n            const connection = new Connection(source, target, resolvedOptions);\n            return this.addConnection(connection);\n        }\n        /**\n         * Executes the next undoable action on top of the undo stack if any.\n         */\n        undo() {\n            this.undoRedoService.undo();\n        }\n        /**\n         * Executes the previous undoable action on top of the redo stack if any.\n         */\n        redo() {\n            this.undoRedoService.redo();\n        }\n        /**\n         * Selects items on the basis of the given input or returns the current selection if none.\n         *\n         * @param itemsOrRect DiagramElement, Array of elements, \"All\", false or Rect. A value 'false' will deselect everything.\n         * @param options\n         * @returns {Array}\n         */\n        select(item, options) {\n            if (isDefined(item)) {\n                options = deepExtend({ addToSelection: false }, options);\n                const addToSelection = options.addToSelection, selected = [];\n                let items = [], i, element;\n                if (!addToSelection) {\n                    this.deselect();\n                }\n                this._internalSelection = true;\n                if (item instanceof Array) {\n                    items = item;\n                }\n                else if (item instanceof DiagramElement) {\n                    items = [item];\n                }\n                for (i = 0; i < items.length; i++) {\n                    element = items[i];\n                    if (element.select(true)) {\n                        selected.push(element);\n                    }\n                }\n                this._selectionChanged(selected, []);\n                this._internalSelection = false;\n            }\n            else {\n                return this._selectedItems;\n            }\n        }\n        selectAll() {\n            this.select(this.shapes.concat(this.connections));\n        }\n        selectArea(rect) {\n            let i, items, item;\n            this._internalSelection = true;\n            const selected = [];\n            if (rect instanceof Rect) {\n                items = this.shapes.concat(this.connections);\n                for (i = 0; i < items.length; i++) {\n                    item = items[i];\n                    if ((!rect || item._hitTest(rect)) && item.options.enable) {\n                        if (item.select(true)) {\n                            selected.push(item);\n                        }\n                    }\n                }\n            }\n            this._selectionChanged(selected, []);\n            this._internalSelection = false;\n        }\n        deselect(item) {\n            this._internalSelection = true;\n            const deselected = [];\n            let items = [], element, i;\n            if (item instanceof Array) {\n                items = item;\n            }\n            else if (item instanceof DiagramElement) {\n                items.push(item);\n            }\n            else if (!isDefined(item)) {\n                items = this._selectedItems.slice(0);\n            }\n            for (i = 0; i < items.length; i++) {\n                element = items[i];\n                if (element.select(false)) {\n                    deselected.push(element);\n                }\n            }\n            this._selectionChanged([], deselected);\n            this._internalSelection = false;\n        }\n        /**\n         * Brings to front the passed items.\n         *\n         * @param items DiagramElement, Array of Items.\n         * @param undoable. By default the action is undoable.\n         */\n        toFront(items, undoable) {\n            if (!items) {\n                items = this._selectedItems.slice();\n            }\n            const result = this._getDiagramItems(items);\n            let indices;\n            if (!defined(undoable) || undoable) {\n                indices = indicesOfItems(this.mainLayer, result.visuals);\n                const unit = new ToFrontUnit(this, items, indices);\n                this.undoRedoService.add(unit);\n            }\n            else {\n                this.mainLayer.toFront(result.visuals);\n                this._fixOrdering(result, true);\n            }\n        }\n        /**\n         * Sends to back the passed items.\n         *\n         * @param items DiagramElement, Array of Items.\n         * @param undoable. By default the action is undoable.\n         */\n        toBack(items, undoable) {\n            if (!items) {\n                items = this._selectedItems.slice();\n            }\n            const result = this._getDiagramItems(items);\n            let indices;\n            if (!defined(undoable) || undoable) {\n                indices = indicesOfItems(this.mainLayer, result.visuals);\n                const unit = new ToBackUnit(this, items, indices);\n                this.undoRedoService.add(unit);\n            }\n            else {\n                this.mainLayer.toBack(result.visuals);\n                this._fixOrdering(result, false);\n            }\n        }\n        /**\n         * Bring into view the passed item(s) or rectangle.\n         *\n         * @param items DiagramElement, Array of Items, Rect.\n         * @param options. align - controls the position of the calculated rectangle relative to the viewport.\n         * \"Center middle\" will position the items in the center. animate - controls if the pan should be animated.\n         */\n        bringIntoView(item, options) {\n            const viewport = this.viewport();\n            const aligner = new RectAlign(viewport);\n            let rect;\n            if (viewport.width === 0 || viewport.height === 0) {\n                return;\n            }\n            options = deepExtend({ animate: false, align: 'center middle' }, options);\n            if (options.align === 'none') {\n                options.align = 'center middle';\n            }\n            if (item instanceof DiagramElement) {\n                rect = item.bounds(TRANSFORMED);\n            }\n            else if (Array.isArray(item)) {\n                rect = this.boundingBox(item);\n            }\n            else if (item instanceof Rect) {\n                rect = item.clone();\n            }\n            const original = rect.clone();\n            rect.zoom(this._zoom);\n            if (rect.width > viewport.width || rect.height > viewport.height) {\n                this._zoom = this._getValidZoom(Math.min(viewport.width / original.width, viewport.height / original.height));\n                rect = original.clone().zoom(this._zoom);\n            }\n            this._zoomMainLayer();\n            const current = rect.clone();\n            aligner.align(rect, options.align);\n            const newPan = rect.topLeft().minus(current.topLeft());\n            this.pan(newPan.times(-1), options.animate);\n        }\n        alignShapes(direction) {\n            if (isUndefined(direction)) {\n                direction = 'Left';\n            }\n            let val, item, i;\n            const items = this.select();\n            if (items.length === 0) {\n                return;\n            }\n            switch (direction.toLowerCase()) {\n                case 'left':\n                case 'top':\n                    val = MAX_VALUE;\n                    break;\n                case 'right':\n                case 'bottom':\n                    val = MIN_VALUE;\n                    break;\n                default:\n                    break;\n            }\n            for (i = 0; i < items.length; i++) {\n                item = items[i];\n                if (item instanceof Shape) {\n                    switch (direction.toLowerCase()) {\n                        case 'left':\n                            val = Math.min(val, item.options.x);\n                            break;\n                        case 'top':\n                            val = Math.min(val, item.options.y);\n                            break;\n                        case 'right':\n                            val = Math.max(val, item.options.x);\n                            break;\n                        case 'bottom':\n                            val = Math.max(val, item.options.y);\n                            break;\n                        default:\n                            break;\n                    }\n                }\n            }\n            const undoStates = [];\n            const shapes = [];\n            for (i = 0; i < items.length; i++) {\n                item = items[i];\n                if (item instanceof Shape) {\n                    shapes.push(item);\n                    undoStates.push(item.bounds());\n                    switch (direction.toLowerCase()) {\n                        case 'left':\n                        case 'right':\n                            item.position(new Point(val, item.options.y));\n                            break;\n                        case 'top':\n                        case 'bottom':\n                            item.position(new Point(item.options.x, val));\n                            break;\n                        default:\n                            break;\n                    }\n                }\n            }\n            const unit = new TransformUnit(shapes, undoStates);\n            this.undoRedoService.add(unit, false);\n        }\n        zoom(zoom, options) {\n            if (zoom) {\n                let staticPoint = options ? options.point : new Point(0, 0);\n                // var meta = options ? options.meta : 0;\n                zoom = this._zoom = this._getValidZoom(zoom);\n                if (!isUndefined(staticPoint)) { // Viewpoint vector is constant\n                    staticPoint = new Point(Math.round(staticPoint.x), Math.round(staticPoint.y));\n                    const zoomedPoint = staticPoint.times(zoom);\n                    const viewportVector = this.modelToView(staticPoint);\n                    const raw = viewportVector.minus(zoomedPoint); // pan + zoomed point = viewpoint vector\n                    this._storePan(new Point(Math.round(raw.x), Math.round(raw.y)));\n                }\n                if (options) {\n                    options.zoom = zoom;\n                }\n                this._panTransform();\n                if (this.canvas.surface.hideTooltip) {\n                    this.canvas.surface.hideTooltip();\n                }\n                this._updateAdorners();\n            }\n            return this._zoom;\n        }\n        _getPan(pan) {\n            const canvas = this.canvas;\n            if (!canvas.translate) {\n                pan = pan.plus(this._pan);\n            }\n            return pan;\n        }\n        pan(pan, animate) {\n            if (pan instanceof Point) {\n                const scroller = this.scroller;\n                pan = this._getPan(pan);\n                pan = pan.times(-1);\n                if (animate) {\n                    scroller.animatedScrollTo(pan.x, pan.y, () => {\n                        this._updateAdorners();\n                    });\n                }\n                else {\n                    scroller.scrollTo(pan.x, pan.y);\n                    this._updateAdorners();\n                }\n            }\n            else {\n                return this._pan.times(-1);\n            }\n        }\n        viewport() {\n            const element = this.element;\n            const width = elementWidth(element);\n            let height = elementHeight(element);\n            if (this.toolBar) {\n                height -= outerHeight(this.toolBar.element);\n            }\n            return new Rect(0, 0, width, height);\n        }\n        copy() {\n            if (this.options.copy.enabled) {\n                this._clipboard.length = 0;\n                this._copyOffset = 1;\n                for (let i = 0; i < this._selectedItems.length; i++) {\n                    const item = this._selectedItems[i];\n                    this._clipboard.push(item);\n                }\n            }\n        }\n        cut() {\n            if (this.options.copy.enabled) {\n                this._clipboard.length = 0;\n                this._copyOffset = 0;\n                for (let i = 0; i < this._selectedItems.length; i++) {\n                    const item = this._selectedItems[i];\n                    this._clipboard.push(item);\n                }\n                this.remove(this._clipboard, true);\n            }\n        }\n        paste() {\n            if (this._clipboard.length > 0) {\n                let item, copied, i;\n                const mapping = {};\n                const elements = splitDiagramElements(this._clipboard);\n                const connections = elements.connections;\n                const shapes = elements.shapes;\n                const offset = {\n                    x: this._copyOffset * this.options.copy.offsetX,\n                    y: this._copyOffset * this.options.copy.offsetY\n                };\n                this.deselect();\n                // first the shapes\n                for (i = 0; i < shapes.length; i++) {\n                    item = shapes[i];\n                    copied = item.clone();\n                    mapping[item.id] = copied;\n                    copied.position(new Point(item.options.x + offset.x, item.options.y + offset.y));\n                    copied.diagram = this;\n                    copied = this._addShape(copied);\n                    if (copied) {\n                        copied.select();\n                    }\n                }\n                // then the connections\n                for (i = 0; i < connections.length; i++) {\n                    item = connections[i];\n                    copied = this._addConnection(item.clone());\n                    if (copied) {\n                        this._updateCopiedConnection(copied, item, 'source', mapping, offset);\n                        this._updateCopiedConnection(copied, item, 'target', mapping, offset);\n                        copied.select(true);\n                        copied.updateModel();\n                    }\n                }\n                this._syncChanges();\n                this._copyOffset += 1;\n            }\n        }\n        _syncChanges() {\n            if (this.options._syncChanges) {\n                this.options._syncChanges();\n            }\n        }\n        _syncConnectionChanges() {\n            if (this.options._syncConnectionChanges) {\n                this.options._syncConnectionChanges();\n            }\n        }\n        _syncShapeChanges() {\n            if (this.options._syncShapeChanges) {\n                this.options._syncShapeChanges();\n            }\n        }\n        _updateCopiedConnection(connection, sourceConnection, connectorName, mapping, offset) {\n            let onActivate, inactiveItem, targetShape;\n            const target = sourceConnection[connectorName]();\n            if (target instanceof Connector && mapping[target.shape.id]) {\n                targetShape = mapping[target.shape.id];\n                if (this.getShapeById(targetShape.id)) {\n                    connection[connectorName](targetShape.getConnector(target.options.name));\n                }\n                else {\n                    inactiveItem = this._inactiveShapeItems.getByUid(targetShape.dataItem.uid);\n                    if (inactiveItem) {\n                        onActivate = (item) => {\n                            targetShape = this._dataMap[item.id];\n                            connection[connectorName](targetShape.getConnector(target.options.name));\n                            connection.updateModel();\n                        };\n                        this._deferredConnectionUpdates.push(inactiveItem.onActivate(onActivate));\n                    }\n                }\n            }\n            else {\n                connection[connectorName](new Point(sourceConnection[connectorName + 'Point']().x + offset.x, sourceConnection[connectorName + 'Point']().y + offset.y));\n            }\n        }\n        /**\n         * Gets the bounding rectangle of the given items.\n         *\n         * @param items DiagramElement, Array of elements.\n         * @param origin Boolean. Pass 'true' if you need to get the bounding box of the shapes without their rotation offset.\n         * @returns {Rect}\n         */\n        boundingBox(items, origin) {\n            let rect = Rect.empty(), temp;\n            const di = isDefined(items) ? this._getDiagramItems(items) : { shapes: this.shapes };\n            if (di.shapes.length > 0) {\n                let item = di.shapes[0];\n                rect = item.bounds(ROTATED);\n                for (let i = 1; i < di.shapes.length; i++) {\n                    item = di.shapes[i];\n                    temp = item.bounds(ROTATED);\n                    if (origin === true) {\n                        temp.x -= item._rotationOffset.x;\n                        temp.y -= item._rotationOffset.y;\n                    }\n                    rect = rect.union(temp);\n                }\n            }\n            return rect;\n        }\n        _containerOffset() {\n            const containerOffset = elementOffset(this.element);\n            if (this.toolBar) {\n                containerOffset.top += outerHeight(this.toolBar.element);\n            }\n            return containerOffset;\n        }\n        documentToView(point) {\n            const containerOffset = this._containerOffset();\n            return new Point(point.x - containerOffset.left, point.y - containerOffset.top);\n        }\n        viewToDocument(point) {\n            const containerOffset = this._containerOffset();\n            return new Point(point.x + containerOffset.left, point.y + containerOffset.top);\n        }\n        viewToModel(point) {\n            return this._transformWithMatrix(point, this._matrixInvert);\n        }\n        modelToView(point) {\n            return this._transformWithMatrix(point, this._matrix);\n        }\n        modelToLayer(point) {\n            return this._transformWithMatrix(point, this._layerMatrix);\n        }\n        layerToModel(point) {\n            return this._transformWithMatrix(point, this._layerMatrixInvert);\n        }\n        documentToModel(point) {\n            const viewPoint = this.documentToView(point);\n            if (!this.canvas.translate) {\n                viewPoint.x = viewPoint.x + this.scroller.scrollLeft;\n                viewPoint.y = viewPoint.y + this.scroller.scrollTop;\n            }\n            return this.viewToModel(viewPoint);\n        }\n        modelToDocument(point) {\n            return this.viewToDocument(this.modelToView(point));\n        }\n        _transformWithMatrix(point, matrix) {\n            let result = point;\n            if (point instanceof Point) {\n                if (matrix) {\n                    result = matrix.apply(point);\n                }\n            }\n            else {\n                const tl = this._transformWithMatrix(point.topLeft(), matrix), br = this._transformWithMatrix(point.bottomRight(), matrix);\n                result = Rect.fromPoints(tl, br);\n            }\n            return result;\n        }\n        /**\n         * Performs a diagram layout of the given type.\n         *\n         * @param layoutType The layout algorithm to be applied (TreeLayout, LayeredLayout, SpringLayout).\n         * @param options Layout-specific options.\n         */\n        layout(options) {\n            this._layouting = true;\n            // TODO: raise layout event?\n            let type;\n            if (isUndefined(options)) {\n                options = this.options.layout;\n            }\n            if (isUndefined(options) || isUndefined(options.type)) {\n                type = 'Tree';\n            }\n            else {\n                type = options.type;\n            }\n            let l;\n            switch (type.toLowerCase()) {\n                case 'tree':\n                    l = new TreeLayout(this);\n                    break;\n                case 'layered':\n                    l = new LayeredLayout(this);\n                    break;\n                case 'forcedirected':\n                case 'force':\n                case 'spring':\n                case 'springembedder':\n                    l = new SpringLayout(this);\n                    break;\n                default:\n                    throw new Error('Layout algorithm \\'' + type + '\\' is not supported.');\n            }\n            const initialState = new LayoutState(this);\n            const finalState = l.layout(options);\n            if (finalState) {\n                const unit = new LayoutUndoUnit(initialState, finalState, options ? options.animate : null);\n                this.undoRedoService.add(unit);\n            }\n            this._layouting = false;\n            this._redrawConnections();\n        }\n        /**\n         * Gets a shape on the basis of its identifier.\n         *\n         * @param id (string) the identifier of a shape.\n         * @returns {Shape}\n         */\n        getShapeById(id) {\n            let found;\n            found = first(this.shapes, function (s) {\n                return s.visual.id === id;\n            });\n            if (found) {\n                return found;\n            }\n            found = first(this.connections, function (c) {\n                return c.visual.id === id;\n            });\n            return found;\n        }\n        getShapeByModelId(id) {\n            let shapeResult;\n            if (this._isEditable) {\n                shapeResult = this._dataMap[id];\n            }\n            else {\n                shapeResult = first(this.shapes, function (shape) {\n                    return (shape.dataItem || {}).id === id;\n                });\n            }\n            return shapeResult;\n        }\n        getShapeByModelUid(uid) {\n            let shapeResult;\n            if (this._isEditable) {\n                shapeResult = first(this.shapes, function (shape) {\n                    return (shape.dataItem || {}).uid === uid;\n                });\n            }\n            else {\n                shapeResult = this._dataMap[uid];\n            }\n            return shapeResult;\n        }\n        _extendLayoutOptions(options) {\n            if (options.layout) {\n                options.layout = deepExtend({}, LayoutDefaultOptions, options.layout);\n            }\n        }\n        _selectionChanged(selected, deselected) {\n            if (selected.length || deselected.length) {\n                this.trigger(SELECT$1, { selected: selected, deselected: deselected });\n            }\n        }\n        _getValidZoom(zoom) {\n            return Math.min(Math.max(zoom, this.options.zoomMin), this.options.zoomMax);\n        }\n        _panTransform(pos) {\n            const pan = pos || this._pan;\n            if (this.canvas.translate) {\n                this.scroller.scrollTo(pan.x, pan.y);\n                this._zoomMainLayer();\n            }\n            else {\n                this._storePan(pan);\n                this._transformMainLayer();\n            }\n        }\n        _finishPan() {\n            this.trigger(PAN, { total: this._pan, delta: Number.NaN });\n        }\n        _storePan(pan) {\n            this._pan = pan;\n            this._storeViewMatrix();\n        }\n        _zoomMainLayer() {\n            const zoom = this._zoom;\n            const transform = new CompositeTransform(0, 0, zoom, zoom);\n            transform.render(this.mainLayer);\n            this._storeLayerMatrix(transform);\n            this._storeViewMatrix();\n        }\n        _transformMainLayer() {\n            const pan = this._pan, zoom = this._zoom;\n            const transform = new CompositeTransform(pan.x, pan.y, zoom, zoom);\n            transform.render(this.mainLayer);\n            this._storeLayerMatrix(transform);\n            this._storeViewMatrix();\n        }\n        _storeLayerMatrix(canvasTransform) {\n            this._layerMatrix = canvasTransform.toMatrix();\n            this._layerMatrixInvert = canvasTransform.invert().toMatrix();\n        }\n        _storeViewMatrix() {\n            const pan = this._pan, zoom = this._zoom;\n            const transform = new CompositeTransform(pan.x, pan.y, zoom, zoom);\n            this._matrix = transform.toMatrix();\n            this._matrixInvert = transform.invert().toMatrix();\n        }\n        _toIndex(items, indices) {\n            const result = this._getDiagramItems(items);\n            this.mainLayer.toIndex(result.visuals, indices);\n            this._fixOrdering(result, false);\n        }\n        _fixOrdering(result, toFront) {\n            const shapePos = toFront ? this.shapes.length - 1 : 0, conPos = toFront ? this.connections.length - 1 : 0;\n            let i, item;\n            for (i = 0; i < result.shapes.length; i++) {\n                item = result.shapes[i];\n                remove(this.shapes, item);\n                insert(this.shapes, item, shapePos);\n            }\n            for (i = 0; i < result.cons.length; i++) {\n                item = result.cons[i];\n                remove(this.connections, item);\n                insert(this.connections, item, conPos);\n            }\n        }\n        _getDiagramItems(items) {\n            let i, args = items;\n            const result = {};\n            result.visuals = [];\n            result.shapes = [];\n            result.cons = [];\n            if (!items) {\n                args = this._selectedItems.slice();\n            }\n            else if (!Array.isArray(items)) {\n                args = [items];\n            }\n            for (i = 0; i < args.length; i++) {\n                const item = args[i];\n                if (item instanceof Shape) {\n                    result.shapes.push(item);\n                    result.visuals.push(item.visual);\n                }\n                else if (item instanceof Connection) {\n                    result.cons.push(item);\n                    result.visuals.push(item.visual);\n                }\n            }\n            return result;\n        }\n        _addDataItemByUid(dataItem) {\n            if (!defined(dataItem)) {\n                return;\n            }\n            let shape = this._dataMap[dataItem.uid];\n            if (shape) {\n                return shape;\n            }\n            const options = deepExtend({}, this.options.shapeDefaults);\n            options.dataItem = dataItem;\n            shape = new Shape(options, this);\n            this.addShape(shape);\n            this._dataMap[dataItem.uid] = shape;\n            return shape;\n        }\n        _addItem(item) {\n            if (item instanceof Shape) {\n                this.addShape(item);\n            }\n            else if (item instanceof Connection) {\n                this.addConnection(item);\n            }\n        }\n        _toolBarClick(e) {\n            this.trigger('toolBarClick', e);\n            this._destroyToolBar();\n        }\n        _normalizePointZoom(point) {\n            return point.times(1 / this.zoom());\n        }\n        _initialize() {\n            this.shapes.length = 0;\n            this.connections.length = 0;\n            this._selectedItems.length = 0;\n            Object.keys(this._dataMap).forEach((key) => {\n                delete this._dataMap[key];\n            });\n            Object.keys(this._connectionsDataMap).forEach((key) => {\n                delete this._connectionsDataMap[key];\n            });\n            this._deferredConnectionUpdates.length = 0;\n            this.undoRedoService = new UndoRedoService({\n                undone: this._syncChanges.bind(this),\n                redone: this._syncChanges.bind(this)\n            });\n            this.id = randomId();\n        }\n        _redrawConnections() {\n            const connections = this.connections;\n            for (let idx = 0; idx < connections.length; idx++) {\n                connections[idx].refresh();\n            }\n        }\n        _adorn(adorner, isActive) {\n            if (isActive !== undefined && adorner) {\n                if (isActive) {\n                    this._adorners.push(adorner);\n                    this.adornerLayer.append(adorner.visual);\n                }\n                else {\n                    remove(this._adorners, adorner);\n                    this.adornerLayer.remove(adorner.visual);\n                }\n            }\n        }\n        _showConnectors(shape, value) {\n            if (value) {\n                this._connectorsAdorner.show(shape);\n            }\n            else {\n                this._connectorsAdorner.destroy();\n            }\n        }\n        _updateAdorners() {\n            const adorners = this._adorners;\n            for (let i = 0; i < adorners.length; i++) {\n                const adorner = adorners[i];\n                if (adorner.refreshBounds) {\n                    adorner.refreshBounds();\n                }\n                adorner.refresh();\n            }\n        }\n        _refresh() {\n            for (let i = 0; i < this.connections.length; i++) {\n                this.connections[i].refresh();\n            }\n        }\n        _removeItem(item, undoable, removedConnections) {\n            item.select(false);\n            if (item instanceof Shape) {\n                this._removeShapeDataItem(item);\n                this._removeShape(item, undoable, removedConnections);\n            }\n            else if (item instanceof Connection) {\n                this._removeConnectionDataItem(item);\n                this._removeConnection(item, undoable);\n            }\n            this.mainLayer.remove(item.visual);\n        }\n        _removeConnectionDataItem(item) {\n            if (this._isEditable) {\n                this.options._removeConnectionDataItem(item.dataItem);\n                delete this._connectionsDataMap[item.dataItem.uid];\n            }\n        }\n        _removeShapeDataItem(item) {\n            if (this._isEditable) {\n                this.options._removeShapeDataItem(item.dataItem);\n                delete this._dataMap[item.dataItem.id];\n            }\n        }\n        _removeShape(shape, undoable, removedConnections) {\n            let i, connection, connector;\n            const sources = [], targets = [];\n            this.toolService._removeHover();\n            if (undoable) {\n                this.undoRedoService.addCompositeItem(new DeleteShapeUnit(shape));\n            }\n            remove(this.shapes, shape);\n            this._shapesQuadTree.remove(shape);\n            for (i = 0; i < shape.connectors.length; i++) {\n                connector = shape.connectors[i];\n                for (let j = 0; j < connector.connections.length; j++) {\n                    connection = connector.connections[j];\n                    if (!removedConnections || !contains(removedConnections, connection)) {\n                        if (connection.sourceConnector === connector) {\n                            sources.push(connection);\n                        }\n                        else if (connection.targetConnector === connector) {\n                            targets.push(connection);\n                        }\n                    }\n                }\n            }\n            for (i = 0; i < sources.length; i++) {\n                sources[i].source(null, undoable);\n                sources[i].updateModel();\n            }\n            for (i = 0; i < targets.length; i++) {\n                targets[i].target(null, undoable);\n                targets[i].updateModel();\n            }\n        }\n        _removeConnection(connection, undoable) {\n            if (connection.sourceConnector) {\n                remove(connection.sourceConnector.connections, connection);\n            }\n            if (connection.targetConnector) {\n                remove(connection.targetConnector.connections, connection);\n            }\n            if (undoable) {\n                this.undoRedoService.addCompositeItem(new DeleteConnectionUnit(connection));\n            }\n            remove(this.connections, connection);\n        }\n        _removeShapeConnections(shape) {\n            const connections = shape.connections();\n            let idx;\n            if (connections) {\n                for (idx = 0; idx < connections.length; idx++) {\n                    this._removeItem(connections[idx], false);\n                }\n            }\n        }\n        _destroyToolBar() {\n            this.options.destroyToolBar();\n        }\n        _destroyGlobalToolBar() {\n            if (this.toolBar) {\n                this.toolBar = null;\n            }\n        }\n        _mobileOS() {\n            return kendo_common_cmn_chunk_js.m;\n        }\n        exportDOMVisual() {\n            const viewBox = this.canvas._viewBox;\n            const scrollOffset = kendo_drawing_cmn_chunk_js.t()\n                .translate(-viewBox.x, -viewBox.y);\n            const viewRect = new kendo_drawing_cmn_chunk_js.R([0, 0], [viewBox.width, viewBox.height]);\n            const clipPath = kendo_drawing_cmn_chunk_js.b.fromRect(viewRect);\n            const wrap = new kendo_drawing_cmn_chunk_js.G({ transform: scrollOffset });\n            const clipWrap = new kendo_drawing_cmn_chunk_js.G({ clip: clipPath });\n            const root = this.canvas.drawingElement.children[0];\n            clipWrap.append(wrap);\n            // Don't reparent the root\n            wrap.children.push(root);\n            return clipWrap;\n        }\n        exportVisual() {\n            const scaleX = 1 / this._zoom;\n            const scale = kendo_drawing_cmn_chunk_js.t().scale(scaleX, scaleX);\n            const wrap = new kendo_drawing_cmn_chunk_js.G({\n                transform: scale\n            });\n            const root = this.mainLayer.drawingElement;\n            wrap.children.push(root);\n            return wrap;\n        }\n        updateConnectionModel(connection, syncChanges) {\n            if (this.options.updateConnectionModel) {\n                return this.options.updateConnectionModel(connection, syncChanges);\n            }\n        }\n        updateShapeModel(shape, syncChanges) {\n            if (this.options.updateShapeModel) {\n                return this.options.updateShapeModel(shape, syncChanges);\n            }\n        }\n    }\n\n    const elementStyles = (element) => element.ownerDocument.defaultView.getComputedStyle(element);\n    const cache = {};\n    const toColor = (colorMix, element) => {\n        if (cache[colorMix]) {\n            return cache[colorMix];\n        }\n        const curColor = element.style.color;\n        element.style.color = colorMix;\n        const color = elementStyles(element).color;\n        element.style.color = curColor;\n        cache[colorMix] = color;\n        return color;\n    };\n    const getProp = (element, prop) => {\n        let value = elementStyles(element).getPropertyValue(prop);\n        if (/^color-mix/i.test(value)) {\n            value = toColor(value, element);\n        }\n        return value;\n    };\n    const loadTheme = (element) => {\n        const primaryBg = getProp(element, '--kendo-chart-primary-bg');\n        const primaryContrast = getProp(element, '--kendo-chart-primary-contrast');\n        const normalTextColor = getProp(element, '--kendo-chart-text');\n        const normalBackground = getProp(element, '--kendo-color-surface');\n        return {\n            shapeDefaults: {\n                fill: {\n                    color: primaryBg\n                },\n                content: {\n                    color: primaryContrast\n                },\n                connectorDefaults: {\n                    fill: {\n                        color: normalTextColor\n                    },\n                    stroke: {\n                        color: primaryContrast\n                    },\n                    hover: {\n                        fill: {\n                            color: primaryContrast\n                        },\n                        stroke: {\n                            color: normalTextColor\n                        }\n                    }\n                }\n            },\n            editable: {\n                resize: {\n                    handles: {\n                        stroke: {\n                            color: normalTextColor\n                        },\n                        fill: {\n                            color: normalBackground\n                        },\n                        hover: {\n                            stroke: {\n                                color: normalTextColor\n                            },\n                            fill: {\n                                color: normalTextColor\n                            }\n                        }\n                    }\n                }\n            },\n            selectable: {\n                stroke: {\n                    color: normalTextColor\n                }\n            },\n            connectionDefaults: {\n                stroke: {\n                    color: normalTextColor\n                },\n                content: {\n                    color: normalTextColor\n                },\n                selection: {\n                    handles: {\n                        fill: {\n                            color: primaryContrast\n                        },\n                        stroke: {\n                            color: normalTextColor\n                        },\n                        width: 8,\n                        height: 8\n                    },\n                    stroke: {\n                        color: normalTextColor\n                    }\n                }\n            }\n        };\n    };\n\n    exports.$ = ConnectionEditUnit;\n    exports.A = ArrowMarker;\n    exports.B = RotateUnit;\n    exports.C = Canvas$1;\n    exports.D = Dictionary;\n    exports.E = Element;\n    exports.F = ConnectionEditTool;\n    exports.G = Graph;\n    exports.H = HashTable;\n    exports.I = Intersect;\n    exports.J = PointerTool;\n    exports.K = ScrollerTool;\n    exports.L = Link;\n    exports.M = MatrixVector;\n    exports.N = Node$1;\n    exports.O = SelectionTool;\n    exports.P = PathDefiner;\n    exports.Q = Queue;\n    exports.R = Range;\n    exports.S = Set$1;\n    exports.T = Ticker;\n    exports.U = Utils$1;\n    exports.V = VisualBase;\n    exports.W = CascadingRouter;\n    exports.X = PolylineRouter;\n    exports.Y = ConnectionRouterBase;\n    exports.Z = ToBackUnit;\n    exports._ = ToFrontUnit;\n    exports.__meta__ = __meta__;\n    exports.a = Matrix;\n    exports.a0 = LayoutUndoUnit;\n    exports.a1 = ConnectorsAdorner;\n    exports.a2 = ToolService;\n    exports.a3 = Selector;\n    exports.a4 = ResizingAdorner;\n    exports.a5 = UndoRedoService;\n    exports.a6 = ConnectorVisual;\n    exports.a7 = ConnectionTool;\n    exports.a8 = ConnectionEditAdorner;\n    exports.a9 = DeleteConnectionUnit;\n    exports.aa = DeleteShapeUnit;\n    exports.ab = AddConnectionUnit;\n    exports.ac = AddShapeUnit;\n    exports.ad = PanUndoUnit;\n    exports.ae = TransformUnit;\n    exports.af = CompositeUnit;\n    exports.ag = LayoutState;\n    exports.ah = LayoutBase;\n    exports.ai = LayeredLayout;\n    exports.aj = DiagramToHyperTreeAdapter;\n    exports.ak = TreeLayout;\n    exports.al = SpringLayout;\n    exports.am = DefaultConnectors;\n    exports.an = shapeDefaults;\n    exports.ao = defined;\n    exports.ap = Shape;\n    exports.aq = events;\n    exports.ar = Connection;\n    exports.as = first;\n    exports.at = defaultOptions;\n    exports.au = Diagram;\n    exports.av = ShapesQuadTree;\n    exports.aw = QuadRoot;\n    exports.ax = QuadNode;\n    exports.ay = Connector;\n    exports.b = RectAlign;\n    exports.c = Size;\n    exports.d = Rect;\n    exports.e = Geometry;\n    exports.f = Point;\n    exports.g = Image;\n    exports.h = TextBlock;\n    exports.i = CompositeTransform;\n    exports.j = Polyline;\n    exports.k = CircleMarker;\n    exports.l = MarkerBase;\n    exports.m = Line;\n    exports.n = normalVariable;\n    exports.o = Layout;\n    exports.p = Path;\n    exports.q = Rectangle;\n    exports.r = randomId;\n    exports.s = Group;\n    exports.t = Circle;\n    exports.u = Rotation;\n    exports.v = Translation;\n    exports.w = Scale;\n    exports.x = Markers;\n    exports.y = diffNumericOptions;\n    exports.z = Cursors;\n\n}));\n"]}